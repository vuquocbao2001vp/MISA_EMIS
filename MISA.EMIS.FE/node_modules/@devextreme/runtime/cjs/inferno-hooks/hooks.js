"use strict";
// Based on https://github.com/chrisdavies/xferno by Chris Davies
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/no-non-null-assertion */
var inferno_1 = require("inferno");
var shallow_equal_1 = require("./shallow-equal");
var emptyProps = {};
var currentComponent;
function renderChild(component, _a, context) {
    var renderFn = _a.renderFn, renderProps = _a.renderProps;
    var prevRecorder = currentComponent;
    currentComponent = component;
    try {
        return renderFn(renderProps || emptyProps, context);
    }
    finally {
        currentComponent = prevRecorder;
    }
}
function createRecorder(component) {
    var nextId = 0;
    var hookInstances = [];
    var shouldUpdate = true;
    component.state = {};
    function nextHook(dependencies) {
        var id = nextId;
        nextId += 1;
        var hook = hookInstances[id];
        if (hook && shallow_equal_1.equal(hook.dependencies, dependencies)) {
            hook.isNew = false;
            return hook;
        }
        if (hook && hook.dispose) {
            hook.dispose();
        }
        hook = {
            id: id,
            isNew: true,
            dependencies: dependencies,
            didMount: hook && hook.didMount,
        };
        hookInstances[id] = hook;
        return hook;
    }
    var recorder = {
        renderResult: undefined,
        getHook: function (dependencies, fn) {
            var hook = nextHook(dependencies);
            var value = hook.value;
            fn(hook);
            shouldUpdate = shouldUpdate || !shallow_equal_1.equal(hook.value, value);
            return hook.value;
        },
        shouldComponentUpdate: function (nextProps, nextState, context) {
            shouldUpdate = !shallow_equal_1.equal(component.props.renderProps, nextProps.renderProps);
            component.state = nextState;
            nextId = 0;
            var renderResult = renderChild(component, nextProps, context);
            if (shouldUpdate) {
                recorder.renderResult = renderResult;
            }
            return shouldUpdate;
        },
        dispose: function () {
            hookInstances.forEach(function (hook) { return hook && hook.dispose && hook.dispose(); });
        },
        didMount: function () {
            hookInstances.forEach(function (hook) {
                if (hook.didMount) {
                    hook.didMount();
                    hook.didMount = true;
                }
            });
        },
    };
    return recorder;
}
var HookComponent = /** @class */ (function (_super) {
    __extends(HookComponent, _super);
    function HookComponent(props) {
        var _this = _super.call(this, props) || this;
        _this.state = null;
        return _this;
    }
    HookComponent.prototype.componentDidMount = function () {
        if (this.recorder) {
            this.recorder.didMount();
        }
    };
    HookComponent.prototype.UNSAFE_componentWillReceiveProps = function (_a) {
        var renderFn = _a.renderFn;
        if (renderFn !== this.props.renderFn) {
            this.dispose();
        }
    };
    HookComponent.prototype.shouldComponentUpdate = function (nextProps, nextState, context) {
        if (!this.recorder) {
            return true;
        }
        return this.recorder.shouldComponentUpdate(nextProps, nextState, context);
    };
    HookComponent.prototype.componentWillUnmount = function () {
        this.dispose();
    };
    HookComponent.prototype.getHook = function (dependencies, fn) {
        if (!this.recorder) {
            this.recorder = createRecorder(this);
        }
        return this.recorder.getHook(dependencies, fn);
    };
    HookComponent.prototype.getContextValue = function (consumer) {
        return this.context[consumer.id];
    };
    HookComponent.prototype.dispose = function () {
        if (this.recorder) {
            this.recorder.dispose();
        }
        this.state = null;
        this.recorder = undefined;
    };
    HookComponent.prototype.render = function () {
        return this.recorder
            ? this.recorder.renderResult
            : renderChild(this, this.props, this.context);
    };
    return HookComponent;
}(inferno_1.Component));
exports.HookComponent = HookComponent;
function useState(initialState) {
    return currentComponent.getHook(0, function (hook) {
        if (hook.isNew) {
            currentComponent.state[hook.id] = initialState instanceof Function
                ? initialState()
                : initialState;
            var component_1 = currentComponent;
            hook.$setState = function (setter) {
                var state = component_1.state[hook.id];
                var nextState = typeof setter === 'function' ? setter(component_1.state[hook.id]) : setter;
                if (state === nextState) {
                    return undefined;
                }
                return component_1.setState(function (s) {
                    s[hook.id] = nextState;
                    return s;
                });
            };
        }
        hook.value = [currentComponent.state[hook.id], hook.$setState];
    });
}
exports.useState = useState;
function useEffect(fn, dependencies) {
    return currentComponent.getHook(dependencies, function (hook) {
        if (hook.isNew) {
            if (hook.didMount) {
                hook.dispose = fn();
            }
            else {
                hook.didMount = function () {
                    hook.dispose = fn();
                };
            }
        }
    });
}
exports.useEffect = useEffect;
function useMemo(fn, dependencies) {
    return currentComponent.getHook(dependencies, function (hook) {
        if (hook.isNew) {
            hook.value = fn();
        }
    });
}
exports.useMemo = useMemo;
function useCallback(fn, dependencies) {
    return currentComponent.getHook(dependencies, function (hook) {
        if (hook.isNew) {
            hook.value = fn;
        }
    });
}
exports.useCallback = useCallback;
function useImperativeHandle(ref, init, dependencies) {
    return currentComponent.getHook(dependencies, function (hook) {
        if (hook.isNew && ref) {
            ref.current = init();
        }
    });
}
exports.useImperativeHandle = useImperativeHandle;
function useContext(consumer) {
    return currentComponent.getContextValue(consumer);
}
exports.useContext = useContext;
function useRef(initialValue) {
    return currentComponent.getHook(0, function (hook) {
        if (hook.isNew) {
            var ref_1 = { current: initialValue || null };
            hook.value = ref_1;
            hook.dispose = function () { ref_1.current = null; };
        }
    });
}
exports.useRef = useRef;
