import { Component } from 'inferno';
export interface RefObject<T> {
    current: T | null;
}
declare function createRecorder(component: HookComponent): {
    renderResult: undefined;
    getHook(dependencies: number | unknown[], fn: (arg0: any) => void): any;
    shouldComponentUpdate(nextProps: {
        renderProps?: any;
        renderFn?: any;
    }, nextState: any, context: any): boolean;
    dispose(): void;
    didMount(): void;
};
export declare class HookComponent extends Component<Record<string, unknown>, Record<string, unknown>> {
    recorder: ReturnType<typeof createRecorder> | undefined;
    constructor(props: any);
    componentDidMount(): void;
    UNSAFE_componentWillReceiveProps({ renderFn }: {
        renderFn: () => JSX.Element;
    }): void;
    shouldComponentUpdate(nextProps: Record<string, unknown>, nextState: Record<string, unknown>, context: undefined): boolean;
    componentWillUnmount(): void;
    getHook(dependencies: number | unknown[], fn: any): any;
    getContextValue(consumer: {
        id: number;
    }): unknown;
    dispose(): void;
    render(): JSX.Element;
}
declare type SetStateAction<S> = S | ((prevState: S) => S);
declare type Dispatch<A> = (value: A) => void;
export declare function useState<S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>];
export declare function useEffect(fn: () => any, dependencies: unknown[]): any;
export declare function useMemo<T>(fn: () => T, dependencies: unknown[]): T;
export declare function useCallback<T extends (...args: never[]) => unknown>(fn: T, dependencies: unknown[]): T;
export declare function useImperativeHandle(ref: any, init: () => any, dependencies?: any): any;
export declare function useContext(consumer: {
    id: number;
}): any;
export declare function useRef<T>(initialValue: T): any;
export {};
