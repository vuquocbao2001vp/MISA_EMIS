// Based on https://github.com/chrisdavies/xferno by Chris Davies
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/no-non-null-assertion */
import { Component } from 'inferno';
import { equal } from './shallow-equal';
const emptyProps = {};
let currentComponent;
function renderChild(component, { renderFn, renderProps }, context) {
    const prevRecorder = currentComponent;
    currentComponent = component;
    try {
        return renderFn(renderProps || emptyProps, context);
    }
    finally {
        currentComponent = prevRecorder;
    }
}
function createRecorder(component) {
    let nextId = 0;
    const hookInstances = [];
    let shouldUpdate = true;
    component.state = {};
    function nextHook(dependencies) {
        const id = nextId;
        nextId += 1;
        let hook = hookInstances[id];
        if (hook && equal(hook.dependencies, dependencies)) {
            hook.isNew = false;
            return hook;
        }
        if (hook && hook.dispose) {
            hook.dispose();
        }
        hook = {
            id,
            isNew: true,
            dependencies,
            didMount: hook && hook.didMount,
        };
        hookInstances[id] = hook;
        return hook;
    }
    const recorder = {
        renderResult: undefined,
        getHook(dependencies, fn) {
            const hook = nextHook(dependencies);
            const value = hook.value;
            fn(hook);
            shouldUpdate = shouldUpdate || !equal(hook.value, value);
            return hook.value;
        },
        shouldComponentUpdate(nextProps, nextState, context) {
            shouldUpdate = !equal(component.props.renderProps, nextProps.renderProps);
            component.state = nextState;
            nextId = 0;
            const renderResult = renderChild(component, nextProps, context);
            if (shouldUpdate) {
                recorder.renderResult = renderResult;
            }
            return shouldUpdate;
        },
        dispose() {
            hookInstances.forEach((hook) => hook && hook.dispose && hook.dispose());
        },
        didMount() {
            hookInstances.forEach((hook) => {
                if (hook.didMount) {
                    hook.didMount();
                    hook.didMount = true;
                }
            });
        },
    };
    return recorder;
}
export class HookComponent extends Component {
    constructor(props) {
        super(props);
        this.state = null;
    }
    componentDidMount() {
        if (this.recorder) {
            this.recorder.didMount();
        }
    }
    UNSAFE_componentWillReceiveProps({ renderFn }) {
        if (renderFn !== this.props.renderFn) {
            this.dispose();
        }
    }
    shouldComponentUpdate(nextProps, nextState, context) {
        if (!this.recorder) {
            return true;
        }
        return this.recorder.shouldComponentUpdate(nextProps, nextState, context);
    }
    componentWillUnmount() {
        this.dispose();
    }
    getHook(dependencies, fn) {
        if (!this.recorder) {
            this.recorder = createRecorder(this);
        }
        return this.recorder.getHook(dependencies, fn);
    }
    getContextValue(consumer) {
        return this.context[consumer.id];
    }
    dispose() {
        if (this.recorder) {
            this.recorder.dispose();
        }
        this.state = null;
        this.recorder = undefined;
    }
    render() {
        return this.recorder
            ? this.recorder.renderResult
            : renderChild(this, this.props, this.context);
    }
}
export function useState(initialState) {
    return currentComponent.getHook(0, (hook) => {
        if (hook.isNew) {
            currentComponent.state[hook.id] = initialState instanceof Function
                ? initialState()
                : initialState;
            const component = currentComponent;
            hook.$setState = (setter) => {
                const state = component.state[hook.id];
                const nextState = typeof setter === 'function' ? setter(component.state[hook.id]) : setter;
                if (state === nextState) {
                    return undefined;
                }
                return component.setState((s) => {
                    s[hook.id] = nextState;
                    return s;
                });
            };
        }
        hook.value = [currentComponent.state[hook.id], hook.$setState];
    });
}
export function useEffect(fn, dependencies) {
    return currentComponent.getHook(dependencies, (hook) => {
        if (hook.isNew) {
            if (hook.didMount) {
                hook.dispose = fn();
            }
            else {
                hook.didMount = () => {
                    hook.dispose = fn();
                };
            }
        }
    });
}
export function useMemo(fn, dependencies) {
    return currentComponent.getHook(dependencies, (hook) => {
        if (hook.isNew) {
            hook.value = fn();
        }
    });
}
export function useCallback(fn, dependencies) {
    return currentComponent.getHook(dependencies, (hook) => {
        if (hook.isNew) {
            hook.value = fn;
        }
    });
}
export function useImperativeHandle(ref, init, dependencies) {
    return currentComponent.getHook(dependencies, (hook) => {
        if (hook.isNew && ref) {
            ref.current = init();
        }
    });
}
export function useContext(consumer) {
    return currentComponent.getContextValue(consumer);
}
export function useRef(initialValue) {
    return currentComponent.getHook(0, (hook) => {
        if (hook.isNew) {
            const ref = { current: initialValue || null };
            hook.value = ref;
            hook.dispose = () => { ref.current = null; };
        }
    });
}
