/*!
 * devextreme-vue
 * Version: 22.1.4
 * Build date: Fri Jul 22 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-vue
 */

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.discover = exports.mountTemplate = void 0;
var vue_helper_1 = require("./vue-helper");
var vue_1 = require("vue");
var TEMPLATE_PROP = "template";
function asConfigurable(component) {
    var componentOptions = component;
    if (!componentOptions) {
        return;
    }
    if (!componentOptions.$_config || !componentOptions.$_config.name) {
        return undefined;
    }
    return componentOptions;
}
function hasTemplate(component) {
    return TEMPLATE_PROP in component.type.props && vue_helper_1.configurationTemplate(component);
}
function discover(component) {
    var templates = {};
    var namedTeplates = vue_helper_1.declaredTemplates(component);
    for (var slotName in namedTeplates) {
        if (slotName === "default" && component.$slots.default) {
            continue;
        }
        var slot = namedTeplates[slotName];
        if (!slot) {
            continue;
        }
        templates[slotName] = slot;
    }
    var componentChildren = vue_helper_1.getChildren(component);
    for (var _i = 0, componentChildren_1 = componentChildren; _i < componentChildren_1.length; _i++) {
        var childComponent = componentChildren_1[_i];
        var configurable = asConfigurable(childComponent);
        if (!configurable) {
            continue;
        }
        var defaultSlot = vue_helper_1.configurationDefaultTemplate(childComponent);
        if (!defaultSlot || !hasTemplate(childComponent)) {
            continue;
        }
        var templateName = configurable.$_config.fullPath + "." + TEMPLATE_PROP;
        templates[templateName] = defaultSlot;
    }
    return templates;
}
exports.discover = discover;
function clearConfiguration(content) {
    var newContent = [];
    content.forEach(function (item) {
        var configurable = vue_helper_1.getConfigurationOptions(item);
        if (!configurable || !configurable.$_optionName) {
            newContent.push(item);
        }
    });
    return newContent;
}
function mountTemplate(getSlot, parent, data, name, placeholder) {
    return vue_helper_1.mount({
        name: name,
        inject: ["eventBus"],
        created: function () {
            this.eventBus.add(this.$_updatedHandler);
        },
        mounted: function () {
            data.onRendered();
        },
        unmounted: function () {
            this.eventBus.remove(this.$_updatedHandler);
        },
        methods: {
            $_updatedHandler: function () {
                this.$forceUpdate();
            }
        },
        render: function () {
            var content = clearConfiguration(getSlot()(data));
            if (!content) {
                return vue_1.h("div");
            }
            return content.length > 1 ? content : content[0];
        }
    }, parent, placeholder);
}
exports.mountTemplate = mountTemplate;
