{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/series/helpers/range_data_calculator.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { unique, getAddFunction, getLog } from \"../../core/utils\";\nimport { isDefined, isObject } from \"../../../core/utils/type\";\nimport { noop } from \"../../../core/utils/common\";\nvar DISCRETE = \"discrete\";\nvar {\n  abs: abs,\n  floor: floor,\n  ceil: ceil,\n  min: min\n} = Math;\n\nfunction continuousRangeCalculator(range, minValue, maxValue) {\n  range.min = range.min < minValue ? range.min : minValue;\n  range.max = range.max > maxValue ? range.max : maxValue;\n}\n\nfunction createGetLogFunction(axisType, axis) {\n  if (\"logarithmic\" !== axisType) {\n    return null;\n  }\n\n  var base = axis.getOptions().logarithmBase;\n  return value => {\n    var log = getLog(abs(value), base);\n    var round = log < 0 ? floor : ceil;\n    return round(log);\n  };\n}\n\nfunction getRangeCalculator(axisType, axis, getLog) {\n  var rangeCalculator = continuousRangeCalculator;\n\n  if (axisType === DISCRETE) {\n    rangeCalculator = function (range, minValue, maxValue) {\n      if (minValue !== maxValue) {\n        range.categories.push(maxValue);\n      }\n\n      range.categories.push(minValue);\n    };\n  } else if (axis) {\n    rangeCalculator = function (range, value) {\n      var interval = axis.calculateInterval(value, range.prevValue);\n      var minInterval = range.interval;\n      range.interval = (minInterval < interval ? minInterval : interval) || minInterval;\n      range.prevValue = value;\n      continuousRangeCalculator(range, value, value);\n    };\n  }\n\n  if (getLog) {\n    return (range, minValue, maxValue) => {\n      var minArgs = [];\n      rangeCalculator(range, minValue, maxValue);\n      0 !== minValue && minArgs.push(getLog(minValue));\n      0 !== maxValue && minArgs.push(getLog(maxValue));\n      var linearThreshold = min.apply(null, minArgs);\n      range.linearThreshold = range.linearThreshold < linearThreshold ? range.linearThreshold : linearThreshold;\n    };\n  }\n\n  return rangeCalculator;\n}\n\nfunction getInitialRange(axisType, dataType, firstValue) {\n  var range = {\n    axisType: axisType,\n    dataType: dataType\n  };\n\n  if (axisType === DISCRETE) {\n    range.categories = [];\n  } else {\n    range.min = isObject(firstValue) ? firstValue.min : firstValue;\n    range.max = isObject(firstValue) ? firstValue.max : firstValue;\n  }\n\n  return range;\n}\n\nfunction processCategories(range) {\n  if (range.categories) {\n    range.categories = unique(range.categories);\n  }\n\n  return range;\n}\n\nfunction getValueForArgument(point, extraPoint, x, range) {\n  if (extraPoint && isDefined(extraPoint.value)) {\n    var y1 = point.value;\n    var y2 = extraPoint.value;\n    var x1 = point.argument;\n    var x2 = extraPoint.argument;\n    var r = (x - x1) * (y2 - y1) / (x2 - x1) + y1.valueOf();\n    return \"datetime\" === range.dataType ? new Date(r) : r;\n  } else {\n    return point.value;\n  }\n}\n\nfunction calculateRangeBetweenPoints(rangeCalculator, range, point, prevPoint, bound) {\n  var value = getValueForArgument(point, prevPoint, bound, range);\n  rangeCalculator(range, value, value);\n}\n\nfunction isLineSeries(series) {\n  return series.type.toLowerCase().indexOf(\"line\") >= 0 || series.type.toLowerCase().indexOf(\"area\") >= 0;\n}\n\nfunction getViewportReducer(series) {\n  var rangeCalculator = getRangeCalculator(series.valueAxisType);\n  var argumentAxis = series.getArgumentAxis();\n  var viewport = argumentAxis && series.getArgumentAxis().visualRange() || {};\n  var calculatePointBetweenPoints = isLineSeries(series) ? calculateRangeBetweenPoints : noop;\n\n  if (argumentAxis && argumentAxis.getMarginOptions().checkInterval) {\n    var range = series.getArgumentAxis().getTranslator().getBusinessRange();\n    var add = getAddFunction(range, false);\n    var interval = range.interval;\n\n    if (isFinite(interval) && isDefined(viewport.startValue) && isDefined(viewport.endValue)) {\n      viewport.startValue = add(viewport.startValue, interval, -1);\n      viewport.endValue = add(viewport.endValue, interval);\n    }\n  }\n\n  var viewportFilter = getViewPortFilter(viewport);\n  return function (range, point, index, points) {\n    var argument = point.argument;\n\n    if (!point.hasValue()) {\n      return range;\n    }\n\n    if (viewportFilter(argument)) {\n      if (!range.startCalc) {\n        range.startCalc = true;\n        calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.startValue);\n      }\n\n      rangeCalculator(range, point.getMinValue(), point.getMaxValue());\n    } else if (!viewport.categories && isDefined(viewport.startValue) && argument > viewport.startValue) {\n      if (!range.startCalc) {\n        calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.startValue);\n      }\n\n      range.endCalc = true;\n      calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.endValue);\n    }\n\n    return range;\n  };\n}\n\nfunction getViewPortFilter(viewport) {\n  if (viewport.categories) {\n    var dictionary = viewport.categories.reduce((result, category) => {\n      result[category.valueOf()] = true;\n      return result;\n    }, {});\n    return argument => isDefined(argument) && dictionary[argument.valueOf()];\n  }\n\n  if (!isDefined(viewport.startValue) && !isDefined(viewport.endValue)) {\n    return () => true;\n  }\n\n  if (!isDefined(viewport.endValue)) {\n    return argument => argument >= viewport.startValue;\n  }\n\n  if (!isDefined(viewport.startValue)) {\n    return argument => argument <= viewport.endValue;\n  }\n\n  return argument => argument >= viewport.startValue && argument <= viewport.endValue;\n}\n\nexport default {\n  getViewPortFilter: getViewPortFilter,\n  getArgumentRange: function (series) {\n    var data = series._data || [];\n    var range = {};\n\n    if (data.length) {\n      if (series.argumentAxisType === DISCRETE) {\n        range = {\n          categories: data.map(item => item.argument)\n        };\n      } else {\n        var interval;\n\n        if (data.length > 1) {\n          var i1 = series.getArgumentAxis().calculateInterval(data[0].argument, data[1].argument);\n          var i2 = series.getArgumentAxis().calculateInterval(data[data.length - 1].argument, data[data.length - 2].argument);\n          interval = min(i1, i2);\n        }\n\n        range = {\n          min: data[0].argument,\n          max: data[data.length - 1].argument,\n          interval: interval\n        };\n      }\n    }\n\n    return processCategories(range);\n  },\n  getRangeData: function (series) {\n    var points = series.getPoints();\n    var useAggregation = series.useAggregation();\n    var argumentAxis = series.getArgumentAxis();\n    var argumentCalculator = getRangeCalculator(series.argumentAxisType, points.length > 1 && argumentAxis, createGetLogFunction(series.argumentAxisType, argumentAxis));\n    var valueRangeCalculator = getRangeCalculator(series.valueAxisType, null, createGetLogFunction(series.valueAxisType, series.getValueAxis()));\n    var viewportReducer = getViewportReducer(series);\n    var range = points.reduce(function (range, point, index, points) {\n      var argument = point.argument;\n\n      if (!point.isArgumentCorrect()) {\n        return range;\n      }\n\n      argumentCalculator(range.arg, argument, argument);\n\n      if (point.hasValue()) {\n        valueRangeCalculator(range.val, point.getMinValue(), point.getMaxValue());\n        viewportReducer(range.viewport, point, index, points);\n      }\n\n      return range;\n    }, {\n      arg: getInitialRange(series.argumentAxisType, series.argumentType, null !== argumentAxis && void 0 !== argumentAxis && argumentAxis.aggregatedPointBetweenTicks() ? void 0 : series.getArgumentRangeInitialValue()),\n      val: getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0),\n      viewport: getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0)\n    });\n\n    if (useAggregation) {\n      var argumentRange = this.getArgumentRange(series);\n\n      if (series.argumentAxisType === DISCRETE) {\n        range.arg = argumentRange;\n      } else {\n        var viewport = argumentAxis.getViewport();\n\n        if (isDefined(viewport.startValue) || isDefined(viewport.length)) {\n          argumentCalculator(range.arg, argumentRange.min, argumentRange.min);\n        }\n\n        if (isDefined(viewport.endValue) || isDefined(viewport.length) && isDefined(viewport.startValue)) {\n          argumentCalculator(range.arg, argumentRange.max, argumentRange.max);\n        }\n      }\n    }\n\n    processCategories(range.arg);\n    processCategories(range.val);\n    return range;\n  },\n  getViewport: function (series) {\n    var points = series.getPoints();\n    var range;\n    var reducer = getViewportReducer(series);\n    range = getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0);\n    points.some(function (point, index) {\n      reducer(range, point, index, points);\n      return range.endCalc;\n    });\n    return range;\n  },\n  getPointsInViewPort: function (series) {\n    var argumentViewPortFilter = getViewPortFilter(series.getArgumentAxis().visualRange() || {});\n    var valueViewPort = series.getValueAxis().visualRange() || {};\n    var valueViewPortFilter = getViewPortFilter(valueViewPort);\n    var points = series.getPoints();\n\n    var addValue = function (values, point, isEdge) {\n      var minValue = point.getMinValue();\n      var maxValue = point.getMaxValue();\n      var isMinValueInViewPort = valueViewPortFilter(minValue);\n      var isMaxValueInViewPort = valueViewPortFilter(maxValue);\n\n      if (isMinValueInViewPort) {\n        values.push(minValue);\n      }\n\n      if (maxValue !== minValue && isMaxValueInViewPort) {\n        values.push(maxValue);\n      }\n\n      if (isEdge && !isMinValueInViewPort && !isMaxValueInViewPort) {\n        if (!values.length) {\n          values.push(valueViewPort.startValue);\n        } else {\n          values.push(valueViewPort.endValue);\n        }\n      }\n    };\n\n    var addEdgePoints = isLineSeries(series) ? function (result, points, index) {\n      var point = points[index];\n      var prevPoint = points[index - 1];\n      var nextPoint = points[index + 1];\n\n      if (nextPoint && argumentViewPortFilter(nextPoint.argument)) {\n        addValue(result[1], point, true);\n      }\n\n      if (prevPoint && argumentViewPortFilter(prevPoint.argument)) {\n        addValue(result[1], point, true);\n      }\n    } : noop;\n    return points.reduce(function (result, point, index) {\n      if (argumentViewPortFilter(point.argument)) {\n        addValue(result[0], point);\n      } else {\n        addEdgePoints(result, points, index);\n      }\n\n      return result;\n    }, [[], []]);\n  }\n};","map":{"version":3,"names":["unique","getAddFunction","getLog","isDefined","isObject","noop","DISCRETE","abs","floor","ceil","min","Math","continuousRangeCalculator","range","minValue","maxValue","max","createGetLogFunction","axisType","axis","base","getOptions","logarithmBase","value","log","round","getRangeCalculator","rangeCalculator","categories","push","interval","calculateInterval","prevValue","minInterval","minArgs","linearThreshold","apply","getInitialRange","dataType","firstValue","processCategories","getValueForArgument","point","extraPoint","x","y1","y2","x1","argument","x2","r","valueOf","Date","calculateRangeBetweenPoints","prevPoint","bound","isLineSeries","series","type","toLowerCase","indexOf","getViewportReducer","valueAxisType","argumentAxis","getArgumentAxis","viewport","visualRange","calculatePointBetweenPoints","getMarginOptions","checkInterval","getTranslator","getBusinessRange","add","isFinite","startValue","endValue","viewportFilter","getViewPortFilter","index","points","hasValue","startCalc","getMinValue","getMaxValue","endCalc","dictionary","reduce","result","category","getArgumentRange","data","_data","length","argumentAxisType","map","item","i1","i2","getRangeData","getPoints","useAggregation","argumentCalculator","valueRangeCalculator","getValueAxis","viewportReducer","isArgumentCorrect","arg","val","argumentType","aggregatedPointBetweenTicks","getArgumentRangeInitialValue","valueType","getValueRangeInitialValue","argumentRange","getViewport","reducer","some","getPointsInViewPort","argumentViewPortFilter","valueViewPort","valueViewPortFilter","addValue","values","isEdge","isMinValueInViewPort","isMaxValueInViewPort","addEdgePoints","nextPoint"],"sources":["E:/MisaProject/W2022_06/misa_emis/node_modules/devextreme/esm/viz/series/helpers/range_data_calculator.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/viz/series/helpers/range_data_calculator.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    unique,\r\n    getAddFunction,\r\n    getLog\r\n} from \"../../core/utils\";\r\nimport {\r\n    isDefined,\r\n    isObject\r\n} from \"../../../core/utils/type\";\r\nimport {\r\n    noop\r\n} from \"../../../core/utils/common\";\r\nvar DISCRETE = \"discrete\";\r\nvar {\r\n    abs: abs,\r\n    floor: floor,\r\n    ceil: ceil,\r\n    min: min\r\n} = Math;\r\n\r\nfunction continuousRangeCalculator(range, minValue, maxValue) {\r\n    range.min = range.min < minValue ? range.min : minValue;\r\n    range.max = range.max > maxValue ? range.max : maxValue\r\n}\r\n\r\nfunction createGetLogFunction(axisType, axis) {\r\n    if (\"logarithmic\" !== axisType) {\r\n        return null\r\n    }\r\n    var base = axis.getOptions().logarithmBase;\r\n    return value => {\r\n        var log = getLog(abs(value), base);\r\n        var round = log < 0 ? floor : ceil;\r\n        return round(log)\r\n    }\r\n}\r\n\r\nfunction getRangeCalculator(axisType, axis, getLog) {\r\n    var rangeCalculator = continuousRangeCalculator;\r\n    if (axisType === DISCRETE) {\r\n        rangeCalculator = function(range, minValue, maxValue) {\r\n            if (minValue !== maxValue) {\r\n                range.categories.push(maxValue)\r\n            }\r\n            range.categories.push(minValue)\r\n        }\r\n    } else if (axis) {\r\n        rangeCalculator = function(range, value) {\r\n            var interval = axis.calculateInterval(value, range.prevValue);\r\n            var minInterval = range.interval;\r\n            range.interval = (minInterval < interval ? minInterval : interval) || minInterval;\r\n            range.prevValue = value;\r\n            continuousRangeCalculator(range, value, value)\r\n        }\r\n    }\r\n    if (getLog) {\r\n        return (range, minValue, maxValue) => {\r\n            var minArgs = [];\r\n            rangeCalculator(range, minValue, maxValue);\r\n            0 !== minValue && minArgs.push(getLog(minValue));\r\n            0 !== maxValue && minArgs.push(getLog(maxValue));\r\n            var linearThreshold = min.apply(null, minArgs);\r\n            range.linearThreshold = range.linearThreshold < linearThreshold ? range.linearThreshold : linearThreshold\r\n        }\r\n    }\r\n    return rangeCalculator\r\n}\r\n\r\nfunction getInitialRange(axisType, dataType, firstValue) {\r\n    var range = {\r\n        axisType: axisType,\r\n        dataType: dataType\r\n    };\r\n    if (axisType === DISCRETE) {\r\n        range.categories = []\r\n    } else {\r\n        range.min = isObject(firstValue) ? firstValue.min : firstValue;\r\n        range.max = isObject(firstValue) ? firstValue.max : firstValue\r\n    }\r\n    return range\r\n}\r\n\r\nfunction processCategories(range) {\r\n    if (range.categories) {\r\n        range.categories = unique(range.categories)\r\n    }\r\n    return range\r\n}\r\n\r\nfunction getValueForArgument(point, extraPoint, x, range) {\r\n    if (extraPoint && isDefined(extraPoint.value)) {\r\n        var y1 = point.value;\r\n        var y2 = extraPoint.value;\r\n        var x1 = point.argument;\r\n        var x2 = extraPoint.argument;\r\n        var r = (x - x1) * (y2 - y1) / (x2 - x1) + y1.valueOf();\r\n        return \"datetime\" === range.dataType ? new Date(r) : r\r\n    } else {\r\n        return point.value\r\n    }\r\n}\r\n\r\nfunction calculateRangeBetweenPoints(rangeCalculator, range, point, prevPoint, bound) {\r\n    var value = getValueForArgument(point, prevPoint, bound, range);\r\n    rangeCalculator(range, value, value)\r\n}\r\n\r\nfunction isLineSeries(series) {\r\n    return series.type.toLowerCase().indexOf(\"line\") >= 0 || series.type.toLowerCase().indexOf(\"area\") >= 0\r\n}\r\n\r\nfunction getViewportReducer(series) {\r\n    var rangeCalculator = getRangeCalculator(series.valueAxisType);\r\n    var argumentAxis = series.getArgumentAxis();\r\n    var viewport = argumentAxis && series.getArgumentAxis().visualRange() || {};\r\n    var calculatePointBetweenPoints = isLineSeries(series) ? calculateRangeBetweenPoints : noop;\r\n    if (argumentAxis && argumentAxis.getMarginOptions().checkInterval) {\r\n        var range = series.getArgumentAxis().getTranslator().getBusinessRange();\r\n        var add = getAddFunction(range, false);\r\n        var interval = range.interval;\r\n        if (isFinite(interval) && isDefined(viewport.startValue) && isDefined(viewport.endValue)) {\r\n            viewport.startValue = add(viewport.startValue, interval, -1);\r\n            viewport.endValue = add(viewport.endValue, interval)\r\n        }\r\n    }\r\n    var viewportFilter = getViewPortFilter(viewport);\r\n    return function(range, point, index, points) {\r\n        var argument = point.argument;\r\n        if (!point.hasValue()) {\r\n            return range\r\n        }\r\n        if (viewportFilter(argument)) {\r\n            if (!range.startCalc) {\r\n                range.startCalc = true;\r\n                calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.startValue)\r\n            }\r\n            rangeCalculator(range, point.getMinValue(), point.getMaxValue())\r\n        } else if (!viewport.categories && isDefined(viewport.startValue) && argument > viewport.startValue) {\r\n            if (!range.startCalc) {\r\n                calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.startValue)\r\n            }\r\n            range.endCalc = true;\r\n            calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.endValue)\r\n        }\r\n        return range\r\n    }\r\n}\r\n\r\nfunction getViewPortFilter(viewport) {\r\n    if (viewport.categories) {\r\n        var dictionary = viewport.categories.reduce((result, category) => {\r\n            result[category.valueOf()] = true;\r\n            return result\r\n        }, {});\r\n        return argument => isDefined(argument) && dictionary[argument.valueOf()]\r\n    }\r\n    if (!isDefined(viewport.startValue) && !isDefined(viewport.endValue)) {\r\n        return () => true\r\n    }\r\n    if (!isDefined(viewport.endValue)) {\r\n        return argument => argument >= viewport.startValue\r\n    }\r\n    if (!isDefined(viewport.startValue)) {\r\n        return argument => argument <= viewport.endValue\r\n    }\r\n    return argument => argument >= viewport.startValue && argument <= viewport.endValue\r\n}\r\nexport default {\r\n    getViewPortFilter: getViewPortFilter,\r\n    getArgumentRange: function(series) {\r\n        var data = series._data || [];\r\n        var range = {};\r\n        if (data.length) {\r\n            if (series.argumentAxisType === DISCRETE) {\r\n                range = {\r\n                    categories: data.map(item => item.argument)\r\n                }\r\n            } else {\r\n                var interval;\r\n                if (data.length > 1) {\r\n                    var i1 = series.getArgumentAxis().calculateInterval(data[0].argument, data[1].argument);\r\n                    var i2 = series.getArgumentAxis().calculateInterval(data[data.length - 1].argument, data[data.length - 2].argument);\r\n                    interval = min(i1, i2)\r\n                }\r\n                range = {\r\n                    min: data[0].argument,\r\n                    max: data[data.length - 1].argument,\r\n                    interval: interval\r\n                }\r\n            }\r\n        }\r\n        return processCategories(range)\r\n    },\r\n    getRangeData: function(series) {\r\n        var points = series.getPoints();\r\n        var useAggregation = series.useAggregation();\r\n        var argumentAxis = series.getArgumentAxis();\r\n        var argumentCalculator = getRangeCalculator(series.argumentAxisType, points.length > 1 && argumentAxis, createGetLogFunction(series.argumentAxisType, argumentAxis));\r\n        var valueRangeCalculator = getRangeCalculator(series.valueAxisType, null, createGetLogFunction(series.valueAxisType, series.getValueAxis()));\r\n        var viewportReducer = getViewportReducer(series);\r\n        var range = points.reduce((function(range, point, index, points) {\r\n            var argument = point.argument;\r\n            if (!point.isArgumentCorrect()) {\r\n                return range\r\n            }\r\n            argumentCalculator(range.arg, argument, argument);\r\n            if (point.hasValue()) {\r\n                valueRangeCalculator(range.val, point.getMinValue(), point.getMaxValue());\r\n                viewportReducer(range.viewport, point, index, points)\r\n            }\r\n            return range\r\n        }), {\r\n            arg: getInitialRange(series.argumentAxisType, series.argumentType, null !== argumentAxis && void 0 !== argumentAxis && argumentAxis.aggregatedPointBetweenTicks() ? void 0 : series.getArgumentRangeInitialValue()),\r\n            val: getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0),\r\n            viewport: getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0)\r\n        });\r\n        if (useAggregation) {\r\n            var argumentRange = this.getArgumentRange(series);\r\n            if (series.argumentAxisType === DISCRETE) {\r\n                range.arg = argumentRange\r\n            } else {\r\n                var viewport = argumentAxis.getViewport();\r\n                if (isDefined(viewport.startValue) || isDefined(viewport.length)) {\r\n                    argumentCalculator(range.arg, argumentRange.min, argumentRange.min)\r\n                }\r\n                if (isDefined(viewport.endValue) || isDefined(viewport.length) && isDefined(viewport.startValue)) {\r\n                    argumentCalculator(range.arg, argumentRange.max, argumentRange.max)\r\n                }\r\n            }\r\n        }\r\n        processCategories(range.arg);\r\n        processCategories(range.val);\r\n        return range\r\n    },\r\n    getViewport: function(series) {\r\n        var points = series.getPoints();\r\n        var range;\r\n        var reducer = getViewportReducer(series);\r\n        range = getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0);\r\n        points.some((function(point, index) {\r\n            reducer(range, point, index, points);\r\n            return range.endCalc\r\n        }));\r\n        return range\r\n    },\r\n    getPointsInViewPort: function(series) {\r\n        var argumentViewPortFilter = getViewPortFilter(series.getArgumentAxis().visualRange() || {});\r\n        var valueViewPort = series.getValueAxis().visualRange() || {};\r\n        var valueViewPortFilter = getViewPortFilter(valueViewPort);\r\n        var points = series.getPoints();\r\n        var addValue = function(values, point, isEdge) {\r\n            var minValue = point.getMinValue();\r\n            var maxValue = point.getMaxValue();\r\n            var isMinValueInViewPort = valueViewPortFilter(minValue);\r\n            var isMaxValueInViewPort = valueViewPortFilter(maxValue);\r\n            if (isMinValueInViewPort) {\r\n                values.push(minValue)\r\n            }\r\n            if (maxValue !== minValue && isMaxValueInViewPort) {\r\n                values.push(maxValue)\r\n            }\r\n            if (isEdge && !isMinValueInViewPort && !isMaxValueInViewPort) {\r\n                if (!values.length) {\r\n                    values.push(valueViewPort.startValue)\r\n                } else {\r\n                    values.push(valueViewPort.endValue)\r\n                }\r\n            }\r\n        };\r\n        var addEdgePoints = isLineSeries(series) ? function(result, points, index) {\r\n            var point = points[index];\r\n            var prevPoint = points[index - 1];\r\n            var nextPoint = points[index + 1];\r\n            if (nextPoint && argumentViewPortFilter(nextPoint.argument)) {\r\n                addValue(result[1], point, true)\r\n            }\r\n            if (prevPoint && argumentViewPortFilter(prevPoint.argument)) {\r\n                addValue(result[1], point, true)\r\n            }\r\n        } : noop;\r\n        return points.reduce((function(result, point, index) {\r\n            if (argumentViewPortFilter(point.argument)) {\r\n                addValue(result[0], point)\r\n            } else {\r\n                addEdgePoints(result, points, index)\r\n            }\r\n            return result\r\n        }), [\r\n            [],\r\n            []\r\n        ])\r\n    }\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}