{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\n\n/**\r\n * DevExtreme (esm/viz/series/scatter_series.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { extend as _extend } from \"../../core/utils/extend\";\nimport { each as _each } from \"../../core/utils/iterator\";\nimport rangeCalculator from \"./helpers/range_data_calculator\";\nimport { isDefined as _isDefined, isString as _isString } from \"../../core/utils/type\";\nimport { map as _map, normalizeEnum as _normalizeEnum, convertXYToPolar } from \"../core/utils\";\nimport { noop as _noop } from \"../../core/utils/common\";\nvar math = Math;\nvar _abs = math.abs;\nvar _sqrt = math.sqrt;\nvar _max = math.max;\nvar DEFAULT_TRACKER_WIDTH = 12;\nvar DEFAULT_DURATION = 400;\nvar HIGH_ERROR = \"highError\";\nvar LOW_ERROR = \"lowError\";\nvar VARIANCE = \"variance\";\nvar STANDARD_DEVIATION = \"stddeviation\";\nvar STANDARD_ERROR = \"stderror\";\nvar PERCENT = \"percent\";\nvar FIXED = \"fixed\";\nvar UNDEFINED = \"undefined\";\nvar DISCRETE = \"discrete\";\nvar LOGARITHMIC = \"logarithmic\";\nvar DATETIME = \"datetime\";\nvar chart = {};\nvar polar = {};\n\nfunction sum(array) {\n  var result = 0;\n\n  _each(array, function (_, value) {\n    result += value;\n  });\n\n  return result;\n}\n\nfunction isErrorBarTypeCorrect(type) {\n  return [FIXED, PERCENT, VARIANCE, STANDARD_DEVIATION, STANDARD_ERROR].includes(type);\n}\n\nfunction variance(array, expectedValue) {\n  return sum(_map(array, function (value) {\n    return (value - expectedValue) * (value - expectedValue);\n  })) / array.length;\n}\n\nfunction calculateAvgErrorBars(result, data, series) {\n  var errorBarsOptions = series.getOptions().valueErrorBar;\n  var valueField = series.getValueFields()[0];\n  var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;\n  var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;\n\n  if (series.areErrorBarsVisible() && void 0 === errorBarsOptions.type) {\n    var fusionData = data.reduce(function (result, item) {\n      if (_isDefined(item[lowValueField])) {\n        result[0] += item[valueField] - item[lowValueField];\n        result[1]++;\n      }\n\n      if (_isDefined(item[highValueField])) {\n        result[2] += item[highValueField] - item[valueField];\n        result[3]++;\n      }\n\n      return result;\n    }, [0, 0, 0, 0]);\n\n    if (fusionData[1]) {\n      result[lowValueField] = result[valueField] - fusionData[0] / fusionData[1];\n    }\n\n    if (fusionData[2]) {\n      result[highValueField] = result[valueField] + fusionData[2] / fusionData[3];\n    }\n  }\n\n  return result;\n}\n\nfunction calculateSumErrorBars(result, data, series) {\n  var errorBarsOptions = series.getOptions().valueErrorBar;\n  var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;\n  var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;\n\n  if (series.areErrorBarsVisible() && void 0 === errorBarsOptions.type) {\n    result[lowValueField] = 0;\n    result[highValueField] = 0;\n    result = data.reduce(function (result, item) {\n      result[lowValueField] += item[lowValueField];\n      result[highValueField] += item[highValueField];\n      return result;\n    }, result);\n  }\n\n  return result;\n}\n\nfunction getMinMaxAggregator(compare) {\n  return (_ref, series) => {\n    var {\n      intervalStart: intervalStart,\n      intervalEnd: intervalEnd,\n      data: data\n    } = _ref;\n    var valueField = series.getValueFields()[0];\n    var targetData = data[0];\n    targetData = data.reduce((result, item) => {\n      var value = item[valueField];\n\n      if (null === result[valueField]) {\n        result = item;\n      }\n\n      if (null !== value && compare(value, result[valueField])) {\n        return item;\n      }\n\n      return result;\n    }, targetData);\n    return _extend({}, targetData, {\n      [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)\n    });\n  };\n}\n\nfunction checkFields(data, fieldsToCheck, skippedFields) {\n  var allFieldsIsValid = true;\n\n  for (var field in fieldsToCheck) {\n    var isArgument = \"argument\" === field;\n\n    if (isArgument || \"size\" === field ? !_isDefined(data[field]) : void 0 === data[field]) {\n      var selector = fieldsToCheck[field];\n\n      if (!isArgument) {\n        skippedFields[selector] = (skippedFields[selector] || 0) + 1;\n      }\n\n      allFieldsIsValid = false;\n    }\n  }\n\n  return allFieldsIsValid;\n}\n\nvar baseScatterMethods = {\n  _defaultDuration: DEFAULT_DURATION,\n  _defaultTrackerWidth: DEFAULT_TRACKER_WIDTH,\n  _applyStyle: _noop,\n  _updateOptions: _noop,\n  _parseStyle: _noop,\n  _prepareSegment: _noop,\n  _drawSegment: _noop,\n  _appendInGroup: function () {\n    this._group.append(this._extGroups.seriesGroup);\n  },\n  _createLegendState: function (styleOptions, defaultColor) {\n    return {\n      fill: styleOptions.color || defaultColor,\n      hatching: styleOptions.hatching ? _extend({}, styleOptions.hatching, {\n        direction: \"right\"\n      }) : void 0\n    };\n  },\n  _applyElementsClipRect: function (settings) {\n    settings[\"clip-path\"] = this._paneClipRectID;\n  },\n  _applyMarkerClipRect: function (settings) {\n    settings[\"clip-path\"] = this._forceClipping ? this._paneClipRectID : null;\n  },\n  _createGroup: function (groupName, parent, target, settings) {\n    var group = parent[groupName] = parent[groupName] || this._renderer.g();\n\n    target && group.append(target);\n    settings && group.attr(settings);\n  },\n  _applyClearingSettings: function (settings) {\n    settings.opacity = null;\n    settings.scale = null;\n\n    if (this._options.rotated) {\n      settings.translateX = null;\n    } else {\n      settings.translateY = null;\n    }\n  },\n  _createGroups: function () {\n    this._createGroup(\"_markersGroup\", this, this._group);\n\n    this._createGroup(\"_labelsGroup\", this);\n  },\n  _setMarkerGroupSettings: function () {\n    var settings = this._createPointStyles(this._getMarkerGroupOptions()).normal;\n\n    settings.class = \"dxc-markers\";\n    settings.opacity = 1;\n\n    this._applyMarkerClipRect(settings);\n\n    this._markersGroup.attr(settings);\n  },\n  getVisibleArea: function () {\n    return this._visibleArea;\n  },\n  areErrorBarsVisible: function () {\n    var errorBarOptions = this._options.valueErrorBar;\n    return errorBarOptions && this._errorBarsEnabled() && \"none\" !== errorBarOptions.displayMode && (isErrorBarTypeCorrect(_normalizeEnum(errorBarOptions.type)) || _isDefined(errorBarOptions.lowValueField) || _isDefined(errorBarOptions.highValueField));\n  },\n\n  groupPointsByCoords(rotated) {\n    var cat = [];\n\n    _each(this.getVisiblePoints(), function (_, p) {\n      var pointCoord = parseInt(rotated ? p.vy : p.vx);\n\n      if (!cat[pointCoord]) {\n        cat[pointCoord] = p;\n      } else {\n        Array.isArray(cat[pointCoord]) ? cat[pointCoord].push(p) : cat[pointCoord] = [cat[pointCoord], p];\n      }\n    });\n\n    return cat;\n  },\n\n  _createErrorBarGroup: function (animationEnabled) {\n    var errorBarOptions = this._options.valueErrorBar;\n    var settings;\n\n    if (this.areErrorBarsVisible()) {\n      settings = {\n        class: \"dxc-error-bars\",\n        stroke: errorBarOptions.color,\n        \"stroke-width\": errorBarOptions.lineWidth,\n        opacity: animationEnabled ? .001 : errorBarOptions.opacity || 1,\n        \"stroke-linecap\": \"square\",\n        sharp: true,\n        \"clip-path\": this._forceClipping ? this._paneClipRectID : this._widePaneClipRectID\n      };\n\n      this._createGroup(\"_errorBarGroup\", this, this._group, settings);\n    }\n  },\n  _setGroupsSettings: function (animationEnabled) {\n    this._setMarkerGroupSettings();\n\n    this._setLabelGroupSettings(animationEnabled);\n\n    this._createErrorBarGroup(animationEnabled);\n  },\n  _getCreatingPointOptions: function () {\n    var defaultPointOptions;\n    var creatingPointOptions = this._predefinedPointOptions;\n    var normalStyle;\n\n    if (!creatingPointOptions) {\n      defaultPointOptions = this._getPointOptions();\n      this._predefinedPointOptions = creatingPointOptions = _extend(true, {\n        styles: {}\n      }, defaultPointOptions);\n      normalStyle = defaultPointOptions.styles && defaultPointOptions.styles.normal || {};\n      creatingPointOptions.styles = creatingPointOptions.styles || {};\n      creatingPointOptions.styles.normal = {\n        \"stroke-width\": normalStyle[\"stroke-width\"],\n        r: normalStyle.r,\n        opacity: normalStyle.opacity\n      };\n    }\n\n    return creatingPointOptions;\n  },\n  _getPointOptions: function () {\n    return this._parsePointOptions(this._preparePointOptions(), this._options.label);\n  },\n  _getOptionsForPoint: function () {\n    return this._options.point;\n  },\n  _parsePointStyle: function (style, defaultColor, defaultBorderColor, defaultSize) {\n    var border = style.border || {};\n    var sizeValue = void 0 !== style.size ? style.size : defaultSize;\n    return {\n      fill: style.color || defaultColor,\n      stroke: border.color || defaultBorderColor,\n      \"stroke-width\": border.visible ? border.width : 0,\n      r: sizeValue / 2 + (border.visible && 0 !== sizeValue ? ~~(border.width / 2) || 0 : 0)\n    };\n  },\n  _createPointStyles: function (pointOptions) {\n    var mainPointColor = pointOptions.color || this._options.mainSeriesColor;\n    var containerColor = this._options.containerBackgroundColor;\n\n    var normalStyle = this._parsePointStyle(pointOptions, mainPointColor, mainPointColor);\n\n    normalStyle.visibility = pointOptions.visible ? \"visible\" : \"hidden\";\n    return {\n      normal: normalStyle,\n      hover: this._parsePointStyle(pointOptions.hoverStyle, containerColor, mainPointColor, pointOptions.size),\n      selection: this._parsePointStyle(pointOptions.selectionStyle, containerColor, mainPointColor, pointOptions.size)\n    };\n  },\n  _checkData: function (data, skippedFields, fieldsToCheck) {\n    fieldsToCheck = fieldsToCheck || {\n      value: this.getValueFields()[0]\n    };\n    fieldsToCheck.argument = this.getArgumentField();\n    return checkFields(data, fieldsToCheck, skippedFields || {}) && data.value === data.value;\n  },\n\n  getArgumentRangeInitialValue() {\n    var points = this.getPoints();\n\n    if (this.useAggregation() && points.length) {\n      var _points$0$aggregation, _points$aggregationIn;\n\n      return {\n        min: null === (_points$0$aggregation = points[0].aggregationInfo) || void 0 === _points$0$aggregation ? void 0 : _points$0$aggregation.intervalStart,\n        max: null === (_points$aggregationIn = points[points.length - 1].aggregationInfo) || void 0 === _points$aggregationIn ? void 0 : _points$aggregationIn.intervalEnd\n      };\n    }\n\n    return;\n  },\n\n  getValueRangeInitialValue: function () {\n    return;\n  },\n  _getRangeData: function () {\n    return rangeCalculator.getRangeData(this);\n  },\n  _getPointDataSelector: function () {\n    var valueField = this.getValueFields()[0];\n    var argumentField = this.getArgumentField();\n    var tagField = this.getTagField();\n    var areErrorBarsVisible = this.areErrorBarsVisible();\n    var lowValueField;\n    var highValueField;\n\n    if (areErrorBarsVisible) {\n      var errorBarOptions = this._options.valueErrorBar;\n      lowValueField = errorBarOptions.lowValueField || LOW_ERROR;\n      highValueField = errorBarOptions.highValueField || HIGH_ERROR;\n    }\n\n    return data => {\n      var pointData = {\n        value: this._processEmptyValue(data[valueField]),\n        argument: data[argumentField],\n        tag: data[tagField],\n        data: data\n      };\n\n      if (areErrorBarsVisible) {\n        pointData.lowError = data[lowValueField];\n        pointData.highError = data[highValueField];\n      }\n\n      return pointData;\n    };\n  },\n  _errorBarsEnabled: function () {\n    return this.valueAxisType !== DISCRETE && this.valueAxisType !== LOGARITHMIC && this.valueType !== DATETIME;\n  },\n  _drawPoint: function (options) {\n    var point = options.point;\n\n    if (point.isInVisibleArea()) {\n      point.clearVisibility();\n      point.draw(this._renderer, options.groups, options.hasAnimation, options.firstDrawing);\n\n      this._drawnPoints.push(point);\n    } else {\n      point.setInvisibility();\n    }\n  },\n  _animateComplete: function () {\n    var animationSettings = {\n      duration: this._defaultDuration\n    };\n    this._labelsGroup && this._labelsGroup.animate({\n      opacity: 1\n    }, animationSettings);\n    this._errorBarGroup && this._errorBarGroup.animate({\n      opacity: this._options.valueErrorBar.opacity || 1\n    }, animationSettings);\n  },\n  _animate: function () {\n    var that = this;\n    var lastPointIndex = that._drawnPoints.length - 1;\n\n    _each(that._drawnPoints || [], function (i, p) {\n      p.animate(i === lastPointIndex ? function () {\n        that._animateComplete();\n      } : void 0, {\n        translateX: p.x,\n        translateY: p.y\n      });\n    });\n  },\n\n  _getIntervalCenter(intervalStart, intervalEnd) {\n    var argAxis = this.getArgumentAxis();\n    var axisOptions = argAxis.getOptions();\n\n    if (argAxis.aggregatedPointBetweenTicks()) {\n      return intervalStart;\n    }\n\n    return \"discrete\" !== axisOptions.type ? argAxis.getVisualRangeCenter({\n      minVisible: intervalStart,\n      maxVisible: intervalEnd\n    }, true) : intervalStart;\n  },\n\n  _defaultAggregator: \"avg\",\n  _aggregators: {\n    avg(_ref2, series) {\n      var {\n        data: data,\n        intervalStart: intervalStart,\n        intervalEnd: intervalEnd\n      } = _ref2;\n\n      if (!data.length) {\n        return;\n      }\n\n      var valueField = series.getValueFields()[0];\n      var aggregationResult = data.reduce((result, item) => {\n        var value = item[valueField];\n\n        if (_isDefined(value)) {\n          result[0] += value;\n          result[1]++;\n        } else if (null === value) {\n          result[2]++;\n        }\n\n        return result;\n      }, [0, 0, 0]);\n      return calculateAvgErrorBars({\n        [valueField]: aggregationResult[2] === data.length ? null : aggregationResult[0] / aggregationResult[1],\n        [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)\n      }, data, series);\n    },\n\n    sum(_ref3, series) {\n      var {\n        intervalStart: intervalStart,\n        intervalEnd: intervalEnd,\n        data: data\n      } = _ref3;\n\n      if (!data.length) {\n        return;\n      }\n\n      var valueField = series.getValueFields()[0];\n      var aggregationResult = data.reduce((result, item) => {\n        var value = item[valueField];\n\n        if (void 0 !== value) {\n          result[0] += value;\n        }\n\n        if (null === value) {\n          result[1]++;\n        } else if (void 0 === value) {\n          result[2]++;\n        }\n\n        return result;\n      }, [0, 0, 0]);\n      var value = aggregationResult[0];\n\n      if (aggregationResult[1] === data.length) {\n        value = null;\n      }\n\n      if (aggregationResult[2] === data.length) {\n        return;\n      }\n\n      return calculateSumErrorBars({\n        [valueField]: value,\n        [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)\n      }, data, series);\n    },\n\n    count(_ref4, series) {\n      var {\n        data: data,\n        intervalStart: intervalStart,\n        intervalEnd: intervalEnd\n      } = _ref4;\n      var valueField = series.getValueFields()[0];\n      return {\n        [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd),\n        [valueField]: data.filter(i => void 0 !== i[valueField]).length\n      };\n    },\n\n    min: getMinMaxAggregator((a, b) => a < b),\n    max: getMinMaxAggregator((a, b) => a > b)\n  },\n  _endUpdateData: function () {\n    delete this._predefinedPointOptions;\n  },\n  getArgumentField: function () {\n    return this._options.argumentField || \"arg\";\n  },\n  getValueFields: function () {\n    var options = this._options;\n    var errorBarsOptions = options.valueErrorBar;\n    var valueFields = [options.valueField || \"val\"];\n    var lowValueField;\n    var highValueField;\n\n    if (errorBarsOptions) {\n      lowValueField = errorBarsOptions.lowValueField;\n      highValueField = errorBarsOptions.highValueField;\n      _isString(lowValueField) && valueFields.push(lowValueField);\n      _isString(highValueField) && valueFields.push(highValueField);\n    }\n\n    return valueFields;\n  },\n  _calculateErrorBars: function (data) {\n    if (!this.areErrorBarsVisible()) {\n      return;\n    }\n\n    var options = this._options;\n    var errorBarsOptions = options.valueErrorBar;\n\n    var errorBarType = _normalizeEnum(errorBarsOptions.type);\n\n    var floatErrorValue = parseFloat(errorBarsOptions.value);\n    var valueField = this.getValueFields()[0];\n    var value;\n    var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;\n    var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;\n    var valueArray;\n    var valueArrayLength;\n    var meanValue;\n    var processDataItem;\n\n    var addSubError = function (_i, item) {\n      value = item.value;\n      item.lowError = value - floatErrorValue;\n      item.highError = value + floatErrorValue;\n    };\n\n    switch (errorBarType) {\n      case FIXED:\n        processDataItem = addSubError;\n        break;\n\n      case PERCENT:\n        processDataItem = function (_, item) {\n          value = item.value;\n          var error = value * floatErrorValue / 100;\n          item.lowError = value - error;\n          item.highError = value + error;\n        };\n\n        break;\n\n      case UNDEFINED:\n        processDataItem = function (_, item) {\n          item.lowError = item.data[lowValueField];\n          item.highError = item.data[highValueField];\n        };\n\n        break;\n\n      default:\n        valueArray = _map(data, function (item) {\n          return _isDefined(item.data[valueField]) ? item.data[valueField] : null;\n        });\n        valueArrayLength = valueArray.length;\n        floatErrorValue = floatErrorValue || 1;\n\n        switch (errorBarType) {\n          case VARIANCE:\n            floatErrorValue = variance(valueArray, sum(valueArray) / valueArrayLength) * floatErrorValue;\n            processDataItem = addSubError;\n            break;\n\n          case STANDARD_DEVIATION:\n            meanValue = sum(valueArray) / valueArrayLength;\n            floatErrorValue = _sqrt(variance(valueArray, meanValue)) * floatErrorValue;\n\n            processDataItem = function (_, item) {\n              item.lowError = meanValue - floatErrorValue;\n              item.highError = meanValue + floatErrorValue;\n            };\n\n            break;\n\n          case STANDARD_ERROR:\n            floatErrorValue = _sqrt(variance(valueArray, sum(valueArray) / valueArrayLength) / valueArrayLength) * floatErrorValue;\n            processDataItem = addSubError;\n        }\n\n    }\n\n    processDataItem && _each(data, processDataItem);\n  },\n  _patchMarginOptions: function (options) {\n    var pointOptions = this._getCreatingPointOptions();\n\n    var styles = pointOptions.styles;\n    var maxSize = [styles.normal, styles.hover, styles.selection].reduce(function (max, style) {\n      return _max(max, 2 * style.r + style[\"stroke-width\"]);\n    }, 0);\n    options.size = pointOptions.visible ? maxSize : 0;\n    options.sizePointNormalState = pointOptions.visible ? 2 * styles.normal.r + styles.normal[\"stroke-width\"] : 2;\n    return options;\n  },\n  usePointsToDefineAutoHiding: () => true\n};\nchart = _extend({}, baseScatterMethods, {\n  drawTrackers: function () {\n    var that = this;\n    var trackers;\n    var trackersGroup;\n    var segments = that._segments || [];\n    var rotated = that._options.rotated;\n\n    if (!that.isVisible()) {\n      return;\n    }\n\n    if (segments.length) {\n      trackers = that._trackers = that._trackers || [];\n      trackersGroup = that._trackersGroup = (that._trackersGroup || that._renderer.g().attr({\n        fill: \"gray\",\n        opacity: .001,\n        stroke: \"gray\",\n        class: \"dxc-trackers\"\n      })).attr({\n        \"clip-path\": this._paneClipRectID || null\n      }).append(that._group);\n\n      _each(segments, function (i, segment) {\n        if (!trackers[i]) {\n          trackers[i] = that._drawTrackerElement(segment).data({\n            \"chart-data-series\": that\n          }).append(trackersGroup);\n        } else {\n          that._updateTrackerElement(segment, trackers[i]);\n        }\n      });\n    }\n\n    that._trackersTranslator = that.groupPointsByCoords(rotated);\n  },\n\n  _checkAxisVisibleAreaCoord(isArgument, coord) {\n    var axis = isArgument ? this.getArgumentAxis() : this.getValueAxis();\n    var visibleArea = axis.getVisibleArea();\n    return _isDefined(coord) && visibleArea[0] <= coord && visibleArea[1] >= coord;\n  },\n\n  checkSeriesViewportCoord(axis, coord) {\n    return this.getPoints().length && this.isVisible();\n  },\n\n  getSeriesPairCoord(coord, isArgument) {\n    var oppositeCoord = null;\n    var isOpposite = !isArgument && !this._options.rotated || isArgument && this._options.rotated;\n    var coordName = !isOpposite ? \"vx\" : \"vy\";\n    var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\n    var points = this.getVisiblePoints();\n\n    for (var i = 0; i < points.length; i++) {\n      var p = points[i];\n      var tmpCoord = p[coordName] === coord ? p[oppositeCoordName] : void 0;\n\n      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\n        oppositeCoord = tmpCoord;\n        break;\n      }\n    }\n\n    return oppositeCoord;\n  },\n\n  _getNearestPoints: (point, nextPoint) => [point, nextPoint],\n  _getBezierPoints: () => [],\n\n  _getNearestPointsByCoord(coord, isArgument) {\n    var that = this;\n    var rotated = that.getOptions().rotated;\n    var isOpposite = !isArgument && !rotated || isArgument && rotated;\n    var coordName = isOpposite ? \"vy\" : \"vx\";\n    var allPoints = that.getPoints();\n\n    var bezierPoints = that._getBezierPoints();\n\n    var nearestPoints = [];\n\n    if (allPoints.length > 1) {\n      allPoints.forEach((point, i) => {\n        var nextPoint = allPoints[i + 1];\n\n        if (nextPoint && (point[coordName] <= coord && nextPoint[coordName] >= coord || point[coordName] >= coord && nextPoint[coordName] <= coord)) {\n          nearestPoints.push(that._getNearestPoints(point, nextPoint, bezierPoints));\n        }\n      });\n    } else {\n      nearestPoints.push([allPoints[0], allPoints[0]]);\n    }\n\n    return nearestPoints;\n  },\n\n  getNeighborPoint: function (x, y) {\n    var pCoord = this._options.rotated ? y : x;\n    var nCoord = pCoord;\n    var cat = this._trackersTranslator;\n    var point = null;\n    var minDistance;\n    var oppositeCoord = this._options.rotated ? x : y;\n    var oppositeCoordName = this._options.rotated ? \"vx\" : \"vy\";\n\n    if (this.isVisible() && cat) {\n      point = cat[pCoord];\n\n      do {\n        point = cat[nCoord] || cat[pCoord];\n        pCoord--;\n        nCoord++;\n      } while ((pCoord >= 0 || nCoord < cat.length) && !point);\n\n      if (Array.isArray(point)) {\n        minDistance = _abs(point[0][oppositeCoordName] - oppositeCoord);\n\n        _each(point, function (i, p) {\n          var distance = _abs(p[oppositeCoordName] - oppositeCoord);\n\n          if (minDistance >= distance) {\n            minDistance = distance;\n            point = p;\n          }\n        });\n      }\n    }\n\n    return point;\n  },\n  _applyVisibleArea: function () {\n    var rotated = this._options.rotated;\n    var visibleX = (rotated ? this.getValueAxis() : this.getArgumentAxis()).getVisibleArea();\n    var visibleY = (rotated ? this.getArgumentAxis() : this.getValueAxis()).getVisibleArea();\n    this._visibleArea = {\n      minX: visibleX[0],\n      maxX: visibleX[1],\n      minY: visibleY[0],\n      maxY: visibleY[1]\n    };\n  },\n\n  getPointCenterByArg(arg) {\n    var point = this.getPointsByArg(arg)[0];\n    return point ? point.getCenterCoord() : void 0;\n  }\n\n});\npolar = _extend({}, baseScatterMethods, {\n  drawTrackers: function () {\n    chart.drawTrackers.call(this);\n    var cat = this._trackersTranslator;\n    var index;\n\n    if (!this.isVisible()) {\n      return;\n    }\n\n    _each(cat, function (i, category) {\n      if (category) {\n        index = i;\n        return false;\n      }\n    });\n\n    cat[index + 360] = cat[index];\n  },\n  getNeighborPoint: function (x, y) {\n    var pos = convertXYToPolar(this.getValueAxis().getCenter(), x, y);\n    return chart.getNeighborPoint.call(this, pos.phi, pos.r);\n  },\n  _applyVisibleArea: function () {\n    var canvas = this.getValueAxis().getCanvas();\n    this._visibleArea = {\n      minX: canvas.left,\n      maxX: canvas.width - canvas.right,\n      minY: canvas.top,\n      maxY: canvas.height - canvas.bottom\n    };\n  },\n\n  getSeriesPairCoord(params, isArgument) {\n    var coords = null;\n    var paramName = isArgument ? \"argument\" : \"radius\";\n    var points = this.getVisiblePoints();\n\n    for (var i = 0; i < points.length; i++) {\n      var p = points[i];\n      var tmpPoint = _isDefined(p[paramName]) && _isDefined(params[paramName]) && p[paramName].valueOf() === params[paramName].valueOf() ? {\n        x: p.x,\n        y: p.y\n      } : void 0;\n\n      if (_isDefined(tmpPoint)) {\n        coords = tmpPoint;\n        break;\n      }\n    }\n\n    return coords;\n  }\n\n});\nexport { chart, polar };","map":{"version":3,"names":["extend","_extend","each","_each","rangeCalculator","isDefined","_isDefined","isString","_isString","map","_map","normalizeEnum","_normalizeEnum","convertXYToPolar","noop","_noop","math","Math","_abs","abs","_sqrt","sqrt","_max","max","DEFAULT_TRACKER_WIDTH","DEFAULT_DURATION","HIGH_ERROR","LOW_ERROR","VARIANCE","STANDARD_DEVIATION","STANDARD_ERROR","PERCENT","FIXED","UNDEFINED","DISCRETE","LOGARITHMIC","DATETIME","chart","polar","sum","array","result","_","value","isErrorBarTypeCorrect","type","includes","variance","expectedValue","length","calculateAvgErrorBars","data","series","errorBarsOptions","getOptions","valueErrorBar","valueField","getValueFields","lowValueField","highValueField","areErrorBarsVisible","fusionData","reduce","item","calculateSumErrorBars","getMinMaxAggregator","compare","_ref","intervalStart","intervalEnd","targetData","getArgumentField","_getIntervalCenter","checkFields","fieldsToCheck","skippedFields","allFieldsIsValid","field","isArgument","selector","baseScatterMethods","_defaultDuration","_defaultTrackerWidth","_applyStyle","_updateOptions","_parseStyle","_prepareSegment","_drawSegment","_appendInGroup","_group","append","_extGroups","seriesGroup","_createLegendState","styleOptions","defaultColor","fill","color","hatching","direction","_applyElementsClipRect","settings","_paneClipRectID","_applyMarkerClipRect","_forceClipping","_createGroup","groupName","parent","target","group","_renderer","g","attr","_applyClearingSettings","opacity","scale","_options","rotated","translateX","translateY","_createGroups","_setMarkerGroupSettings","_createPointStyles","_getMarkerGroupOptions","normal","class","_markersGroup","getVisibleArea","_visibleArea","errorBarOptions","_errorBarsEnabled","displayMode","groupPointsByCoords","cat","getVisiblePoints","p","pointCoord","parseInt","vy","vx","Array","isArray","push","_createErrorBarGroup","animationEnabled","stroke","lineWidth","sharp","_widePaneClipRectID","_setGroupsSettings","_setLabelGroupSettings","_getCreatingPointOptions","defaultPointOptions","creatingPointOptions","_predefinedPointOptions","normalStyle","_getPointOptions","styles","r","_parsePointOptions","_preparePointOptions","label","_getOptionsForPoint","point","_parsePointStyle","style","defaultBorderColor","defaultSize","border","sizeValue","size","visible","width","pointOptions","mainPointColor","mainSeriesColor","containerColor","containerBackgroundColor","visibility","hover","hoverStyle","selection","selectionStyle","_checkData","argument","getArgumentRangeInitialValue","points","getPoints","useAggregation","_points$0$aggregation","_points$aggregationIn","min","aggregationInfo","getValueRangeInitialValue","_getRangeData","getRangeData","_getPointDataSelector","argumentField","tagField","getTagField","pointData","_processEmptyValue","tag","lowError","highError","valueAxisType","valueType","_drawPoint","options","isInVisibleArea","clearVisibility","draw","groups","hasAnimation","firstDrawing","_drawnPoints","setInvisibility","_animateComplete","animationSettings","duration","_labelsGroup","animate","_errorBarGroup","_animate","that","lastPointIndex","i","x","y","argAxis","getArgumentAxis","axisOptions","aggregatedPointBetweenTicks","getVisualRangeCenter","minVisible","maxVisible","_defaultAggregator","_aggregators","avg","_ref2","aggregationResult","_ref3","count","_ref4","filter","a","b","_endUpdateData","valueFields","_calculateErrorBars","errorBarType","floatErrorValue","parseFloat","valueArray","valueArrayLength","meanValue","processDataItem","addSubError","_i","error","_patchMarginOptions","maxSize","sizePointNormalState","usePointsToDefineAutoHiding","drawTrackers","trackers","trackersGroup","segments","_segments","isVisible","_trackers","_trackersGroup","segment","_drawTrackerElement","_updateTrackerElement","_trackersTranslator","_checkAxisVisibleAreaCoord","coord","axis","getValueAxis","visibleArea","checkSeriesViewportCoord","getSeriesPairCoord","oppositeCoord","isOpposite","coordName","oppositeCoordName","tmpCoord","_getNearestPoints","nextPoint","_getBezierPoints","_getNearestPointsByCoord","allPoints","bezierPoints","nearestPoints","forEach","getNeighborPoint","pCoord","nCoord","minDistance","distance","_applyVisibleArea","visibleX","visibleY","minX","maxX","minY","maxY","getPointCenterByArg","arg","getPointsByArg","getCenterCoord","call","index","category","pos","getCenter","phi","canvas","getCanvas","left","right","top","height","bottom","params","coords","paramName","tmpPoint","valueOf"],"sources":["E:/MisaProject/W2022_06/misa_emis/node_modules/devextreme/esm/viz/series/scatter_series.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/viz/series/scatter_series.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    extend as _extend\r\n} from \"../../core/utils/extend\";\r\nimport {\r\n    each as _each\r\n} from \"../../core/utils/iterator\";\r\nimport rangeCalculator from \"./helpers/range_data_calculator\";\r\nimport {\r\n    isDefined as _isDefined,\r\n    isString as _isString\r\n} from \"../../core/utils/type\";\r\nimport {\r\n    map as _map,\r\n    normalizeEnum as _normalizeEnum,\r\n    convertXYToPolar\r\n} from \"../core/utils\";\r\nimport {\r\n    noop as _noop\r\n} from \"../../core/utils/common\";\r\nvar math = Math;\r\nvar _abs = math.abs;\r\nvar _sqrt = math.sqrt;\r\nvar _max = math.max;\r\nvar DEFAULT_TRACKER_WIDTH = 12;\r\nvar DEFAULT_DURATION = 400;\r\nvar HIGH_ERROR = \"highError\";\r\nvar LOW_ERROR = \"lowError\";\r\nvar VARIANCE = \"variance\";\r\nvar STANDARD_DEVIATION = \"stddeviation\";\r\nvar STANDARD_ERROR = \"stderror\";\r\nvar PERCENT = \"percent\";\r\nvar FIXED = \"fixed\";\r\nvar UNDEFINED = \"undefined\";\r\nvar DISCRETE = \"discrete\";\r\nvar LOGARITHMIC = \"logarithmic\";\r\nvar DATETIME = \"datetime\";\r\nvar chart = {};\r\nvar polar = {};\r\n\r\nfunction sum(array) {\r\n    var result = 0;\r\n    _each(array, (function(_, value) {\r\n        result += value\r\n    }));\r\n    return result\r\n}\r\n\r\nfunction isErrorBarTypeCorrect(type) {\r\n    return [FIXED, PERCENT, VARIANCE, STANDARD_DEVIATION, STANDARD_ERROR].includes(type)\r\n}\r\n\r\nfunction variance(array, expectedValue) {\r\n    return sum(_map(array, (function(value) {\r\n        return (value - expectedValue) * (value - expectedValue)\r\n    }))) / array.length\r\n}\r\n\r\nfunction calculateAvgErrorBars(result, data, series) {\r\n    var errorBarsOptions = series.getOptions().valueErrorBar;\r\n    var valueField = series.getValueFields()[0];\r\n    var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;\r\n    var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;\r\n    if (series.areErrorBarsVisible() && void 0 === errorBarsOptions.type) {\r\n        var fusionData = data.reduce((function(result, item) {\r\n            if (_isDefined(item[lowValueField])) {\r\n                result[0] += item[valueField] - item[lowValueField];\r\n                result[1]++\r\n            }\r\n            if (_isDefined(item[highValueField])) {\r\n                result[2] += item[highValueField] - item[valueField];\r\n                result[3]++\r\n            }\r\n            return result\r\n        }), [0, 0, 0, 0]);\r\n        if (fusionData[1]) {\r\n            result[lowValueField] = result[valueField] - fusionData[0] / fusionData[1]\r\n        }\r\n        if (fusionData[2]) {\r\n            result[highValueField] = result[valueField] + fusionData[2] / fusionData[3]\r\n        }\r\n    }\r\n    return result\r\n}\r\n\r\nfunction calculateSumErrorBars(result, data, series) {\r\n    var errorBarsOptions = series.getOptions().valueErrorBar;\r\n    var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;\r\n    var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;\r\n    if (series.areErrorBarsVisible() && void 0 === errorBarsOptions.type) {\r\n        result[lowValueField] = 0;\r\n        result[highValueField] = 0;\r\n        result = data.reduce((function(result, item) {\r\n            result[lowValueField] += item[lowValueField];\r\n            result[highValueField] += item[highValueField];\r\n            return result\r\n        }), result)\r\n    }\r\n    return result\r\n}\r\n\r\nfunction getMinMaxAggregator(compare) {\r\n    return (_ref, series) => {\r\n        var {\r\n            intervalStart: intervalStart,\r\n            intervalEnd: intervalEnd,\r\n            data: data\r\n        } = _ref;\r\n        var valueField = series.getValueFields()[0];\r\n        var targetData = data[0];\r\n        targetData = data.reduce((result, item) => {\r\n            var value = item[valueField];\r\n            if (null === result[valueField]) {\r\n                result = item\r\n            }\r\n            if (null !== value && compare(value, result[valueField])) {\r\n                return item\r\n            }\r\n            return result\r\n        }, targetData);\r\n        return _extend({}, targetData, {\r\n            [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)\r\n        })\r\n    }\r\n}\r\n\r\nfunction checkFields(data, fieldsToCheck, skippedFields) {\r\n    var allFieldsIsValid = true;\r\n    for (var field in fieldsToCheck) {\r\n        var isArgument = \"argument\" === field;\r\n        if (isArgument || \"size\" === field ? !_isDefined(data[field]) : void 0 === data[field]) {\r\n            var selector = fieldsToCheck[field];\r\n            if (!isArgument) {\r\n                skippedFields[selector] = (skippedFields[selector] || 0) + 1\r\n            }\r\n            allFieldsIsValid = false\r\n        }\r\n    }\r\n    return allFieldsIsValid\r\n}\r\nvar baseScatterMethods = {\r\n    _defaultDuration: DEFAULT_DURATION,\r\n    _defaultTrackerWidth: DEFAULT_TRACKER_WIDTH,\r\n    _applyStyle: _noop,\r\n    _updateOptions: _noop,\r\n    _parseStyle: _noop,\r\n    _prepareSegment: _noop,\r\n    _drawSegment: _noop,\r\n    _appendInGroup: function() {\r\n        this._group.append(this._extGroups.seriesGroup)\r\n    },\r\n    _createLegendState: function(styleOptions, defaultColor) {\r\n        return {\r\n            fill: styleOptions.color || defaultColor,\r\n            hatching: styleOptions.hatching ? _extend({}, styleOptions.hatching, {\r\n                direction: \"right\"\r\n            }) : void 0\r\n        }\r\n    },\r\n    _applyElementsClipRect: function(settings) {\r\n        settings[\"clip-path\"] = this._paneClipRectID\r\n    },\r\n    _applyMarkerClipRect: function(settings) {\r\n        settings[\"clip-path\"] = this._forceClipping ? this._paneClipRectID : null\r\n    },\r\n    _createGroup: function(groupName, parent, target, settings) {\r\n        var group = parent[groupName] = parent[groupName] || this._renderer.g();\r\n        target && group.append(target);\r\n        settings && group.attr(settings)\r\n    },\r\n    _applyClearingSettings: function(settings) {\r\n        settings.opacity = null;\r\n        settings.scale = null;\r\n        if (this._options.rotated) {\r\n            settings.translateX = null\r\n        } else {\r\n            settings.translateY = null\r\n        }\r\n    },\r\n    _createGroups: function() {\r\n        this._createGroup(\"_markersGroup\", this, this._group);\r\n        this._createGroup(\"_labelsGroup\", this)\r\n    },\r\n    _setMarkerGroupSettings: function() {\r\n        var settings = this._createPointStyles(this._getMarkerGroupOptions()).normal;\r\n        settings.class = \"dxc-markers\";\r\n        settings.opacity = 1;\r\n        this._applyMarkerClipRect(settings);\r\n        this._markersGroup.attr(settings)\r\n    },\r\n    getVisibleArea: function() {\r\n        return this._visibleArea\r\n    },\r\n    areErrorBarsVisible: function() {\r\n        var errorBarOptions = this._options.valueErrorBar;\r\n        return errorBarOptions && this._errorBarsEnabled() && \"none\" !== errorBarOptions.displayMode && (isErrorBarTypeCorrect(_normalizeEnum(errorBarOptions.type)) || _isDefined(errorBarOptions.lowValueField) || _isDefined(errorBarOptions.highValueField))\r\n    },\r\n    groupPointsByCoords(rotated) {\r\n        var cat = [];\r\n        _each(this.getVisiblePoints(), (function(_, p) {\r\n            var pointCoord = parseInt(rotated ? p.vy : p.vx);\r\n            if (!cat[pointCoord]) {\r\n                cat[pointCoord] = p\r\n            } else {\r\n                Array.isArray(cat[pointCoord]) ? cat[pointCoord].push(p) : cat[pointCoord] = [cat[pointCoord], p]\r\n            }\r\n        }));\r\n        return cat\r\n    },\r\n    _createErrorBarGroup: function(animationEnabled) {\r\n        var errorBarOptions = this._options.valueErrorBar;\r\n        var settings;\r\n        if (this.areErrorBarsVisible()) {\r\n            settings = {\r\n                class: \"dxc-error-bars\",\r\n                stroke: errorBarOptions.color,\r\n                \"stroke-width\": errorBarOptions.lineWidth,\r\n                opacity: animationEnabled ? .001 : errorBarOptions.opacity || 1,\r\n                \"stroke-linecap\": \"square\",\r\n                sharp: true,\r\n                \"clip-path\": this._forceClipping ? this._paneClipRectID : this._widePaneClipRectID\r\n            };\r\n            this._createGroup(\"_errorBarGroup\", this, this._group, settings)\r\n        }\r\n    },\r\n    _setGroupsSettings: function(animationEnabled) {\r\n        this._setMarkerGroupSettings();\r\n        this._setLabelGroupSettings(animationEnabled);\r\n        this._createErrorBarGroup(animationEnabled)\r\n    },\r\n    _getCreatingPointOptions: function() {\r\n        var defaultPointOptions;\r\n        var creatingPointOptions = this._predefinedPointOptions;\r\n        var normalStyle;\r\n        if (!creatingPointOptions) {\r\n            defaultPointOptions = this._getPointOptions();\r\n            this._predefinedPointOptions = creatingPointOptions = _extend(true, {\r\n                styles: {}\r\n            }, defaultPointOptions);\r\n            normalStyle = defaultPointOptions.styles && defaultPointOptions.styles.normal || {};\r\n            creatingPointOptions.styles = creatingPointOptions.styles || {};\r\n            creatingPointOptions.styles.normal = {\r\n                \"stroke-width\": normalStyle[\"stroke-width\"],\r\n                r: normalStyle.r,\r\n                opacity: normalStyle.opacity\r\n            }\r\n        }\r\n        return creatingPointOptions\r\n    },\r\n    _getPointOptions: function() {\r\n        return this._parsePointOptions(this._preparePointOptions(), this._options.label)\r\n    },\r\n    _getOptionsForPoint: function() {\r\n        return this._options.point\r\n    },\r\n    _parsePointStyle: function(style, defaultColor, defaultBorderColor, defaultSize) {\r\n        var border = style.border || {};\r\n        var sizeValue = void 0 !== style.size ? style.size : defaultSize;\r\n        return {\r\n            fill: style.color || defaultColor,\r\n            stroke: border.color || defaultBorderColor,\r\n            \"stroke-width\": border.visible ? border.width : 0,\r\n            r: sizeValue / 2 + (border.visible && 0 !== sizeValue ? ~~(border.width / 2) || 0 : 0)\r\n        }\r\n    },\r\n    _createPointStyles: function(pointOptions) {\r\n        var mainPointColor = pointOptions.color || this._options.mainSeriesColor;\r\n        var containerColor = this._options.containerBackgroundColor;\r\n        var normalStyle = this._parsePointStyle(pointOptions, mainPointColor, mainPointColor);\r\n        normalStyle.visibility = pointOptions.visible ? \"visible\" : \"hidden\";\r\n        return {\r\n            normal: normalStyle,\r\n            hover: this._parsePointStyle(pointOptions.hoverStyle, containerColor, mainPointColor, pointOptions.size),\r\n            selection: this._parsePointStyle(pointOptions.selectionStyle, containerColor, mainPointColor, pointOptions.size)\r\n        }\r\n    },\r\n    _checkData: function(data, skippedFields, fieldsToCheck) {\r\n        fieldsToCheck = fieldsToCheck || {\r\n            value: this.getValueFields()[0]\r\n        };\r\n        fieldsToCheck.argument = this.getArgumentField();\r\n        return checkFields(data, fieldsToCheck, skippedFields || {}) && data.value === data.value\r\n    },\r\n    getArgumentRangeInitialValue() {\r\n        var points = this.getPoints();\r\n        if (this.useAggregation() && points.length) {\r\n            var _points$0$aggregation, _points$aggregationIn;\r\n            return {\r\n                min: null === (_points$0$aggregation = points[0].aggregationInfo) || void 0 === _points$0$aggregation ? void 0 : _points$0$aggregation.intervalStart,\r\n                max: null === (_points$aggregationIn = points[points.length - 1].aggregationInfo) || void 0 === _points$aggregationIn ? void 0 : _points$aggregationIn.intervalEnd\r\n            }\r\n        }\r\n        return\r\n    },\r\n    getValueRangeInitialValue: function() {\r\n        return\r\n    },\r\n    _getRangeData: function() {\r\n        return rangeCalculator.getRangeData(this)\r\n    },\r\n    _getPointDataSelector: function() {\r\n        var valueField = this.getValueFields()[0];\r\n        var argumentField = this.getArgumentField();\r\n        var tagField = this.getTagField();\r\n        var areErrorBarsVisible = this.areErrorBarsVisible();\r\n        var lowValueField;\r\n        var highValueField;\r\n        if (areErrorBarsVisible) {\r\n            var errorBarOptions = this._options.valueErrorBar;\r\n            lowValueField = errorBarOptions.lowValueField || LOW_ERROR;\r\n            highValueField = errorBarOptions.highValueField || HIGH_ERROR\r\n        }\r\n        return data => {\r\n            var pointData = {\r\n                value: this._processEmptyValue(data[valueField]),\r\n                argument: data[argumentField],\r\n                tag: data[tagField],\r\n                data: data\r\n            };\r\n            if (areErrorBarsVisible) {\r\n                pointData.lowError = data[lowValueField];\r\n                pointData.highError = data[highValueField]\r\n            }\r\n            return pointData\r\n        }\r\n    },\r\n    _errorBarsEnabled: function() {\r\n        return this.valueAxisType !== DISCRETE && this.valueAxisType !== LOGARITHMIC && this.valueType !== DATETIME\r\n    },\r\n    _drawPoint: function(options) {\r\n        var point = options.point;\r\n        if (point.isInVisibleArea()) {\r\n            point.clearVisibility();\r\n            point.draw(this._renderer, options.groups, options.hasAnimation, options.firstDrawing);\r\n            this._drawnPoints.push(point)\r\n        } else {\r\n            point.setInvisibility()\r\n        }\r\n    },\r\n    _animateComplete: function() {\r\n        var animationSettings = {\r\n            duration: this._defaultDuration\r\n        };\r\n        this._labelsGroup && this._labelsGroup.animate({\r\n            opacity: 1\r\n        }, animationSettings);\r\n        this._errorBarGroup && this._errorBarGroup.animate({\r\n            opacity: this._options.valueErrorBar.opacity || 1\r\n        }, animationSettings)\r\n    },\r\n    _animate: function() {\r\n        var that = this;\r\n        var lastPointIndex = that._drawnPoints.length - 1;\r\n        _each(that._drawnPoints || [], (function(i, p) {\r\n            p.animate(i === lastPointIndex ? function() {\r\n                that._animateComplete()\r\n            } : void 0, {\r\n                translateX: p.x,\r\n                translateY: p.y\r\n            })\r\n        }))\r\n    },\r\n    _getIntervalCenter(intervalStart, intervalEnd) {\r\n        var argAxis = this.getArgumentAxis();\r\n        var axisOptions = argAxis.getOptions();\r\n        if (argAxis.aggregatedPointBetweenTicks()) {\r\n            return intervalStart\r\n        }\r\n        return \"discrete\" !== axisOptions.type ? argAxis.getVisualRangeCenter({\r\n            minVisible: intervalStart,\r\n            maxVisible: intervalEnd\r\n        }, true) : intervalStart\r\n    },\r\n    _defaultAggregator: \"avg\",\r\n    _aggregators: {\r\n        avg(_ref2, series) {\r\n            var {\r\n                data: data,\r\n                intervalStart: intervalStart,\r\n                intervalEnd: intervalEnd\r\n            } = _ref2;\r\n            if (!data.length) {\r\n                return\r\n            }\r\n            var valueField = series.getValueFields()[0];\r\n            var aggregationResult = data.reduce((result, item) => {\r\n                var value = item[valueField];\r\n                if (_isDefined(value)) {\r\n                    result[0] += value;\r\n                    result[1]++\r\n                } else if (null === value) {\r\n                    result[2]++\r\n                }\r\n                return result\r\n            }, [0, 0, 0]);\r\n            return calculateAvgErrorBars({\r\n                [valueField]: aggregationResult[2] === data.length ? null : aggregationResult[0] / aggregationResult[1],\r\n                [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)\r\n            }, data, series)\r\n        },\r\n        sum(_ref3, series) {\r\n            var {\r\n                intervalStart: intervalStart,\r\n                intervalEnd: intervalEnd,\r\n                data: data\r\n            } = _ref3;\r\n            if (!data.length) {\r\n                return\r\n            }\r\n            var valueField = series.getValueFields()[0];\r\n            var aggregationResult = data.reduce((result, item) => {\r\n                var value = item[valueField];\r\n                if (void 0 !== value) {\r\n                    result[0] += value\r\n                }\r\n                if (null === value) {\r\n                    result[1]++\r\n                } else if (void 0 === value) {\r\n                    result[2]++\r\n                }\r\n                return result\r\n            }, [0, 0, 0]);\r\n            var value = aggregationResult[0];\r\n            if (aggregationResult[1] === data.length) {\r\n                value = null\r\n            }\r\n            if (aggregationResult[2] === data.length) {\r\n                return\r\n            }\r\n            return calculateSumErrorBars({\r\n                [valueField]: value,\r\n                [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)\r\n            }, data, series)\r\n        },\r\n        count(_ref4, series) {\r\n            var {\r\n                data: data,\r\n                intervalStart: intervalStart,\r\n                intervalEnd: intervalEnd\r\n            } = _ref4;\r\n            var valueField = series.getValueFields()[0];\r\n            return {\r\n                [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd),\r\n                [valueField]: data.filter(i => void 0 !== i[valueField]).length\r\n            }\r\n        },\r\n        min: getMinMaxAggregator((a, b) => a < b),\r\n        max: getMinMaxAggregator((a, b) => a > b)\r\n    },\r\n    _endUpdateData: function() {\r\n        delete this._predefinedPointOptions\r\n    },\r\n    getArgumentField: function() {\r\n        return this._options.argumentField || \"arg\"\r\n    },\r\n    getValueFields: function() {\r\n        var options = this._options;\r\n        var errorBarsOptions = options.valueErrorBar;\r\n        var valueFields = [options.valueField || \"val\"];\r\n        var lowValueField;\r\n        var highValueField;\r\n        if (errorBarsOptions) {\r\n            lowValueField = errorBarsOptions.lowValueField;\r\n            highValueField = errorBarsOptions.highValueField;\r\n            _isString(lowValueField) && valueFields.push(lowValueField);\r\n            _isString(highValueField) && valueFields.push(highValueField)\r\n        }\r\n        return valueFields\r\n    },\r\n    _calculateErrorBars: function(data) {\r\n        if (!this.areErrorBarsVisible()) {\r\n            return\r\n        }\r\n        var options = this._options;\r\n        var errorBarsOptions = options.valueErrorBar;\r\n        var errorBarType = _normalizeEnum(errorBarsOptions.type);\r\n        var floatErrorValue = parseFloat(errorBarsOptions.value);\r\n        var valueField = this.getValueFields()[0];\r\n        var value;\r\n        var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;\r\n        var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;\r\n        var valueArray;\r\n        var valueArrayLength;\r\n        var meanValue;\r\n        var processDataItem;\r\n        var addSubError = function(_i, item) {\r\n            value = item.value;\r\n            item.lowError = value - floatErrorValue;\r\n            item.highError = value + floatErrorValue\r\n        };\r\n        switch (errorBarType) {\r\n            case FIXED:\r\n                processDataItem = addSubError;\r\n                break;\r\n            case PERCENT:\r\n                processDataItem = function(_, item) {\r\n                    value = item.value;\r\n                    var error = value * floatErrorValue / 100;\r\n                    item.lowError = value - error;\r\n                    item.highError = value + error\r\n                };\r\n                break;\r\n            case UNDEFINED:\r\n                processDataItem = function(_, item) {\r\n                    item.lowError = item.data[lowValueField];\r\n                    item.highError = item.data[highValueField]\r\n                };\r\n                break;\r\n            default:\r\n                valueArray = _map(data, (function(item) {\r\n                    return _isDefined(item.data[valueField]) ? item.data[valueField] : null\r\n                }));\r\n                valueArrayLength = valueArray.length;\r\n                floatErrorValue = floatErrorValue || 1;\r\n                switch (errorBarType) {\r\n                    case VARIANCE:\r\n                        floatErrorValue = variance(valueArray, sum(valueArray) / valueArrayLength) * floatErrorValue;\r\n                        processDataItem = addSubError;\r\n                        break;\r\n                    case STANDARD_DEVIATION:\r\n                        meanValue = sum(valueArray) / valueArrayLength;\r\n                        floatErrorValue = _sqrt(variance(valueArray, meanValue)) * floatErrorValue;\r\n                        processDataItem = function(_, item) {\r\n                            item.lowError = meanValue - floatErrorValue;\r\n                            item.highError = meanValue + floatErrorValue\r\n                        };\r\n                        break;\r\n                    case STANDARD_ERROR:\r\n                        floatErrorValue = _sqrt(variance(valueArray, sum(valueArray) / valueArrayLength) / valueArrayLength) * floatErrorValue;\r\n                        processDataItem = addSubError\r\n                }\r\n        }\r\n        processDataItem && _each(data, processDataItem)\r\n    },\r\n    _patchMarginOptions: function(options) {\r\n        var pointOptions = this._getCreatingPointOptions();\r\n        var styles = pointOptions.styles;\r\n        var maxSize = [styles.normal, styles.hover, styles.selection].reduce((function(max, style) {\r\n            return _max(max, 2 * style.r + style[\"stroke-width\"])\r\n        }), 0);\r\n        options.size = pointOptions.visible ? maxSize : 0;\r\n        options.sizePointNormalState = pointOptions.visible ? 2 * styles.normal.r + styles.normal[\"stroke-width\"] : 2;\r\n        return options\r\n    },\r\n    usePointsToDefineAutoHiding: () => true\r\n};\r\nchart = _extend({}, baseScatterMethods, {\r\n    drawTrackers: function() {\r\n        var that = this;\r\n        var trackers;\r\n        var trackersGroup;\r\n        var segments = that._segments || [];\r\n        var rotated = that._options.rotated;\r\n        if (!that.isVisible()) {\r\n            return\r\n        }\r\n        if (segments.length) {\r\n            trackers = that._trackers = that._trackers || [];\r\n            trackersGroup = that._trackersGroup = (that._trackersGroup || that._renderer.g().attr({\r\n                fill: \"gray\",\r\n                opacity: .001,\r\n                stroke: \"gray\",\r\n                class: \"dxc-trackers\"\r\n            })).attr({\r\n                \"clip-path\": this._paneClipRectID || null\r\n            }).append(that._group);\r\n            _each(segments, (function(i, segment) {\r\n                if (!trackers[i]) {\r\n                    trackers[i] = that._drawTrackerElement(segment).data({\r\n                        \"chart-data-series\": that\r\n                    }).append(trackersGroup)\r\n                } else {\r\n                    that._updateTrackerElement(segment, trackers[i])\r\n                }\r\n            }))\r\n        }\r\n        that._trackersTranslator = that.groupPointsByCoords(rotated)\r\n    },\r\n    _checkAxisVisibleAreaCoord(isArgument, coord) {\r\n        var axis = isArgument ? this.getArgumentAxis() : this.getValueAxis();\r\n        var visibleArea = axis.getVisibleArea();\r\n        return _isDefined(coord) && visibleArea[0] <= coord && visibleArea[1] >= coord\r\n    },\r\n    checkSeriesViewportCoord(axis, coord) {\r\n        return this.getPoints().length && this.isVisible()\r\n    },\r\n    getSeriesPairCoord(coord, isArgument) {\r\n        var oppositeCoord = null;\r\n        var isOpposite = !isArgument && !this._options.rotated || isArgument && this._options.rotated;\r\n        var coordName = !isOpposite ? \"vx\" : \"vy\";\r\n        var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\r\n        var points = this.getVisiblePoints();\r\n        for (var i = 0; i < points.length; i++) {\r\n            var p = points[i];\r\n            var tmpCoord = p[coordName] === coord ? p[oppositeCoordName] : void 0;\r\n            if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\r\n                oppositeCoord = tmpCoord;\r\n                break\r\n            }\r\n        }\r\n        return oppositeCoord\r\n    },\r\n    _getNearestPoints: (point, nextPoint) => [point, nextPoint],\r\n    _getBezierPoints: () => [],\r\n    _getNearestPointsByCoord(coord, isArgument) {\r\n        var that = this;\r\n        var rotated = that.getOptions().rotated;\r\n        var isOpposite = !isArgument && !rotated || isArgument && rotated;\r\n        var coordName = isOpposite ? \"vy\" : \"vx\";\r\n        var allPoints = that.getPoints();\r\n        var bezierPoints = that._getBezierPoints();\r\n        var nearestPoints = [];\r\n        if (allPoints.length > 1) {\r\n            allPoints.forEach((point, i) => {\r\n                var nextPoint = allPoints[i + 1];\r\n                if (nextPoint && (point[coordName] <= coord && nextPoint[coordName] >= coord || point[coordName] >= coord && nextPoint[coordName] <= coord)) {\r\n                    nearestPoints.push(that._getNearestPoints(point, nextPoint, bezierPoints))\r\n                }\r\n            })\r\n        } else {\r\n            nearestPoints.push([allPoints[0], allPoints[0]])\r\n        }\r\n        return nearestPoints\r\n    },\r\n    getNeighborPoint: function(x, y) {\r\n        var pCoord = this._options.rotated ? y : x;\r\n        var nCoord = pCoord;\r\n        var cat = this._trackersTranslator;\r\n        var point = null;\r\n        var minDistance;\r\n        var oppositeCoord = this._options.rotated ? x : y;\r\n        var oppositeCoordName = this._options.rotated ? \"vx\" : \"vy\";\r\n        if (this.isVisible() && cat) {\r\n            point = cat[pCoord];\r\n            do {\r\n                point = cat[nCoord] || cat[pCoord];\r\n                pCoord--;\r\n                nCoord++\r\n            } while ((pCoord >= 0 || nCoord < cat.length) && !point);\r\n            if (Array.isArray(point)) {\r\n                minDistance = _abs(point[0][oppositeCoordName] - oppositeCoord);\r\n                _each(point, (function(i, p) {\r\n                    var distance = _abs(p[oppositeCoordName] - oppositeCoord);\r\n                    if (minDistance >= distance) {\r\n                        minDistance = distance;\r\n                        point = p\r\n                    }\r\n                }))\r\n            }\r\n        }\r\n        return point\r\n    },\r\n    _applyVisibleArea: function() {\r\n        var rotated = this._options.rotated;\r\n        var visibleX = (rotated ? this.getValueAxis() : this.getArgumentAxis()).getVisibleArea();\r\n        var visibleY = (rotated ? this.getArgumentAxis() : this.getValueAxis()).getVisibleArea();\r\n        this._visibleArea = {\r\n            minX: visibleX[0],\r\n            maxX: visibleX[1],\r\n            minY: visibleY[0],\r\n            maxY: visibleY[1]\r\n        }\r\n    },\r\n    getPointCenterByArg(arg) {\r\n        var point = this.getPointsByArg(arg)[0];\r\n        return point ? point.getCenterCoord() : void 0\r\n    }\r\n});\r\npolar = _extend({}, baseScatterMethods, {\r\n    drawTrackers: function() {\r\n        chart.drawTrackers.call(this);\r\n        var cat = this._trackersTranslator;\r\n        var index;\r\n        if (!this.isVisible()) {\r\n            return\r\n        }\r\n        _each(cat, (function(i, category) {\r\n            if (category) {\r\n                index = i;\r\n                return false\r\n            }\r\n        }));\r\n        cat[index + 360] = cat[index]\r\n    },\r\n    getNeighborPoint: function(x, y) {\r\n        var pos = convertXYToPolar(this.getValueAxis().getCenter(), x, y);\r\n        return chart.getNeighborPoint.call(this, pos.phi, pos.r)\r\n    },\r\n    _applyVisibleArea: function() {\r\n        var canvas = this.getValueAxis().getCanvas();\r\n        this._visibleArea = {\r\n            minX: canvas.left,\r\n            maxX: canvas.width - canvas.right,\r\n            minY: canvas.top,\r\n            maxY: canvas.height - canvas.bottom\r\n        }\r\n    },\r\n    getSeriesPairCoord(params, isArgument) {\r\n        var coords = null;\r\n        var paramName = isArgument ? \"argument\" : \"radius\";\r\n        var points = this.getVisiblePoints();\r\n        for (var i = 0; i < points.length; i++) {\r\n            var p = points[i];\r\n            var tmpPoint = _isDefined(p[paramName]) && _isDefined(params[paramName]) && p[paramName].valueOf() === params[paramName].valueOf() ? {\r\n                x: p.x,\r\n                y: p.y\r\n            } : void 0;\r\n            if (_isDefined(tmpPoint)) {\r\n                coords = tmpPoint;\r\n                break\r\n            }\r\n        }\r\n        return coords\r\n    }\r\n});\r\nexport {\r\n    chart,\r\n    polar\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}