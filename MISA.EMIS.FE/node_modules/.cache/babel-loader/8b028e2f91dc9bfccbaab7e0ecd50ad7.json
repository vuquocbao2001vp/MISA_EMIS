{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/chart_components/multi_axes_synchronizer.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { debug } from \"../../core/utils/console\";\nimport { isDefined, isNumeric } from \"../../core/utils/type\";\nimport { each } from \"../../core/utils/iterator\";\nimport { getLogExt, raiseToExt } from \"../core/utils\";\nimport { adjust } from \"../../core/utils/math\";\nvar _math = Math;\nvar _floor = _math.floor;\nvar _max = _math.max;\nvar _abs = _math.abs;\n\nfunction getValueAxesPerPanes(valueAxes) {\n  var result = {};\n  valueAxes.forEach(axis => {\n    var pane = axis.pane;\n\n    if (!result[pane]) {\n      result[pane] = [];\n    }\n\n    result[pane].push(axis);\n  });\n  return result;\n}\n\nvar linearConverter = br => ({\n  transform: function (v, b) {\n    return adjust(getLogExt(v, b, br.allowNegatives, br.linearThreshold));\n  },\n  getTicks: function (interval, tickValues, base) {\n    var ticks = [];\n    var tick = this.transform(tickValues[0], base);\n\n    while (ticks.length < tickValues.length) {\n      ticks.push(tick);\n      tick = adjust(tick + interval);\n    }\n\n    return ticks;\n  }\n});\n\nvar logConverter = br => ({\n  transform: function (v, b) {\n    return adjust(raiseToExt(v, b, br.allowNegatives, br.linearThreshold));\n  },\n  getTicks: function (interval, tickValues, base) {\n    var ticks = [];\n    var tick;\n\n    for (var i = 0; i < tickValues.length; i += 1) {\n      tick = this.transform(tickValues[i], base);\n      ticks.push(tick);\n    }\n\n    return ticks;\n  }\n});\n\nfunction convertAxisInfo(axisInfo, converter) {\n  if (!axisInfo.isLogarithmic) {\n    return;\n  }\n\n  var base = axisInfo.logarithmicBase;\n  var tickValues = axisInfo.tickValues;\n  axisInfo.minValue = converter.transform(axisInfo.minValue, base);\n  axisInfo.oldMinValue = converter.transform(axisInfo.oldMinValue, base);\n  axisInfo.maxValue = converter.transform(axisInfo.maxValue, base);\n  axisInfo.oldMaxValue = converter.transform(axisInfo.oldMaxValue, base);\n  axisInfo.tickInterval = _math.round(axisInfo.tickInterval);\n\n  if (axisInfo.tickInterval < 1) {\n    axisInfo.tickInterval = 1;\n  }\n\n  var ticks = converter.getTicks(axisInfo.tickInterval, tickValues, base);\n  ticks.tickInterval = axisInfo.tickInterval;\n  axisInfo.tickValues = ticks;\n}\n\nfunction populateAxesInfo(axes) {\n  return axes.reduce(function (result, axis) {\n    var ticksValues = axis.getTicksValues();\n    var majorTicks = ticksValues.majorTicksValues;\n    var options = axis.getOptions();\n    var businessRange = axis.getTranslator().getBusinessRange();\n    var visibleArea = axis.getVisibleArea();\n    var axisInfo;\n    var tickInterval = axis._tickInterval;\n    var synchronizedValue = options.synchronizedValue;\n    var action = axis.getViewport().action;\n\n    if (majorTicks && majorTicks.length > 0 && isNumeric(majorTicks[0]) && \"discrete\" !== options.type && !businessRange.isEmpty() && !(businessRange.breaks && businessRange.breaks.length) && \"zoom\" !== action && \"pan\" !== action) {\n      axis.applyMargins();\n      var startValue = axis.getTranslator().from(visibleArea[0]);\n      var endValue = axis.getTranslator().from(visibleArea[1]);\n      var minValue = startValue < endValue ? startValue : endValue;\n      var maxValue = startValue < endValue ? endValue : startValue;\n\n      if (minValue === maxValue && isDefined(synchronizedValue)) {\n        tickInterval = _abs(majorTicks[0] - synchronizedValue) || 1;\n        minValue = majorTicks[0] - tickInterval;\n        maxValue = majorTicks[0] + tickInterval;\n      }\n\n      axisInfo = {\n        axis: axis,\n        isLogarithmic: \"logarithmic\" === options.type,\n        logarithmicBase: businessRange.base,\n        tickValues: majorTicks,\n        minorValues: ticksValues.minorTicksValues,\n        minorTickInterval: axis._minorTickInterval,\n        minValue: minValue,\n        oldMinValue: minValue,\n        maxValue: maxValue,\n        oldMaxValue: maxValue,\n        inverted: businessRange.invert,\n        tickInterval: tickInterval,\n        synchronizedValue: synchronizedValue\n      };\n      convertAxisInfo(axisInfo, linearConverter(axis.getTranslator().getBusinessRange()));\n      result.push(axisInfo);\n    }\n\n    return result;\n  }, []);\n}\n\nfunction updateTickValues(axesInfo) {\n  var maxTicksCount = axesInfo.reduce((max, axisInfo) => _max(max, axisInfo.tickValues.length), 0);\n  axesInfo.forEach(axisInfo => {\n    var ticksMultiplier;\n    var ticksCount;\n    var additionalStartTicksCount = 0;\n    var synchronizedValue = axisInfo.synchronizedValue;\n    var tickValues = axisInfo.tickValues;\n    var tickInterval = axisInfo.tickInterval;\n\n    if (isDefined(synchronizedValue)) {\n      axisInfo.baseTickValue = axisInfo.invertedBaseTickValue = synchronizedValue;\n      axisInfo.tickValues = [axisInfo.baseTickValue];\n    } else {\n      if (tickValues.length > 1 && tickInterval) {\n        ticksMultiplier = _floor((maxTicksCount + 1) / tickValues.length);\n        ticksCount = ticksMultiplier > 1 ? _floor((maxTicksCount + 1) / ticksMultiplier) : maxTicksCount;\n        additionalStartTicksCount = _floor((ticksCount - tickValues.length) / 2);\n\n        while (additionalStartTicksCount > 0 && 0 !== tickValues[0]) {\n          tickValues.unshift(adjust(tickValues[0] - tickInterval));\n          additionalStartTicksCount--;\n        }\n\n        while (tickValues.length < ticksCount) {\n          tickValues.push(adjust(tickValues[tickValues.length - 1] + tickInterval));\n        }\n\n        axisInfo.tickInterval = tickInterval / ticksMultiplier;\n      }\n\n      axisInfo.baseTickValue = tickValues[0];\n      axisInfo.invertedBaseTickValue = tickValues[tickValues.length - 1];\n    }\n  });\n}\n\nfunction getAxisRange(axisInfo) {\n  return axisInfo.maxValue - axisInfo.minValue || 1;\n}\n\nfunction getMainAxisInfo(axesInfo) {\n  for (var i = 0; i < axesInfo.length; i++) {\n    if (!axesInfo[i].stubData) {\n      return axesInfo[i];\n    }\n  }\n\n  return null;\n}\n\nfunction correctMinMaxValues(axesInfo) {\n  var mainAxisInfo = getMainAxisInfo(axesInfo);\n  var mainAxisInfoTickInterval = mainAxisInfo.tickInterval;\n  axesInfo.forEach(axisInfo => {\n    var scale;\n    var move;\n    var mainAxisBaseValueOffset;\n    var valueFromAxisInfo;\n\n    if (axisInfo !== mainAxisInfo) {\n      if (mainAxisInfoTickInterval && axisInfo.tickInterval) {\n        if (axisInfo.stubData && isDefined(axisInfo.synchronizedValue)) {\n          axisInfo.oldMinValue = axisInfo.minValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.minValue) / mainAxisInfoTickInterval * axisInfo.tickInterval;\n          axisInfo.oldMaxValue = axisInfo.maxValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.maxValue) / mainAxisInfoTickInterval * axisInfo.tickInterval;\n        }\n\n        scale = mainAxisInfoTickInterval / getAxisRange(mainAxisInfo) / axisInfo.tickInterval * getAxisRange(axisInfo);\n        axisInfo.maxValue = axisInfo.minValue + getAxisRange(axisInfo) / scale;\n      }\n\n      if (mainAxisInfo.inverted && !axisInfo.inverted || !mainAxisInfo.inverted && axisInfo.inverted) {\n        mainAxisBaseValueOffset = mainAxisInfo.maxValue - mainAxisInfo.invertedBaseTickValue;\n      } else {\n        mainAxisBaseValueOffset = mainAxisInfo.baseTickValue - mainAxisInfo.minValue;\n      }\n\n      valueFromAxisInfo = getAxisRange(axisInfo);\n      move = (mainAxisBaseValueOffset / getAxisRange(mainAxisInfo) - (axisInfo.baseTickValue - axisInfo.minValue) / valueFromAxisInfo) * valueFromAxisInfo;\n      axisInfo.minValue -= move;\n      axisInfo.maxValue -= move;\n    }\n  });\n}\n\nfunction calculatePaddings(axesInfo) {\n  var minPadding;\n  var maxPadding;\n  var startPadding = 0;\n  var endPadding = 0;\n  axesInfo.forEach(axisInfo => {\n    var inverted = axisInfo.inverted;\n    minPadding = axisInfo.minValue > axisInfo.oldMinValue ? (axisInfo.minValue - axisInfo.oldMinValue) / getAxisRange(axisInfo) : 0;\n    maxPadding = axisInfo.maxValue < axisInfo.oldMaxValue ? (axisInfo.oldMaxValue - axisInfo.maxValue) / getAxisRange(axisInfo) : 0;\n    startPadding = _max(startPadding, inverted ? maxPadding : minPadding);\n    endPadding = _max(endPadding, inverted ? minPadding : maxPadding);\n  });\n  return {\n    start: startPadding,\n    end: endPadding\n  };\n}\n\nfunction correctMinMaxValuesByPaddings(axesInfo, paddings) {\n  axesInfo.forEach(info => {\n    var range = getAxisRange(info);\n    var inverted = info.inverted;\n    info.minValue = adjust(info.minValue - paddings[inverted ? \"end\" : \"start\"] * range);\n    info.maxValue = adjust(info.maxValue + paddings[inverted ? \"start\" : \"end\"] * range);\n  });\n}\n\nfunction updateTickValuesIfSynchronizedValueUsed(axesInfo) {\n  var hasSynchronizedValue = false;\n  axesInfo.forEach(info => {\n    hasSynchronizedValue = hasSynchronizedValue || isDefined(info.synchronizedValue);\n  });\n  axesInfo.forEach(info => {\n    var tickInterval = info.tickInterval;\n    var tickValues = info.tickValues;\n    var maxValue = info.maxValue;\n    var minValue = info.minValue;\n    var tick;\n\n    if (hasSynchronizedValue && tickInterval) {\n      while ((tick = adjust(tickValues[0] - tickInterval)) >= minValue) {\n        tickValues.unshift(tick);\n      }\n\n      tick = tickValues[tickValues.length - 1];\n\n      while ((tick = adjust(tick + tickInterval)) <= maxValue) {\n        tickValues.push(tick);\n      }\n    }\n\n    while (tickValues[0] + tickInterval / 10 < minValue) {\n      tickValues.shift();\n    }\n\n    while (tickValues[tickValues.length - 1] - tickInterval / 10 > maxValue) {\n      tickValues.pop();\n    }\n  });\n}\n\nfunction applyMinMaxValues(axesInfo) {\n  axesInfo.forEach(info => {\n    var axis = info.axis;\n    var range = axis.getTranslator().getBusinessRange();\n\n    if (range.min === range.minVisible) {\n      range.min = info.minValue;\n    }\n\n    if (range.max === range.maxVisible) {\n      range.max = info.maxValue;\n    }\n\n    range.minVisible = info.minValue;\n    range.maxVisible = info.maxValue;\n\n    if (range.min > range.minVisible) {\n      range.min = range.minVisible;\n    }\n\n    if (range.max < range.maxVisible) {\n      range.max = range.maxVisible;\n    }\n\n    axis.getTranslator().updateBusinessRange(range);\n    axis.setTicks({\n      majorTicks: info.tickValues,\n      minorTicks: info.minorValues\n    });\n  });\n}\n\nfunction correctAfterSynchronize(axesInfo) {\n  var invalidAxisInfo = [];\n  var correctValue;\n  axesInfo.forEach(info => {\n    if (info.oldMaxValue - info.oldMinValue === 0) {\n      invalidAxisInfo.push(info);\n    } else if (!isDefined(correctValue) && !isDefined(info.synchronizedValue)) {\n      correctValue = _abs((info.maxValue - info.minValue) / (info.tickValues[_floor(info.tickValues.length / 2)] - info.minValue || info.maxValue));\n    }\n  });\n\n  if (!isDefined(correctValue)) {\n    return;\n  }\n\n  invalidAxisInfo.forEach(info => {\n    var firstTick = info.tickValues[0];\n    var correctedTick = firstTick * correctValue;\n\n    if (firstTick > 0) {\n      info.maxValue = correctedTick;\n      info.minValue = 0;\n    } else if (firstTick < 0) {\n      info.minValue = correctedTick;\n      info.maxValue = 0;\n    }\n  });\n}\n\nfunction updateMinorTicks(axesInfo) {\n  axesInfo.forEach(function (axisInfo) {\n    if (!axisInfo.minorTickInterval) {\n      return;\n    }\n\n    var ticks = [];\n    var interval = axisInfo.minorTickInterval;\n    var tickCount = axisInfo.tickInterval / interval - 1;\n\n    for (var i = 1; i < axisInfo.tickValues.length; i++) {\n      var tick = axisInfo.tickValues[i - 1];\n\n      for (var j = 0; j < tickCount; j++) {\n        tick += interval;\n        ticks.push(tick);\n      }\n    }\n\n    axisInfo.minorValues = ticks;\n  });\n}\n\nfunction correctPaddings(axesInfo, paddings) {\n  return axesInfo.reduce((prev, info) => {\n    var inverted = info.inverted;\n    var {\n      start: start,\n      end: end\n    } = info.axis.getCorrectedValuesToZero(info.minValue, info.maxValue);\n\n    if (isDefined(start) || isDefined(end)) {\n      return inverted ? {\n        start: prev.start,\n        end: Math.min(prev.end, end)\n      } : {\n        start: Math.min(prev.start, start),\n        end: prev.end\n      };\n    }\n\n    return prev;\n  }, paddings);\n}\n\nvar multiAxesSynchronizer = {\n  synchronize: function (valueAxes) {\n    each(getValueAxesPerPanes(valueAxes), function (_, axes) {\n      var axesInfo;\n      var paddings;\n\n      if (axes.length > 1) {\n        axesInfo = populateAxesInfo(axes);\n\n        if (axesInfo.length < 2 || !getMainAxisInfo(axesInfo)) {\n          return;\n        }\n\n        updateTickValues(axesInfo);\n        correctMinMaxValues(axesInfo);\n        paddings = calculatePaddings(axesInfo);\n        paddings = correctPaddings(axesInfo, paddings);\n        correctMinMaxValuesByPaddings(axesInfo, paddings);\n        correctAfterSynchronize(axesInfo);\n        updateTickValuesIfSynchronizedValueUsed(axesInfo);\n        updateMinorTicks(axesInfo);\n        axesInfo.forEach(info => {\n          convertAxisInfo(info, logConverter(info.axis.getTranslator().getBusinessRange()));\n        });\n        applyMinMaxValues(axesInfo);\n      }\n    });\n  }\n};\nexport default multiAxesSynchronizer;","map":{"version":3,"names":["debug","isDefined","isNumeric","each","getLogExt","raiseToExt","adjust","_math","Math","_floor","floor","_max","max","_abs","abs","getValueAxesPerPanes","valueAxes","result","forEach","axis","pane","push","linearConverter","br","transform","v","b","allowNegatives","linearThreshold","getTicks","interval","tickValues","base","ticks","tick","length","logConverter","i","convertAxisInfo","axisInfo","converter","isLogarithmic","logarithmicBase","minValue","oldMinValue","maxValue","oldMaxValue","tickInterval","round","populateAxesInfo","axes","reduce","ticksValues","getTicksValues","majorTicks","majorTicksValues","options","getOptions","businessRange","getTranslator","getBusinessRange","visibleArea","getVisibleArea","_tickInterval","synchronizedValue","action","getViewport","type","isEmpty","breaks","applyMargins","startValue","from","endValue","minorValues","minorTicksValues","minorTickInterval","_minorTickInterval","inverted","invert","updateTickValues","axesInfo","maxTicksCount","ticksMultiplier","ticksCount","additionalStartTicksCount","baseTickValue","invertedBaseTickValue","unshift","getAxisRange","getMainAxisInfo","stubData","correctMinMaxValues","mainAxisInfo","mainAxisInfoTickInterval","scale","move","mainAxisBaseValueOffset","valueFromAxisInfo","calculatePaddings","minPadding","maxPadding","startPadding","endPadding","start","end","correctMinMaxValuesByPaddings","paddings","info","range","updateTickValuesIfSynchronizedValueUsed","hasSynchronizedValue","shift","pop","applyMinMaxValues","min","minVisible","maxVisible","updateBusinessRange","setTicks","minorTicks","correctAfterSynchronize","invalidAxisInfo","correctValue","firstTick","correctedTick","updateMinorTicks","tickCount","j","correctPaddings","prev","getCorrectedValuesToZero","multiAxesSynchronizer","synchronize","_"],"sources":["E:/MisaProject/W2022_06/misa_emis/node_modules/devextreme/esm/viz/chart_components/multi_axes_synchronizer.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/viz/chart_components/multi_axes_synchronizer.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    debug\r\n} from \"../../core/utils/console\";\r\nimport {\r\n    isDefined,\r\n    isNumeric\r\n} from \"../../core/utils/type\";\r\nimport {\r\n    each\r\n} from \"../../core/utils/iterator\";\r\nimport {\r\n    getLogExt,\r\n    raiseToExt\r\n} from \"../core/utils\";\r\nimport {\r\n    adjust\r\n} from \"../../core/utils/math\";\r\nvar _math = Math;\r\nvar _floor = _math.floor;\r\nvar _max = _math.max;\r\nvar _abs = _math.abs;\r\n\r\nfunction getValueAxesPerPanes(valueAxes) {\r\n    var result = {};\r\n    valueAxes.forEach(axis => {\r\n        var pane = axis.pane;\r\n        if (!result[pane]) {\r\n            result[pane] = []\r\n        }\r\n        result[pane].push(axis)\r\n    });\r\n    return result\r\n}\r\nvar linearConverter = br => ({\r\n    transform: function(v, b) {\r\n        return adjust(getLogExt(v, b, br.allowNegatives, br.linearThreshold))\r\n    },\r\n    getTicks: function(interval, tickValues, base) {\r\n        var ticks = [];\r\n        var tick = this.transform(tickValues[0], base);\r\n        while (ticks.length < tickValues.length) {\r\n            ticks.push(tick);\r\n            tick = adjust(tick + interval)\r\n        }\r\n        return ticks\r\n    }\r\n});\r\nvar logConverter = br => ({\r\n    transform: function(v, b) {\r\n        return adjust(raiseToExt(v, b, br.allowNegatives, br.linearThreshold))\r\n    },\r\n    getTicks: function(interval, tickValues, base) {\r\n        var ticks = [];\r\n        var tick;\r\n        for (var i = 0; i < tickValues.length; i += 1) {\r\n            tick = this.transform(tickValues[i], base);\r\n            ticks.push(tick)\r\n        }\r\n        return ticks\r\n    }\r\n});\r\n\r\nfunction convertAxisInfo(axisInfo, converter) {\r\n    if (!axisInfo.isLogarithmic) {\r\n        return\r\n    }\r\n    var base = axisInfo.logarithmicBase;\r\n    var tickValues = axisInfo.tickValues;\r\n    axisInfo.minValue = converter.transform(axisInfo.minValue, base);\r\n    axisInfo.oldMinValue = converter.transform(axisInfo.oldMinValue, base);\r\n    axisInfo.maxValue = converter.transform(axisInfo.maxValue, base);\r\n    axisInfo.oldMaxValue = converter.transform(axisInfo.oldMaxValue, base);\r\n    axisInfo.tickInterval = _math.round(axisInfo.tickInterval);\r\n    if (axisInfo.tickInterval < 1) {\r\n        axisInfo.tickInterval = 1\r\n    }\r\n    var ticks = converter.getTicks(axisInfo.tickInterval, tickValues, base);\r\n    ticks.tickInterval = axisInfo.tickInterval;\r\n    axisInfo.tickValues = ticks\r\n}\r\n\r\nfunction populateAxesInfo(axes) {\r\n    return axes.reduce((function(result, axis) {\r\n        var ticksValues = axis.getTicksValues();\r\n        var majorTicks = ticksValues.majorTicksValues;\r\n        var options = axis.getOptions();\r\n        var businessRange = axis.getTranslator().getBusinessRange();\r\n        var visibleArea = axis.getVisibleArea();\r\n        var axisInfo;\r\n        var tickInterval = axis._tickInterval;\r\n        var synchronizedValue = options.synchronizedValue;\r\n        var action = axis.getViewport().action;\r\n        if (majorTicks && majorTicks.length > 0 && isNumeric(majorTicks[0]) && \"discrete\" !== options.type && !businessRange.isEmpty() && !(businessRange.breaks && businessRange.breaks.length) && \"zoom\" !== action && \"pan\" !== action) {\r\n            axis.applyMargins();\r\n            var startValue = axis.getTranslator().from(visibleArea[0]);\r\n            var endValue = axis.getTranslator().from(visibleArea[1]);\r\n            var minValue = startValue < endValue ? startValue : endValue;\r\n            var maxValue = startValue < endValue ? endValue : startValue;\r\n            if (minValue === maxValue && isDefined(synchronizedValue)) {\r\n                tickInterval = _abs(majorTicks[0] - synchronizedValue) || 1;\r\n                minValue = majorTicks[0] - tickInterval;\r\n                maxValue = majorTicks[0] + tickInterval\r\n            }\r\n            axisInfo = {\r\n                axis: axis,\r\n                isLogarithmic: \"logarithmic\" === options.type,\r\n                logarithmicBase: businessRange.base,\r\n                tickValues: majorTicks,\r\n                minorValues: ticksValues.minorTicksValues,\r\n                minorTickInterval: axis._minorTickInterval,\r\n                minValue: minValue,\r\n                oldMinValue: minValue,\r\n                maxValue: maxValue,\r\n                oldMaxValue: maxValue,\r\n                inverted: businessRange.invert,\r\n                tickInterval: tickInterval,\r\n                synchronizedValue: synchronizedValue\r\n            };\r\n            convertAxisInfo(axisInfo, linearConverter(axis.getTranslator().getBusinessRange()));\r\n            result.push(axisInfo)\r\n        }\r\n        return result\r\n    }), [])\r\n}\r\n\r\nfunction updateTickValues(axesInfo) {\r\n    var maxTicksCount = axesInfo.reduce((max, axisInfo) => _max(max, axisInfo.tickValues.length), 0);\r\n    axesInfo.forEach(axisInfo => {\r\n        var ticksMultiplier;\r\n        var ticksCount;\r\n        var additionalStartTicksCount = 0;\r\n        var synchronizedValue = axisInfo.synchronizedValue;\r\n        var tickValues = axisInfo.tickValues;\r\n        var tickInterval = axisInfo.tickInterval;\r\n        if (isDefined(synchronizedValue)) {\r\n            axisInfo.baseTickValue = axisInfo.invertedBaseTickValue = synchronizedValue;\r\n            axisInfo.tickValues = [axisInfo.baseTickValue]\r\n        } else {\r\n            if (tickValues.length > 1 && tickInterval) {\r\n                ticksMultiplier = _floor((maxTicksCount + 1) / tickValues.length);\r\n                ticksCount = ticksMultiplier > 1 ? _floor((maxTicksCount + 1) / ticksMultiplier) : maxTicksCount;\r\n                additionalStartTicksCount = _floor((ticksCount - tickValues.length) / 2);\r\n                while (additionalStartTicksCount > 0 && 0 !== tickValues[0]) {\r\n                    tickValues.unshift(adjust(tickValues[0] - tickInterval));\r\n                    additionalStartTicksCount--\r\n                }\r\n                while (tickValues.length < ticksCount) {\r\n                    tickValues.push(adjust(tickValues[tickValues.length - 1] + tickInterval))\r\n                }\r\n                axisInfo.tickInterval = tickInterval / ticksMultiplier\r\n            }\r\n            axisInfo.baseTickValue = tickValues[0];\r\n            axisInfo.invertedBaseTickValue = tickValues[tickValues.length - 1]\r\n        }\r\n    })\r\n}\r\n\r\nfunction getAxisRange(axisInfo) {\r\n    return axisInfo.maxValue - axisInfo.minValue || 1\r\n}\r\n\r\nfunction getMainAxisInfo(axesInfo) {\r\n    for (var i = 0; i < axesInfo.length; i++) {\r\n        if (!axesInfo[i].stubData) {\r\n            return axesInfo[i]\r\n        }\r\n    }\r\n    return null\r\n}\r\n\r\nfunction correctMinMaxValues(axesInfo) {\r\n    var mainAxisInfo = getMainAxisInfo(axesInfo);\r\n    var mainAxisInfoTickInterval = mainAxisInfo.tickInterval;\r\n    axesInfo.forEach(axisInfo => {\r\n        var scale;\r\n        var move;\r\n        var mainAxisBaseValueOffset;\r\n        var valueFromAxisInfo;\r\n        if (axisInfo !== mainAxisInfo) {\r\n            if (mainAxisInfoTickInterval && axisInfo.tickInterval) {\r\n                if (axisInfo.stubData && isDefined(axisInfo.synchronizedValue)) {\r\n                    axisInfo.oldMinValue = axisInfo.minValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.minValue) / mainAxisInfoTickInterval * axisInfo.tickInterval;\r\n                    axisInfo.oldMaxValue = axisInfo.maxValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.maxValue) / mainAxisInfoTickInterval * axisInfo.tickInterval\r\n                }\r\n                scale = mainAxisInfoTickInterval / getAxisRange(mainAxisInfo) / axisInfo.tickInterval * getAxisRange(axisInfo);\r\n                axisInfo.maxValue = axisInfo.minValue + getAxisRange(axisInfo) / scale\r\n            }\r\n            if (mainAxisInfo.inverted && !axisInfo.inverted || !mainAxisInfo.inverted && axisInfo.inverted) {\r\n                mainAxisBaseValueOffset = mainAxisInfo.maxValue - mainAxisInfo.invertedBaseTickValue\r\n            } else {\r\n                mainAxisBaseValueOffset = mainAxisInfo.baseTickValue - mainAxisInfo.minValue\r\n            }\r\n            valueFromAxisInfo = getAxisRange(axisInfo);\r\n            move = (mainAxisBaseValueOffset / getAxisRange(mainAxisInfo) - (axisInfo.baseTickValue - axisInfo.minValue) / valueFromAxisInfo) * valueFromAxisInfo;\r\n            axisInfo.minValue -= move;\r\n            axisInfo.maxValue -= move\r\n        }\r\n    })\r\n}\r\n\r\nfunction calculatePaddings(axesInfo) {\r\n    var minPadding;\r\n    var maxPadding;\r\n    var startPadding = 0;\r\n    var endPadding = 0;\r\n    axesInfo.forEach(axisInfo => {\r\n        var inverted = axisInfo.inverted;\r\n        minPadding = axisInfo.minValue > axisInfo.oldMinValue ? (axisInfo.minValue - axisInfo.oldMinValue) / getAxisRange(axisInfo) : 0;\r\n        maxPadding = axisInfo.maxValue < axisInfo.oldMaxValue ? (axisInfo.oldMaxValue - axisInfo.maxValue) / getAxisRange(axisInfo) : 0;\r\n        startPadding = _max(startPadding, inverted ? maxPadding : minPadding);\r\n        endPadding = _max(endPadding, inverted ? minPadding : maxPadding)\r\n    });\r\n    return {\r\n        start: startPadding,\r\n        end: endPadding\r\n    }\r\n}\r\n\r\nfunction correctMinMaxValuesByPaddings(axesInfo, paddings) {\r\n    axesInfo.forEach(info => {\r\n        var range = getAxisRange(info);\r\n        var inverted = info.inverted;\r\n        info.minValue = adjust(info.minValue - paddings[inverted ? \"end\" : \"start\"] * range);\r\n        info.maxValue = adjust(info.maxValue + paddings[inverted ? \"start\" : \"end\"] * range)\r\n    })\r\n}\r\n\r\nfunction updateTickValuesIfSynchronizedValueUsed(axesInfo) {\r\n    var hasSynchronizedValue = false;\r\n    axesInfo.forEach(info => {\r\n        hasSynchronizedValue = hasSynchronizedValue || isDefined(info.synchronizedValue)\r\n    });\r\n    axesInfo.forEach(info => {\r\n        var tickInterval = info.tickInterval;\r\n        var tickValues = info.tickValues;\r\n        var maxValue = info.maxValue;\r\n        var minValue = info.minValue;\r\n        var tick;\r\n        if (hasSynchronizedValue && tickInterval) {\r\n            while ((tick = adjust(tickValues[0] - tickInterval)) >= minValue) {\r\n                tickValues.unshift(tick)\r\n            }\r\n            tick = tickValues[tickValues.length - 1];\r\n            while ((tick = adjust(tick + tickInterval)) <= maxValue) {\r\n                tickValues.push(tick)\r\n            }\r\n        }\r\n        while (tickValues[0] + tickInterval / 10 < minValue) {\r\n            tickValues.shift()\r\n        }\r\n        while (tickValues[tickValues.length - 1] - tickInterval / 10 > maxValue) {\r\n            tickValues.pop()\r\n        }\r\n    })\r\n}\r\n\r\nfunction applyMinMaxValues(axesInfo) {\r\n    axesInfo.forEach(info => {\r\n        var axis = info.axis;\r\n        var range = axis.getTranslator().getBusinessRange();\r\n        if (range.min === range.minVisible) {\r\n            range.min = info.minValue\r\n        }\r\n        if (range.max === range.maxVisible) {\r\n            range.max = info.maxValue\r\n        }\r\n        range.minVisible = info.minValue;\r\n        range.maxVisible = info.maxValue;\r\n        if (range.min > range.minVisible) {\r\n            range.min = range.minVisible\r\n        }\r\n        if (range.max < range.maxVisible) {\r\n            range.max = range.maxVisible\r\n        }\r\n        axis.getTranslator().updateBusinessRange(range);\r\n        axis.setTicks({\r\n            majorTicks: info.tickValues,\r\n            minorTicks: info.minorValues\r\n        })\r\n    })\r\n}\r\n\r\nfunction correctAfterSynchronize(axesInfo) {\r\n    var invalidAxisInfo = [];\r\n    var correctValue;\r\n    axesInfo.forEach(info => {\r\n        if (info.oldMaxValue - info.oldMinValue === 0) {\r\n            invalidAxisInfo.push(info)\r\n        } else if (!isDefined(correctValue) && !isDefined(info.synchronizedValue)) {\r\n            correctValue = _abs((info.maxValue - info.minValue) / (info.tickValues[_floor(info.tickValues.length / 2)] - info.minValue || info.maxValue))\r\n        }\r\n    });\r\n    if (!isDefined(correctValue)) {\r\n        return\r\n    }\r\n    invalidAxisInfo.forEach(info => {\r\n        var firstTick = info.tickValues[0];\r\n        var correctedTick = firstTick * correctValue;\r\n        if (firstTick > 0) {\r\n            info.maxValue = correctedTick;\r\n            info.minValue = 0\r\n        } else if (firstTick < 0) {\r\n            info.minValue = correctedTick;\r\n            info.maxValue = 0\r\n        }\r\n    })\r\n}\r\n\r\nfunction updateMinorTicks(axesInfo) {\r\n    axesInfo.forEach((function(axisInfo) {\r\n        if (!axisInfo.minorTickInterval) {\r\n            return\r\n        }\r\n        var ticks = [];\r\n        var interval = axisInfo.minorTickInterval;\r\n        var tickCount = axisInfo.tickInterval / interval - 1;\r\n        for (var i = 1; i < axisInfo.tickValues.length; i++) {\r\n            var tick = axisInfo.tickValues[i - 1];\r\n            for (var j = 0; j < tickCount; j++) {\r\n                tick += interval;\r\n                ticks.push(tick)\r\n            }\r\n        }\r\n        axisInfo.minorValues = ticks\r\n    }))\r\n}\r\n\r\nfunction correctPaddings(axesInfo, paddings) {\r\n    return axesInfo.reduce((prev, info) => {\r\n        var inverted = info.inverted;\r\n        var {\r\n            start: start,\r\n            end: end\r\n        } = info.axis.getCorrectedValuesToZero(info.minValue, info.maxValue);\r\n        if (isDefined(start) || isDefined(end)) {\r\n            return inverted ? {\r\n                start: prev.start,\r\n                end: Math.min(prev.end, end)\r\n            } : {\r\n                start: Math.min(prev.start, start),\r\n                end: prev.end\r\n            }\r\n        }\r\n        return prev\r\n    }, paddings)\r\n}\r\nvar multiAxesSynchronizer = {\r\n    synchronize: function(valueAxes) {\r\n        each(getValueAxesPerPanes(valueAxes), (function(_, axes) {\r\n            var axesInfo;\r\n            var paddings;\r\n            if (axes.length > 1) {\r\n                axesInfo = populateAxesInfo(axes);\r\n                if (axesInfo.length < 2 || !getMainAxisInfo(axesInfo)) {\r\n                    return\r\n                }\r\n                updateTickValues(axesInfo);\r\n                correctMinMaxValues(axesInfo);\r\n                paddings = calculatePaddings(axesInfo);\r\n                paddings = correctPaddings(axesInfo, paddings);\r\n                correctMinMaxValuesByPaddings(axesInfo, paddings);\r\n                correctAfterSynchronize(axesInfo);\r\n                updateTickValuesIfSynchronizedValueUsed(axesInfo);\r\n                updateMinorTicks(axesInfo);\r\n                axesInfo.forEach(info => {\r\n                    convertAxisInfo(info, logConverter(info.axis.getTranslator().getBusinessRange()))\r\n                });\r\n                applyMinMaxValues(axesInfo)\r\n            }\r\n        }))\r\n    }\r\n};\r\nexport default multiAxesSynchronizer;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}