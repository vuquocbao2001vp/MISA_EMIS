{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/axes/base_axis.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { smartFormatter as _format, formatRange } from \"./smart_formatter\";\nimport { patchFontOptions, getVizRangeObject, getLogExt as getLog, raiseToExt as raiseTo, valueOf, rotateBBox, getCategoriesInfo, adjustVisualRange, getAddFunction, convertVisualRangeObject } from \"../core/utils\";\nimport { isDefined, isFunction, isPlainObject, type } from \"../../core/utils/type\";\nimport constants from \"./axes_constants\";\nimport { extend } from \"../../core/utils/extend\";\nimport formatHelper from \"../../format_helper\";\nimport { getParser } from \"../components/parse_utils\";\nimport { tickGenerator } from \"./tick_generator\";\nimport { Translator2D } from \"../translators/translator2d\";\nimport { Range } from \"../translators/range\";\nimport { tick } from \"./tick\";\nimport { adjust } from \"../../core/utils/math\";\nimport dateUtils from \"../../core/utils/date\";\nimport { noop as _noop } from \"../../core/utils/common\";\nimport xyMethods from \"./xy_axes\";\nimport * as polarMethods from \"./polar_axes\";\nimport createConstantLine from \"./constant_line\";\nimport createStrip from \"./strip\";\nimport { Deferred, when } from \"../../core/utils/deferred\";\nimport { calculateCanvasMargins, measureLabels } from \"./axes_utils\";\nvar convertTicksToValues = constants.convertTicksToValues;\nvar _math = Math;\nvar _abs = _math.abs;\nvar _max = _math.max;\nvar _min = _math.min;\nvar _isArray = Array.isArray;\nvar DEFAULT_AXIS_LABEL_SPACING = 5;\nvar MAX_GRID_BORDER_ADHENSION = 4;\nvar TOP = constants.top;\nvar BOTTOM = constants.bottom;\nvar LEFT = constants.left;\nvar RIGHT = constants.right;\nvar CENTER = constants.center;\nvar KEEP = \"keep\";\nvar SHIFT = \"shift\";\nvar RESET = \"reset\";\nvar ROTATE = \"rotate\";\nvar DEFAULT_AXIS_DIVISION_FACTOR = 50;\nvar DEFAULT_MINOR_AXIS_DIVISION_FACTOR = 15;\nvar SCROLL_THRESHOLD = 5;\nvar MIN_BAR_MARGIN = 5;\nvar MAX_MARGIN_VALUE = .8;\nvar dateIntervals = {\n  day: 864e5,\n  week: 6048e5\n};\n\nfunction getTickGenerator(options, incidentOccurred, skipTickGeneration, rangeIsEmpty, adjustDivisionFactor, _ref) {\n  var _options$workWeek;\n\n  var {\n    allowNegatives: allowNegatives,\n    linearThreshold: linearThreshold\n  } = _ref;\n  return tickGenerator({\n    axisType: options.type,\n    dataType: options.dataType,\n    logBase: options.logarithmBase,\n    allowNegatives: allowNegatives,\n    linearThreshold: linearThreshold,\n    axisDivisionFactor: adjustDivisionFactor(options.axisDivisionFactor || DEFAULT_AXIS_DIVISION_FACTOR),\n    minorAxisDivisionFactor: adjustDivisionFactor(options.minorAxisDivisionFactor || DEFAULT_MINOR_AXIS_DIVISION_FACTOR),\n    numberMultipliers: options.numberMultipliers,\n    calculateMinors: options.minorTick.visible || options.minorGrid.visible || options.calculateMinors,\n    allowDecimals: options.allowDecimals,\n    endOnTick: options.endOnTick,\n    incidentOccurred: incidentOccurred,\n    firstDayOfWeek: null === (_options$workWeek = options.workWeek) || void 0 === _options$workWeek ? void 0 : _options$workWeek[0],\n    skipTickGeneration: skipTickGeneration,\n    skipCalculationLimits: options.skipCalculationLimits,\n    generateExtraTick: options.generateExtraTick,\n    minTickInterval: options.minTickInterval,\n    rangeIsEmpty: rangeIsEmpty\n  });\n}\n\nfunction createMajorTick(axis, renderer, skippedCategory) {\n  var options = axis.getOptions();\n  return tick(axis, renderer, options.tick, options.grid, skippedCategory, false);\n}\n\nfunction createMinorTick(axis, renderer) {\n  var options = axis.getOptions();\n  return tick(axis, renderer, options.minorTick, options.minorGrid);\n}\n\nfunction createBoundaryTick(axis, renderer, isFirst) {\n  var options = axis.getOptions();\n  return tick(axis, renderer, extend({}, options.tick, {\n    visible: options.showCustomBoundaryTicks\n  }), options.grid, void 0, false, isFirst ? -1 : 1);\n}\n\nfunction callAction(elements, action, actionArgument1, actionArgument2) {\n  (elements || []).forEach(e => e[action](actionArgument1, actionArgument2));\n}\n\nfunction initTickCoords(ticks) {\n  callAction(ticks, \"initCoords\");\n}\n\nfunction drawTickMarks(ticks, options) {\n  callAction(ticks, \"drawMark\", options);\n}\n\nfunction drawGrids(ticks, drawLine) {\n  callAction(ticks, \"drawGrid\", drawLine);\n}\n\nfunction updateTicksPosition(ticks, options, animate) {\n  callAction(ticks, \"updateTickPosition\", options, animate);\n}\n\nfunction updateGridsPosition(ticks, animate) {\n  callAction(ticks, \"updateGridPosition\", animate);\n}\n\nfunction cleanUpInvalidTicks(ticks) {\n  var i = ticks.length - 1;\n\n  for (i; i >= 0; i--) {\n    if (!removeInvalidTick(ticks, i)) {\n      break;\n    }\n  }\n\n  for (i = 0; i < ticks.length; i++) {\n    if (removeInvalidTick(ticks, i)) {\n      i--;\n    } else {\n      break;\n    }\n  }\n}\n\nfunction removeInvalidTick(ticks, i) {\n  if (null === ticks[i].coords.x || null === ticks[i].coords.y) {\n    ticks.splice(i, 1);\n    return true;\n  }\n\n  return false;\n}\n\nfunction validateAxisOptions(options) {\n  var _labelOptions$minSpac;\n\n  var labelOptions = options.label;\n  var position = options.position;\n  var defaultPosition = options.isHorizontal ? BOTTOM : LEFT;\n  var secondaryPosition = options.isHorizontal ? TOP : RIGHT;\n  var labelPosition = labelOptions.position;\n\n  if (position !== defaultPosition && position !== secondaryPosition) {\n    position = defaultPosition;\n  }\n\n  if (!labelPosition || \"outside\" === labelPosition) {\n    labelPosition = position;\n  } else if (\"inside\" === labelPosition) {\n    labelPosition = {\n      [TOP]: BOTTOM,\n      [BOTTOM]: TOP,\n      [LEFT]: RIGHT,\n      [RIGHT]: LEFT\n    }[position];\n  }\n\n  if (labelPosition !== defaultPosition && labelPosition !== secondaryPosition) {\n    labelPosition = position;\n  }\n\n  if (labelOptions.alignment !== CENTER && !labelOptions.userAlignment) {\n    labelOptions.alignment = {\n      [TOP]: CENTER,\n      [BOTTOM]: CENTER,\n      [LEFT]: RIGHT,\n      [RIGHT]: LEFT\n    }[labelPosition];\n  }\n\n  options.position = position;\n  labelOptions.position = labelPosition;\n  options.hoverMode = options.hoverMode ? options.hoverMode.toLowerCase() : \"none\";\n  labelOptions.minSpacing = null !== (_labelOptions$minSpac = labelOptions.minSpacing) && void 0 !== _labelOptions$minSpac ? _labelOptions$minSpac : DEFAULT_AXIS_LABEL_SPACING;\n  options.type && (options.type = options.type.toLowerCase());\n  options.argumentType && (options.argumentType = options.argumentType.toLowerCase());\n  options.valueType && (options.valueType = options.valueType.toLowerCase());\n}\n\nfunction getOptimalAngle(boxes, labelOpt) {\n  var angle = 180 * _math.asin((boxes[0].height + labelOpt.minSpacing) / (boxes[1].x - boxes[0].x)) / _math.PI;\n\n  return angle < 45 ? -45 : -90;\n}\n\nfunction updateLabels(ticks, step, func) {\n  ticks.forEach(function (tick, index) {\n    if (tick.getContentContainer()) {\n      if (index % step !== 0) {\n        tick.removeLabel();\n      } else if (func) {\n        func(tick, index);\n      }\n    }\n  });\n}\n\nfunction getZoomBoundValue(optionValue, dataValue) {\n  if (void 0 === optionValue) {\n    return dataValue;\n  } else if (null === optionValue) {\n    return;\n  } else {\n    return optionValue;\n  }\n}\n\nfunction configureGenerator(options, axisDivisionFactor, viewPort, screenDelta, minTickInterval) {\n  var tickGeneratorOptions = extend({}, options, {\n    endOnTick: true,\n    axisDivisionFactor: axisDivisionFactor,\n    skipCalculationLimits: true,\n    generateExtraTick: true,\n    minTickInterval: minTickInterval\n  });\n  return function (tickInterval, skipTickGeneration, min, max, breaks) {\n    return getTickGenerator(tickGeneratorOptions, _noop, skipTickGeneration, viewPort.isEmpty(), v => v, viewPort)({\n      min: min,\n      max: max,\n      categories: viewPort.categories,\n      isSpacedMargin: viewPort.isSpacedMargin\n    }, screenDelta, tickInterval, isDefined(tickInterval), void 0, void 0, void 0, breaks);\n  };\n}\n\nfunction getConstantLineSharpDirection(coord, axisCanvas) {\n  return Math.max(axisCanvas.start, axisCanvas.end) !== coord ? 1 : -1;\n}\n\nexport var Axis = function (renderSettings) {\n  this._renderer = renderSettings.renderer;\n  this._incidentOccurred = renderSettings.incidentOccurred;\n  this._eventTrigger = renderSettings.eventTrigger;\n  this._stripsGroup = renderSettings.stripsGroup;\n  this._stripLabelAxesGroup = renderSettings.stripLabelAxesGroup;\n  this._labelsAxesGroup = renderSettings.labelsAxesGroup;\n  this._constantLinesGroup = renderSettings.constantLinesGroup;\n  this._scaleBreaksGroup = renderSettings.scaleBreaksGroup;\n  this._axesContainerGroup = renderSettings.axesContainerGroup;\n  this._gridContainerGroup = renderSettings.gridGroup;\n  this._axisCssPrefix = renderSettings.widgetClass + \"-\" + (renderSettings.axisClass ? renderSettings.axisClass + \"-\" : \"\");\n\n  this._setType(renderSettings.axisType, renderSettings.drawingType);\n\n  this._createAxisGroups();\n\n  this._translator = this._createTranslator();\n  this.isArgumentAxis = renderSettings.isArgumentAxis;\n  this._viewport = {};\n  this._prevDataInfo = {};\n  this._firstDrawing = true;\n  this._initRange = {};\n  this._getTemplate = renderSettings.getTemplate;\n};\nAxis.prototype = {\n  constructor: Axis,\n\n  _drawAxis() {\n    var options = this._options;\n\n    if (!options.visible) {\n      return;\n    }\n\n    this._axisElement = this._createAxisElement();\n\n    this._updateAxisElementPosition();\n\n    this._axisElement.attr({\n      \"stroke-width\": options.width,\n      stroke: options.color,\n      \"stroke-opacity\": options.opacity\n    }).sharp(this._getSharpParam(true), this.getAxisSharpDirection()).append(this._axisLineGroup);\n  },\n\n  _createPathElement(points, attr, sharpDirection) {\n    return this.sharp(this._renderer.path(points, \"line\").attr(attr), sharpDirection);\n  },\n\n  sharp(svgElement) {\n    var sharpDirection = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\n    return svgElement.sharp(this._getSharpParam(), sharpDirection);\n  },\n\n  customPositionIsAvailable: () => false,\n  getOrthogonalAxis: _noop,\n  getCustomPosition: _noop,\n  getCustomBoundaryPosition: _noop,\n  resolveOverlappingForCustomPositioning: _noop,\n  hasNonBoundaryPosition: () => false,\n  customPositionIsBoundaryOrthogonalAxis: () => false,\n\n  getResolvedBoundaryPosition() {\n    return this.getOptions().position;\n  },\n\n  getAxisSharpDirection() {\n    var position = this.getResolvedBoundaryPosition();\n    return this.hasNonBoundaryPosition() || position !== BOTTOM && position !== RIGHT ? 1 : -1;\n  },\n\n  getSharpDirectionByCoords(coords) {\n    var canvas = this._getCanvasStartEnd();\n\n    var maxCoord = Math.max(canvas.start, canvas.end);\n    return this.getRadius ? 0 : maxCoord !== coords[this._isHorizontal ? \"x\" : \"y\"] ? 1 : -1;\n  },\n\n  _getGridLineDrawer: function () {\n    var that = this;\n    return function (tick, gridStyle) {\n      var grid = that._getGridPoints(tick.coords);\n\n      if (grid.points) {\n        return that._createPathElement(grid.points, gridStyle, that.getSharpDirectionByCoords(tick.coords));\n      }\n\n      return null;\n    };\n  },\n  _getGridPoints: function (coords) {\n    var isHorizontal = this._isHorizontal;\n    var tickPositionField = isHorizontal ? \"x\" : \"y\";\n    var orthogonalPositions = this._orthogonalPositions;\n    var positionFrom = orthogonalPositions.start;\n    var positionTo = orthogonalPositions.end;\n    var borderOptions = this.borderOptions;\n    var canvasStart = isHorizontal ? LEFT : TOP;\n    var canvasEnd = isHorizontal ? RIGHT : BOTTOM;\n    var axisCanvas = this.getCanvas();\n    var canvas = {\n      left: axisCanvas.left,\n      right: axisCanvas.width - axisCanvas.right,\n      top: axisCanvas.top,\n      bottom: axisCanvas.height - axisCanvas.bottom\n    };\n    var firstBorderLinePosition = borderOptions.visible && borderOptions[canvasStart] ? canvas[canvasStart] : void 0;\n    var lastBorderLinePosition = borderOptions.visible && borderOptions[canvasEnd] ? canvas[canvasEnd] : void 0;\n    var minDelta = MAX_GRID_BORDER_ADHENSION + firstBorderLinePosition;\n    var maxDelta = lastBorderLinePosition - MAX_GRID_BORDER_ADHENSION;\n\n    if (this.areCoordsOutsideAxis(coords) || void 0 === coords[tickPositionField] || coords[tickPositionField] < minDelta || coords[tickPositionField] > maxDelta) {\n      return {\n        points: null\n      };\n    }\n\n    return {\n      points: isHorizontal ? null !== coords[tickPositionField] ? [coords[tickPositionField], positionFrom, coords[tickPositionField], positionTo] : null : null !== coords[tickPositionField] ? [positionFrom, coords[tickPositionField], positionTo, coords[tickPositionField]] : null\n    };\n  },\n  _getConstantLinePos: function (parsedValue, canvasStart, canvasEnd) {\n    var value = this._getTranslatedCoord(parsedValue);\n\n    if (!isDefined(value) || value < _min(canvasStart, canvasEnd) || value > _max(canvasStart, canvasEnd)) {\n      return;\n    }\n\n    return value;\n  },\n  _getConstantLineGraphicAttributes: function (value) {\n    var positionFrom = this._orthogonalPositions.start;\n    var positionTo = this._orthogonalPositions.end;\n    return {\n      points: this._isHorizontal ? [value, positionFrom, value, positionTo] : [positionFrom, value, positionTo, value]\n    };\n  },\n  _createConstantLine: function (value, attr) {\n    return this._createPathElement(this._getConstantLineGraphicAttributes(value).points, attr, getConstantLineSharpDirection(value, this._getCanvasStartEnd()));\n  },\n  _drawConstantLineLabelText: function (text, x, y, _ref2, group) {\n    var {\n      font: font,\n      cssClass: cssClass\n    } = _ref2;\n    return this._renderer.text(text, x, y).css(patchFontOptions(extend({}, this._options.label.font, font))).attr({\n      align: \"center\",\n      class: cssClass\n    }).append(group);\n  },\n  _drawConstantLineLabels: function (parsedValue, lineLabelOptions, value, group) {\n    var _text;\n\n    var text = lineLabelOptions.text;\n    var options = this._options;\n    var labelOptions = options.label;\n\n    this._checkAlignmentConstantLineLabels(lineLabelOptions);\n\n    text = null !== (_text = text) && void 0 !== _text ? _text : this.formatLabel(parsedValue, labelOptions);\n\n    var coords = this._getConstantLineLabelsCoords(value, lineLabelOptions);\n\n    return this._drawConstantLineLabelText(text, coords.x, coords.y, lineLabelOptions, group);\n  },\n  _getStripPos: function (startValue, endValue, canvasStart, canvasEnd, range) {\n    var isContinuous = !!(range.minVisible || range.maxVisible);\n    var categories = (range.categories || []).reduce(function (result, cat) {\n      result.push(cat.valueOf());\n      return result;\n    }, []);\n    var start;\n    var end;\n    var swap;\n    var startCategoryIndex;\n    var endCategoryIndex;\n\n    if (!isContinuous) {\n      if (isDefined(startValue) && isDefined(endValue)) {\n        var _parsedStartValue$val, _parsedEndValue$value;\n\n        var parsedStartValue = this.parser(startValue);\n        var parsedEndValue = this.parser(endValue);\n        startCategoryIndex = categories.indexOf(null !== (_parsedStartValue$val = null === parsedStartValue || void 0 === parsedStartValue ? void 0 : parsedStartValue.valueOf()) && void 0 !== _parsedStartValue$val ? _parsedStartValue$val : void 0);\n        endCategoryIndex = categories.indexOf(null !== (_parsedEndValue$value = null === parsedEndValue || void 0 === parsedEndValue ? void 0 : parsedEndValue.valueOf()) && void 0 !== _parsedEndValue$value ? _parsedEndValue$value : void 0);\n\n        if (-1 === startCategoryIndex || -1 === endCategoryIndex) {\n          return {\n            from: 0,\n            to: 0,\n            outOfCanvas: true\n          };\n        }\n\n        if (startCategoryIndex > endCategoryIndex) {\n          swap = endValue;\n          endValue = startValue;\n          startValue = swap;\n        }\n      }\n    }\n\n    if (isDefined(startValue)) {\n      startValue = this.validateUnit(startValue, \"E2105\", \"strip\");\n      start = this._getTranslatedCoord(startValue, -1);\n    } else {\n      start = canvasStart;\n    }\n\n    if (isDefined(endValue)) {\n      endValue = this.validateUnit(endValue, \"E2105\", \"strip\");\n      end = this._getTranslatedCoord(endValue, 1);\n    } else {\n      end = canvasEnd;\n    }\n\n    var stripPosition = start < end ? {\n      from: start,\n      to: end\n    } : {\n      from: end,\n      to: start\n    };\n    var visibleArea = this.getVisibleArea();\n\n    if (stripPosition.from <= visibleArea[0] && stripPosition.to <= visibleArea[0] || stripPosition.from >= visibleArea[1] && stripPosition.to >= visibleArea[1]) {\n      stripPosition.outOfCanvas = true;\n    }\n\n    return stripPosition;\n  },\n  _getStripGraphicAttributes: function (fromPoint, toPoint) {\n    var x;\n    var y;\n    var width;\n    var height;\n    var orthogonalPositions = this._orthogonalPositions;\n    var positionFrom = orthogonalPositions.start;\n    var positionTo = orthogonalPositions.end;\n\n    if (this._isHorizontal) {\n      x = fromPoint;\n      y = _min(positionFrom, positionTo);\n      width = toPoint - fromPoint;\n      height = _abs(positionFrom - positionTo);\n    } else {\n      x = _min(positionFrom, positionTo);\n      y = fromPoint;\n      width = _abs(positionFrom - positionTo);\n      height = _abs(fromPoint - toPoint);\n    }\n\n    return {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    };\n  },\n  _createStrip: function (attrs) {\n    return this._renderer.rect(attrs.x, attrs.y, attrs.width, attrs.height);\n  },\n  _adjustStripLabels: function () {\n    var that = this;\n\n    this._strips.forEach(function (strip) {\n      if (strip.label) {\n        strip.label.attr(that._getAdjustedStripLabelCoords(strip));\n      }\n    });\n  },\n\n  _adjustLabelsCoord(offset, maxWidth, checkCanvas) {\n    var getContainerAttrs = tick => this._getLabelAdjustedCoord(tick, offset + (tick.labelOffset || 0), maxWidth, checkCanvas);\n\n    this._majorTicks.forEach(function (tick) {\n      if (tick.label) {\n        tick.updateMultilineTextAlignment();\n        tick.label.attr(getContainerAttrs(tick));\n      } else {\n        tick.templateContainer && tick.templateContainer.attr(getContainerAttrs(tick));\n      }\n    });\n  },\n\n  _adjustLabels: function (offset) {\n    var options = this.getOptions();\n    var positionsAreConsistent = options.position === options.label.position;\n\n    var maxSize = this._majorTicks.reduce(function (size, tick) {\n      if (!tick.getContentContainer()) {\n        return size;\n      }\n\n      var bBox = tick.labelRotationAngle ? rotateBBox(tick.labelBBox, [tick.labelCoords.x, tick.labelCoords.y], -tick.labelRotationAngle) : tick.labelBBox;\n      return {\n        width: _max(size.width || 0, bBox.width),\n        height: _max(size.height || 0, bBox.height),\n        offset: _max(size.offset || 0, tick.labelOffset || 0)\n      };\n    }, {});\n\n    var additionalOffset = positionsAreConsistent ? this._isHorizontal ? maxSize.height : maxSize.width : 0;\n\n    this._adjustLabelsCoord(offset, maxSize.width);\n\n    return offset + additionalOffset + (additionalOffset && this._options.label.indentFromAxis) + (positionsAreConsistent ? maxSize.offset : 0);\n  },\n  _getLabelAdjustedCoord: function (tick, offset, maxWidth) {\n    offset = offset || 0;\n    var options = this._options;\n    var templateBox = tick.templateContainer && tick.templateContainer.getBBox();\n    var box = templateBox || rotateBBox(tick.labelBBox, [tick.labelCoords.x, tick.labelCoords.y], -tick.labelRotationAngle || 0);\n    var textAlign = tick.labelAlignment || options.label.alignment;\n    var isDiscrete = \"discrete\" === this._options.type;\n    var isFlatLabel = tick.labelRotationAngle % 90 === 0;\n    var indentFromAxis = options.label.indentFromAxis;\n    var labelPosition = options.label.position;\n    var axisPosition = this._axisPosition;\n    var labelCoords = tick.labelCoords;\n    var labelX = labelCoords.x;\n    var translateX;\n    var translateY;\n\n    if (this._isHorizontal) {\n      if (labelPosition === BOTTOM) {\n        translateY = axisPosition + indentFromAxis - box.y + offset;\n      } else {\n        translateY = axisPosition - indentFromAxis - (box.y + box.height) - offset;\n      }\n\n      if (textAlign === RIGHT) {\n        translateX = isDiscrete && isFlatLabel ? tick.coords.x - (box.x + box.width) : labelX - box.x - box.width;\n      } else if (textAlign === LEFT) {\n        translateX = isDiscrete && isFlatLabel ? labelX - box.x - (tick.coords.x - labelX) : labelX - box.x;\n      } else {\n        translateX = labelX - box.x - box.width / 2;\n      }\n    } else {\n      translateY = labelCoords.y - box.y - box.height / 2;\n\n      if (labelPosition === LEFT) {\n        if (textAlign === LEFT) {\n          translateX = axisPosition - indentFromAxis - maxWidth - box.x;\n        } else if (textAlign === CENTER) {\n          translateX = axisPosition - indentFromAxis - maxWidth / 2 - box.x - box.width / 2;\n        } else {\n          translateX = axisPosition - indentFromAxis - box.x - box.width;\n        }\n\n        translateX -= offset;\n      } else {\n        if (textAlign === RIGHT) {\n          translateX = axisPosition + indentFromAxis + maxWidth - box.x - box.width;\n        } else if (textAlign === CENTER) {\n          translateX = axisPosition + indentFromAxis + maxWidth / 2 - box.x - box.width / 2;\n        } else {\n          translateX = axisPosition + indentFromAxis - box.x;\n        }\n\n        translateX += offset;\n      }\n    }\n\n    return {\n      translateX: translateX,\n      translateY: translateY\n    };\n  },\n  _createAxisConstantLineGroups: function () {\n    var renderer = this._renderer;\n    var classSelector = this._axisCssPrefix;\n    var constantLinesClass = classSelector + \"constant-lines\";\n    var insideGroup = renderer.g().attr({\n      class: constantLinesClass\n    });\n    var outsideGroup1 = renderer.g().attr({\n      class: constantLinesClass\n    });\n    var outsideGroup2 = renderer.g().attr({\n      class: constantLinesClass\n    });\n    return {\n      inside: insideGroup,\n      outside1: outsideGroup1,\n      left: outsideGroup1,\n      top: outsideGroup1,\n      outside2: outsideGroup2,\n      right: outsideGroup2,\n      bottom: outsideGroup2,\n      remove: function () {\n        this.inside.remove();\n        this.outside1.remove();\n        this.outside2.remove();\n      },\n      clear: function () {\n        this.inside.clear();\n        this.outside1.clear();\n        this.outside2.clear();\n      }\n    };\n  },\n  _createAxisGroups: function () {\n    var renderer = this._renderer;\n    var classSelector = this._axisCssPrefix;\n    this._axisGroup = renderer.g().attr({\n      class: classSelector + \"axis\"\n    }).enableLinks();\n    this._axisStripGroup = renderer.g().attr({\n      class: classSelector + \"strips\"\n    });\n    this._axisGridGroup = renderer.g().attr({\n      class: classSelector + \"grid\"\n    });\n    this._axisElementsGroup = renderer.g().attr({\n      class: classSelector + \"elements\"\n    });\n    this._axisLineGroup = renderer.g().attr({\n      class: classSelector + \"line\"\n    }).linkOn(this._axisGroup, \"axisLine\").linkAppend();\n    this._axisTitleGroup = renderer.g().attr({\n      class: classSelector + \"title\"\n    }).append(this._axisGroup);\n    this._axisConstantLineGroups = {\n      above: this._createAxisConstantLineGroups(),\n      under: this._createAxisConstantLineGroups()\n    };\n    this._axisStripLabelGroup = renderer.g().attr({\n      class: classSelector + \"axis-labels\"\n    });\n  },\n  _clearAxisGroups: function () {\n    this._axisGroup.remove();\n\n    this._axisStripGroup.remove();\n\n    this._axisStripLabelGroup.remove();\n\n    this._axisConstantLineGroups.above.remove();\n\n    this._axisConstantLineGroups.under.remove();\n\n    this._axisGridGroup.remove();\n\n    this._axisTitleGroup.clear();\n\n    if (!this._options.label.template || !this.isRendered()) {\n      this._axisElementsGroup.remove();\n\n      this._axisElementsGroup.clear();\n    }\n\n    this._axisLineGroup && this._axisLineGroup.clear();\n    this._axisStripGroup && this._axisStripGroup.clear();\n    this._axisGridGroup && this._axisGridGroup.clear();\n\n    this._axisConstantLineGroups.above.clear();\n\n    this._axisConstantLineGroups.under.clear();\n\n    this._axisStripLabelGroup && this._axisStripLabelGroup.clear();\n  },\n  _getLabelFormatObject: function (value, labelOptions, range, point, tickInterval, ticks) {\n    range = range || this._getViewportRange();\n    var formatObject = {\n      value: value,\n      valueText: _format(value, {\n        labelOptions: labelOptions,\n        ticks: ticks || convertTicksToValues(this._majorTicks),\n        tickInterval: null !== tickInterval && void 0 !== tickInterval ? tickInterval : this._tickInterval,\n        dataType: this._options.dataType,\n        logarithmBase: this._options.logarithmBase,\n        type: this._options.type,\n        showTransition: !this._options.marker.visible,\n        point: point\n      }) || \"\",\n      min: range.minVisible,\n      max: range.maxVisible\n    };\n\n    if (point) {\n      formatObject.point = point;\n    }\n\n    return formatObject;\n  },\n  formatLabel: function (value, labelOptions, range, point, tickInterval, ticks) {\n    var formatObject = this._getLabelFormatObject(value, labelOptions, range, point, tickInterval, ticks);\n\n    return isFunction(labelOptions.customizeText) ? labelOptions.customizeText.call(formatObject, formatObject) : formatObject.valueText;\n  },\n  formatHint: function (value, labelOptions, range) {\n    var formatObject = this._getLabelFormatObject(value, labelOptions, range);\n\n    return isFunction(labelOptions.customizeHint) ? labelOptions.customizeHint.call(formatObject, formatObject) : void 0;\n  },\n\n  formatRange(startValue, endValue, interval, argumentFormat) {\n    return formatRange({\n      startValue: startValue,\n      endValue: endValue,\n      tickInterval: interval,\n      argumentFormat: argumentFormat,\n      axisOptions: this.getOptions()\n    });\n  },\n\n  _setTickOffset: function () {\n    var options = this._options;\n    var discreteAxisDivisionMode = options.discreteAxisDivisionMode;\n    this._tickOffset = +(\"crossLabels\" !== discreteAxisDivisionMode || !discreteAxisDivisionMode);\n  },\n\n  aggregatedPointBetweenTicks() {\n    return \"crossTicks\" === this._options.aggregatedPointsPosition;\n  },\n\n  resetApplyingAnimation: function (isFirstDrawing) {\n    this._resetApplyingAnimation = true;\n\n    if (isFirstDrawing) {\n      this._firstDrawing = true;\n    }\n  },\n\n  isFirstDrawing() {\n    return this._firstDrawing;\n  },\n\n  getMargins: function () {\n    var that = this;\n    var {\n      position: position,\n      offset: offset,\n      customPosition: customPosition,\n      placeholderSize: placeholderSize,\n      grid: grid,\n      tick: tick,\n      crosshairMargin: crosshairMargin\n    } = that._options;\n    var isDefinedCustomPositionOption = isDefined(customPosition);\n    var boundaryPosition = that.getResolvedBoundaryPosition();\n    var canvas = that.getCanvas();\n    var cLeft = canvas.left;\n    var cTop = canvas.top;\n    var cRight = canvas.width - canvas.right;\n    var cBottom = canvas.height - canvas.bottom;\n\n    var edgeMarginCorrection = _max(grid.visible && grid.width || 0, tick.visible && tick.width || 0);\n\n    var constantLineAboveSeries = that._axisConstantLineGroups.above;\n    var constantLineUnderSeries = that._axisConstantLineGroups.under;\n    var boxes = [that._axisElementsGroup, constantLineAboveSeries.outside1, constantLineAboveSeries.outside2, constantLineUnderSeries.outside1, constantLineUnderSeries.outside2, that._axisLineGroup].map(group => group && group.getBBox()).concat(function (group) {\n      var box = group && group.getBBox();\n\n      if (!box || box.isEmpty) {\n        return box;\n      }\n\n      if (that._isHorizontal) {\n        box.x = cLeft;\n        box.width = cRight - cLeft;\n      } else {\n        box.y = cTop;\n        box.height = cBottom - cTop;\n      }\n\n      return box;\n    }(that._axisTitleGroup));\n    var margins = calculateCanvasMargins(boxes, canvas);\n    margins[position] += crosshairMargin;\n\n    if (that.hasNonBoundaryPosition() && isDefinedCustomPositionOption) {\n      margins[boundaryPosition] = 0;\n    }\n\n    if (placeholderSize) {\n      margins[position] = placeholderSize;\n    }\n\n    if (edgeMarginCorrection) {\n      if (that._isHorizontal && canvas.right < edgeMarginCorrection && margins.right < edgeMarginCorrection) {\n        margins.right = edgeMarginCorrection;\n      }\n\n      if (!that._isHorizontal && canvas.bottom < edgeMarginCorrection && margins.bottom < edgeMarginCorrection) {\n        margins.bottom = edgeMarginCorrection;\n      }\n    }\n\n    if (!isDefinedCustomPositionOption && isDefined(offset)) {\n      var moveByOffset = that.customPositionIsBoundary() && (offset > 0 && (boundaryPosition === LEFT || boundaryPosition === TOP) || offset < 0 && (boundaryPosition === RIGHT || boundaryPosition === BOTTOM));\n      margins[boundaryPosition] -= moveByOffset ? offset : 0;\n    }\n\n    return margins;\n  },\n  validateUnit: function (unit, idError, parameters) {\n    unit = this.parser(unit);\n\n    if (void 0 === unit && idError) {\n      this._incidentOccurred(idError, [parameters]);\n    }\n\n    return unit;\n  },\n  _setType: function (axisType, drawingType) {\n    var axisTypeMethods;\n\n    switch (axisType) {\n      case \"xyAxes\":\n        axisTypeMethods = xyMethods;\n        break;\n\n      case \"polarAxes\":\n        axisTypeMethods = polarMethods;\n    }\n\n    extend(this, axisTypeMethods[drawingType]);\n  },\n  _getSharpParam: function () {\n    return true;\n  },\n  _disposeBreaksGroup: _noop,\n  dispose: function () {\n    [this._axisElementsGroup, this._axisStripGroup, this._axisGroup].forEach(function (g) {\n      g.dispose();\n    });\n    this._strips = this._title = null;\n    this._axisStripGroup = this._axisConstantLineGroups = this._axisStripLabelGroup = this._axisBreaksGroup = null;\n    this._axisLineGroup = this._axisElementsGroup = this._axisGridGroup = null;\n    this._axisGroup = this._axisTitleGroup = null;\n    this._axesContainerGroup = this._stripsGroup = this._constantLinesGroup = this._labelsAxesGroup = null;\n    this._renderer = this._options = this._textOptions = this._textFontStyles = null;\n    this._translator = null;\n    this._majorTicks = this._minorTicks = null;\n\n    this._disposeBreaksGroup();\n\n    this._templatesRendered && this._templatesRendered.reject();\n  },\n  getOptions: function () {\n    return this._options;\n  },\n  setPane: function (pane) {\n    this.pane = pane;\n    this._options.pane = pane;\n  },\n  setTypes: function (type, axisType, typeSelector) {\n    this._options.type = type || this._options.type;\n    this._options[typeSelector] = axisType || this._options[typeSelector];\n\n    this._updateTranslator();\n  },\n  resetTypes: function (typeSelector) {\n    this._options.type = this._initTypes.type;\n    this._options[typeSelector] = this._initTypes[typeSelector];\n  },\n  getTranslator: function () {\n    return this._translator;\n  },\n  updateOptions: function (options) {\n    var that = this;\n    var labelOpt = options.label;\n    validateAxisOptions(options);\n    that._options = options;\n    options.tick = options.tick || {};\n    options.minorTick = options.minorTick || {};\n    options.grid = options.grid || {};\n    options.minorGrid = options.minorGrid || {};\n    options.title = options.title || {};\n    options.marker = options.marker || {};\n    that._initTypes = {\n      type: options.type,\n      argumentType: options.argumentType,\n      valueType: options.valueType\n    };\n\n    that._setTickOffset();\n\n    that._isHorizontal = options.isHorizontal;\n    that.pane = options.pane;\n    that.name = options.name;\n    that.priority = options.priority;\n    that._hasLabelFormat = \"\" !== labelOpt.format && isDefined(labelOpt.format);\n    that._textOptions = {\n      opacity: labelOpt.opacity,\n      align: \"center\",\n      class: labelOpt.cssClass\n    };\n    that._textFontStyles = patchFontOptions(labelOpt.font);\n\n    if (options.type === constants.logarithmic) {\n      if (options.logarithmBaseError) {\n        that._incidentOccurred(\"E2104\");\n\n        delete options.logarithmBaseError;\n      }\n    }\n\n    that._updateTranslator();\n\n    that._createConstantLines();\n\n    that._strips = (options.strips || []).map(o => createStrip(that, o));\n    that._majorTicks = that._minorTicks = null;\n    that._firstDrawing = true;\n  },\n  calculateInterval: function (value, prevValue) {\n    var options = this._options;\n\n    if (!options || options.type !== constants.logarithmic) {\n      return _abs(value - prevValue);\n    }\n\n    var {\n      allowNegatives: allowNegatives,\n      linearThreshold: linearThreshold\n    } = new Range(this.getTranslator().getBusinessRange());\n    return _abs(getLog(value, options.logarithmBase, allowNegatives, linearThreshold) - getLog(prevValue, options.logarithmBase, allowNegatives, linearThreshold));\n  },\n\n  getCanvasRange() {\n    var translator = this._translator;\n    return {\n      startValue: translator.from(translator.translate(\"canvas_position_start\")),\n      endValue: translator.from(translator.translate(\"canvas_position_end\"))\n    };\n  },\n\n  _processCanvas: function (canvas) {\n    return canvas;\n  },\n  updateCanvas: function (canvas, canvasRedesign) {\n    if (!canvasRedesign) {\n      var positions = this._orthogonalPositions = {\n        start: !this._isHorizontal ? canvas.left : canvas.top,\n        end: !this._isHorizontal ? canvas.width - canvas.right : canvas.height - canvas.bottom\n      };\n      positions.center = positions.start + (positions.end - positions.start) / 2;\n    } else {\n      this._orthogonalPositions = null;\n    }\n\n    this._canvas = canvas;\n\n    this._translator.updateCanvas(this._processCanvas(canvas));\n\n    this._initAxisPositions();\n  },\n  getCanvas: function () {\n    return this._canvas;\n  },\n\n  getAxisShift() {\n    return this._axisShift || 0;\n  },\n\n  hideTitle: function () {\n    if (this._options.title.text) {\n      this._incidentOccurred(\"W2105\", [this._isHorizontal ? \"horizontal\" : \"vertical\"]);\n\n      this._axisTitleGroup.clear();\n    }\n  },\n  getTitle: function () {\n    return this._title;\n  },\n  hideOuterElements: function () {\n    var options = this._options;\n\n    if ((options.label.visible || this._outsideConstantLines.length) && !this._translator.getBusinessRange().isEmpty()) {\n      this._incidentOccurred(\"W2106\", [this._isHorizontal ? \"horizontal\" : \"vertical\"]);\n\n      this._axisElementsGroup.clear();\n\n      callAction(this._outsideConstantLines, \"removeLabel\");\n    }\n  },\n\n  _resolveLogarithmicOptionsForRange(range) {\n    var options = this._options;\n\n    if (options.type === constants.logarithmic) {\n      range.addRange({\n        allowNegatives: void 0 !== options.allowNegatives ? options.allowNegatives : range.min <= 0\n      });\n\n      if (!isNaN(options.linearThreshold)) {\n        range.linearThreshold = options.linearThreshold;\n      }\n    }\n  },\n\n  adjustViewport(businessRange) {\n    var options = this._options;\n    var isDiscrete = options.type === constants.discrete;\n    var categories = this._seriesData && this._seriesData.categories || [];\n    var wholeRange = this.adjustRange(getVizRangeObject(options.wholeRange));\n    var visualRange = this.getViewport() || {};\n    var result = new Range(businessRange);\n\n    this._addConstantLinesToRange(result, \"minVisible\", \"maxVisible\");\n\n    var minDefined = isDefined(visualRange.startValue);\n    var maxDefined = isDefined(visualRange.endValue);\n\n    if (!isDiscrete) {\n      minDefined = minDefined && (!isDefined(wholeRange.endValue) || visualRange.startValue < wholeRange.endValue);\n      maxDefined = maxDefined && (!isDefined(wholeRange.startValue) || visualRange.endValue > wholeRange.startValue);\n    }\n\n    var minVisible = minDefined ? visualRange.startValue : result.minVisible;\n    var maxVisible = maxDefined ? visualRange.endValue : result.maxVisible;\n\n    if (!isDiscrete) {\n      var _wholeRange$startValu, _wholeRange$endValue;\n\n      result.min = null !== (_wholeRange$startValu = wholeRange.startValue) && void 0 !== _wholeRange$startValu ? _wholeRange$startValu : result.min;\n      result.max = null !== (_wholeRange$endValue = wholeRange.endValue) && void 0 !== _wholeRange$endValue ? _wholeRange$endValue : result.max;\n    } else {\n      var categoriesInfo = getCategoriesInfo(categories, wholeRange.startValue, wholeRange.endValue);\n      categories = categoriesInfo.categories;\n      result.categories = categories;\n    }\n\n    var adjustedVisualRange = adjustVisualRange({\n      axisType: options.type,\n      dataType: options.dataType,\n      base: options.logarithmBase\n    }, {\n      startValue: minDefined ? visualRange.startValue : void 0,\n      endValue: maxDefined ? visualRange.endValue : void 0,\n      length: visualRange.length\n    }, {\n      categories: categories,\n      min: wholeRange.startValue,\n      max: wholeRange.endValue\n    }, {\n      categories: categories,\n      min: minVisible,\n      max: maxVisible\n    });\n    result.minVisible = adjustedVisualRange.startValue;\n    result.maxVisible = adjustedVisualRange.endValue;\n    !isDefined(result.min) && (result.min = result.minVisible);\n    !isDefined(result.max) && (result.max = result.maxVisible);\n    result.addRange({});\n\n    this._resolveLogarithmicOptionsForRange(result);\n\n    return result;\n  },\n\n  adjustRange(range) {\n    range = range || {};\n    var isDiscrete = this._options.type === constants.discrete;\n    var isLogarithmic = this._options.type === constants.logarithmic;\n    var disabledNegatives = false === this._options.allowNegatives;\n\n    if (isLogarithmic) {\n      range.startValue = disabledNegatives && range.startValue <= 0 ? null : range.startValue;\n      range.endValue = disabledNegatives && range.endValue <= 0 ? null : range.endValue;\n    }\n\n    if (!isDiscrete && isDefined(range.startValue) && isDefined(range.endValue) && range.startValue > range.endValue) {\n      var tmp = range.endValue;\n      range.endValue = range.startValue;\n      range.startValue = tmp;\n    }\n\n    return range;\n  },\n\n  _getVisualRangeUpdateMode(viewport, newRange, oppositeValue) {\n    var value = this._options.visualRangeUpdateMode;\n    var translator = this._translator;\n    var range = this._seriesData;\n    var prevDataInfo = this._prevDataInfo;\n\n    if (prevDataInfo.isEmpty && !prevDataInfo.containsConstantLine) {\n      return KEEP;\n    }\n\n    if (!this.isArgumentAxis) {\n      var _viewport = this.getViewport();\n\n      if (!isDefined(_viewport.startValue) && !isDefined(_viewport.endValue) && !isDefined(_viewport.length)) {\n        return RESET;\n      }\n    }\n\n    if (this.isArgumentAxis) {\n      if (-1 === [SHIFT, KEEP, RESET].indexOf(value)) {\n        if (range.axisType === constants.discrete) {\n          var categories = range.categories;\n          var newCategories = newRange.categories;\n          var visualRange = this.visualRange();\n\n          if (categories && newCategories && categories.length && -1 !== newCategories.map(c => c.valueOf()).join(\",\").indexOf(categories.map(c => c.valueOf()).join(\",\")) && (visualRange.startValue.valueOf() !== categories[0].valueOf() || visualRange.endValue.valueOf() !== categories[categories.length - 1].valueOf())) {\n            value = KEEP;\n          } else {\n            value = RESET;\n          }\n        } else {\n          var minPoint = translator.translate(range.min);\n          var minVisiblePoint = translator.translate(viewport.startValue);\n          var maxPoint = translator.translate(range.max);\n          var maxVisiblePoint = translator.translate(viewport.endValue);\n\n          if (minPoint === minVisiblePoint && maxPoint === maxVisiblePoint) {\n            value = RESET;\n          } else if (minPoint !== minVisiblePoint && maxPoint === maxVisiblePoint) {\n            value = SHIFT;\n          } else {\n            value = KEEP;\n          }\n        }\n\n        if (value === KEEP && prevDataInfo.isEmpty && prevDataInfo.containsConstantLine) {\n          value = RESET;\n        }\n      }\n    } else if (-1 === [KEEP, RESET].indexOf(value)) {\n      if (oppositeValue === KEEP) {\n        value = KEEP;\n      } else {\n        value = RESET;\n      }\n    }\n\n    return value;\n  },\n\n  _handleBusinessRangeChanged(oppositeVisualRangeUpdateMode, axisReinitialized, newRange) {\n    var visualRange = this.visualRange();\n\n    if (axisReinitialized || this._translator.getBusinessRange().isEmpty()) {\n      return;\n    }\n\n    var visualRangeUpdateMode = this._lastVisualRangeUpdateMode = this._getVisualRangeUpdateMode(visualRange, newRange, oppositeVisualRangeUpdateMode);\n\n    if (visualRangeUpdateMode === KEEP) {\n      this._setVisualRange([visualRange.startValue, visualRange.endValue]);\n    } else if (visualRangeUpdateMode === RESET) {\n      this._setVisualRange([null, null]);\n    } else if (visualRangeUpdateMode === SHIFT) {\n      this._setVisualRange({\n        length: this.getVisualRangeLength()\n      });\n    }\n  },\n\n  getVisualRangeLength(range) {\n    var currentBusinessRange = range || this._translator.getBusinessRange();\n\n    var {\n      type: type\n    } = this._options;\n    var length;\n\n    if (type === constants.logarithmic) {\n      length = adjust(this.calculateInterval(currentBusinessRange.maxVisible, currentBusinessRange.minVisible));\n    } else if (type === constants.discrete) {\n      var categoriesInfo = getCategoriesInfo(currentBusinessRange.categories, currentBusinessRange.minVisible, currentBusinessRange.maxVisible);\n      length = categoriesInfo.categories.length;\n    } else {\n      length = currentBusinessRange.maxVisible - currentBusinessRange.minVisible;\n    }\n\n    return length;\n  },\n\n  getVisualRangeCenter(range, useMerge) {\n    var translator = this.getTranslator();\n    var businessRange = translator.getBusinessRange();\n    var currentBusinessRange = useMerge ? extend(true, {}, businessRange, range || {}) : range || businessRange;\n    var {\n      type: type,\n      logarithmBase: logarithmBase\n    } = this._options;\n    var center;\n\n    if (!isDefined(currentBusinessRange.minVisible) || !isDefined(currentBusinessRange.maxVisible)) {\n      return;\n    }\n\n    if (type === constants.logarithmic) {\n      var {\n        allowNegatives: allowNegatives,\n        linearThreshold: linearThreshold,\n        minVisible: minVisible,\n        maxVisible: maxVisible\n      } = currentBusinessRange;\n      center = raiseTo(adjust(getLog(maxVisible, logarithmBase, allowNegatives, linearThreshold) + getLog(minVisible, logarithmBase, allowNegatives, linearThreshold)) / 2, logarithmBase, allowNegatives, linearThreshold);\n    } else if (type === constants.discrete) {\n      var categoriesInfo = getCategoriesInfo(currentBusinessRange.categories, currentBusinessRange.minVisible, currentBusinessRange.maxVisible);\n      var index = Math.ceil(categoriesInfo.categories.length / 2) - 1;\n      center = businessRange.categories.indexOf(categoriesInfo.categories[index]);\n    } else {\n      center = translator.toValue((currentBusinessRange.maxVisible.valueOf() + currentBusinessRange.minVisible.valueOf()) / 2);\n    }\n\n    return center;\n  },\n\n  setBusinessRange(range, axisReinitialized, oppositeVisualRangeUpdateMode, argCategories) {\n    var _that$_seriesData$min, _that$_seriesData$max;\n\n    var options = this._options;\n    var isDiscrete = options.type === constants.discrete;\n\n    this._handleBusinessRangeChanged(oppositeVisualRangeUpdateMode, axisReinitialized, range);\n\n    this._seriesData = new Range(range);\n\n    var dataIsEmpty = this._seriesData.isEmpty();\n\n    var rangeWithConstantLines = new Range(this._seriesData);\n\n    this._addConstantLinesToRange(rangeWithConstantLines, \"minVisible\", \"maxVisible\");\n\n    this._prevDataInfo = {\n      isEmpty: dataIsEmpty,\n      containsConstantLine: rangeWithConstantLines.containsConstantLine\n    };\n\n    this._seriesData.addRange({\n      categories: options.categories,\n      dataType: options.dataType,\n      axisType: options.type,\n      base: options.logarithmBase,\n      invert: options.inverted\n    });\n\n    this._resolveLogarithmicOptionsForRange(this._seriesData);\n\n    if (!isDiscrete) {\n      if (!isDefined(this._seriesData.min) && !isDefined(this._seriesData.max)) {\n        var visualRange = this.getViewport();\n        visualRange && this._seriesData.addRange({\n          min: visualRange.startValue,\n          max: visualRange.endValue\n        });\n      }\n\n      var synchronizedValue = options.synchronizedValue;\n\n      if (isDefined(synchronizedValue)) {\n        this._seriesData.addRange({\n          min: synchronizedValue,\n          max: synchronizedValue\n        });\n      }\n    }\n\n    this._seriesData.minVisible = null !== (_that$_seriesData$min = this._seriesData.minVisible) && void 0 !== _that$_seriesData$min ? _that$_seriesData$min : this._seriesData.min;\n    this._seriesData.maxVisible = null !== (_that$_seriesData$max = this._seriesData.maxVisible) && void 0 !== _that$_seriesData$max ? _that$_seriesData$max : this._seriesData.max;\n\n    if (!this.isArgumentAxis && options.showZero) {\n      this._seriesData.correctValueZeroLevel();\n    }\n\n    this._seriesData.sortCategories(this.getCategoriesSorter(argCategories));\n\n    this._seriesData.userBreaks = this._seriesData.isEmpty() ? [] : this._getScaleBreaks(options, this._seriesData, this._series, this.isArgumentAxis);\n\n    this._translator.updateBusinessRange(this._getViewportRange());\n  },\n\n  _addConstantLinesToRange(dataRange, minValueField, maxValueField) {\n    this._outsideConstantLines.concat(this._insideConstantLines || []).forEach(cl => {\n      if (cl.options.extendAxis) {\n        var value = cl.getParsedValue();\n        dataRange.addRange({\n          containsConstantLine: true,\n          [minValueField]: value,\n          [maxValueField]: value\n        });\n      }\n    });\n  },\n\n  setGroupSeries: function (series) {\n    this._series = series;\n  },\n  getLabelsPosition: function () {\n    var options = this._options;\n    var position = options.position;\n    var labelShift = options.label.indentFromAxis + (this._axisShift || 0) + this._constantLabelOffset;\n    var axisPosition = this._axisPosition;\n    return position === TOP || position === LEFT ? axisPosition - labelShift : axisPosition + labelShift;\n  },\n  getFormattedValue: function (value, options, point) {\n    var labelOptions = this._options.label;\n    return isDefined(value) ? this.formatLabel(value, extend(true, {}, labelOptions, options), void 0, point) : null;\n  },\n  _getBoundaryTicks: function (majors, viewPort) {\n    var length = majors.length;\n    var options = this._options;\n    var customBounds = options.customBoundTicks;\n    var min = viewPort.minVisible;\n    var max = viewPort.maxVisible;\n    var addMinMax = options.showCustomBoundaryTicks ? this._boundaryTicksVisibility : {};\n    var boundaryTicks = [];\n\n    if (options.type === constants.discrete) {\n      if (this._tickOffset && 0 !== majors.length) {\n        boundaryTicks = [majors[0], majors[majors.length - 1]];\n      }\n    } else if (customBounds) {\n      if (addMinMax.min && isDefined(customBounds[0])) {\n        boundaryTicks.push(customBounds[0]);\n      }\n\n      if (addMinMax.max && isDefined(customBounds[1])) {\n        boundaryTicks.push(customBounds[1]);\n      }\n    } else {\n      if (addMinMax.min && (0 === length || majors[0] > min)) {\n        boundaryTicks.push(min);\n      }\n\n      if (addMinMax.max && (0 === length || majors[length - 1] < max)) {\n        boundaryTicks.push(max);\n      }\n    }\n\n    return boundaryTicks;\n  },\n  setPercentLabelFormat: function () {\n    if (!this._hasLabelFormat) {\n      this._options.label.format = \"percent\";\n    }\n  },\n  resetAutoLabelFormat: function () {\n    if (!this._hasLabelFormat) {\n      delete this._options.label.format;\n    }\n  },\n  getMultipleAxesSpacing: function () {\n    return this._options.multipleAxesSpacing || 0;\n  },\n  getTicksValues: function () {\n    return {\n      majorTicksValues: convertTicksToValues(this._majorTicks),\n      minorTicksValues: convertTicksToValues(this._minorTicks)\n    };\n  },\n  estimateTickInterval: function (canvas) {\n    this.updateCanvas(canvas);\n    return this._tickInterval !== this._getTicks(this._getViewportRange(), _noop, true).tickInterval;\n  },\n  setTicks: function (ticks) {\n    var majors = ticks.majorTicks || [];\n    this._majorTicks = majors.map(createMajorTick(this, this._renderer, this._getSkippedCategory(majors)));\n    this._minorTicks = (ticks.minorTicks || []).map(createMinorTick(this, this._renderer));\n    this._isSynchronized = true;\n  },\n  _adjustDivisionFactor: function (val) {\n    return val;\n  },\n  _getTicks: function (viewPort, incidentOccurred, skipTickGeneration) {\n    var options = this._options;\n    var customTicks = options.customTicks;\n    var customMinorTicks = options.customMinorTicks;\n    return getTickGenerator(options, incidentOccurred || this._incidentOccurred, skipTickGeneration, this._translator.getBusinessRange().isEmpty(), this._adjustDivisionFactor.bind(this), viewPort)({\n      min: viewPort.minVisible,\n      max: viewPort.maxVisible,\n      categories: viewPort.categories,\n      isSpacedMargin: viewPort.isSpacedMargin\n    }, this._getScreenDelta(), options.tickInterval, \"ignore\" === options.label.overlappingBehavior || options.forceUserTickInterval, {\n      majors: customTicks,\n      minors: customMinorTicks\n    }, options.minorTickInterval, options.minorTickCount, this._initialBreaks);\n  },\n  _createTicksAndLabelFormat: function (range, incidentOccurred) {\n    var options = this._options;\n\n    var ticks = this._getTicks(range, incidentOccurred, false);\n\n    if (!range.isEmpty() && options.type === constants.discrete && \"datetime\" === options.dataType && !this._hasLabelFormat && ticks.ticks.length) {\n      options.label.format = formatHelper.getDateFormatByTicks(ticks.ticks);\n    }\n\n    return ticks;\n  },\n\n  getAggregationInfo(useAllAggregatedPoints, range) {\n    var _visualRange$startVal, _visualRange$endValue, _that$_seriesData;\n\n    var options = this._options;\n    var marginOptions = this._marginOptions;\n    var businessRange = new Range(this.getTranslator().getBusinessRange()).addRange(range);\n    var visualRange = this.getViewport();\n    var minVisible = null !== (_visualRange$startVal = null === visualRange || void 0 === visualRange ? void 0 : visualRange.startValue) && void 0 !== _visualRange$startVal ? _visualRange$startVal : businessRange.minVisible;\n    var maxVisible = null !== (_visualRange$endValue = null === visualRange || void 0 === visualRange ? void 0 : visualRange.endValue) && void 0 !== _visualRange$endValue ? _visualRange$endValue : businessRange.maxVisible;\n    var ticks = [];\n\n    if (options.type === constants.discrete && options.aggregateByCategory) {\n      return {\n        aggregateByCategory: true\n      };\n    }\n\n    var aggregationInterval = options.aggregationInterval;\n    var aggregationGroupWidth = options.aggregationGroupWidth;\n\n    if (!aggregationGroupWidth && marginOptions) {\n      if (marginOptions.checkInterval) {\n        aggregationGroupWidth = options.axisDivisionFactor;\n      }\n\n      if (marginOptions.sizePointNormalState) {\n        aggregationGroupWidth = Math.min(marginOptions.sizePointNormalState, options.axisDivisionFactor);\n      }\n    }\n\n    var minInterval = !options.aggregationGroupWidth && !aggregationInterval && range.interval;\n    var generateTicks = configureGenerator(options, aggregationGroupWidth, businessRange, this._getScreenDelta(), minInterval);\n    var tickInterval = generateTicks(aggregationInterval, true, minVisible, maxVisible, null === (_that$_seriesData = this._seriesData) || void 0 === _that$_seriesData ? void 0 : _that$_seriesData.breaks).tickInterval;\n\n    if (options.type !== constants.discrete) {\n      var min = useAllAggregatedPoints ? businessRange.min : minVisible;\n      var max = useAllAggregatedPoints ? businessRange.max : maxVisible;\n\n      if (isDefined(min) && isDefined(max)) {\n        var add = getAddFunction({\n          base: options.logarithmBase,\n          axisType: options.type,\n          dataType: options.dataType\n        }, false);\n        var start = min;\n        var end = max;\n\n        if (!useAllAggregatedPoints) {\n          var maxMinDistance = Math.max(this.calculateInterval(max, min), \"datetime\" === options.dataType ? dateUtils.dateToMilliseconds(tickInterval) : tickInterval);\n          start = add(min, maxMinDistance, -1);\n          end = add(max, maxMinDistance);\n        }\n\n        start = start < businessRange.min ? businessRange.min : start;\n        end = end > businessRange.max ? businessRange.max : end;\n\n        var breaks = this._getScaleBreaks(options, {\n          minVisible: start,\n          maxVisible: end\n        }, this._series, this.isArgumentAxis);\n\n        var filteredBreaks = this._filterBreaks(breaks, {\n          minVisible: start,\n          maxVisible: end\n        }, options.breakStyle);\n\n        ticks = generateTicks(tickInterval, false, start, end, filteredBreaks).ticks;\n      }\n    }\n\n    this._aggregationInterval = tickInterval;\n    return {\n      interval: tickInterval,\n      ticks: ticks\n    };\n  },\n\n  getTickInterval() {\n    return this._tickInterval;\n  },\n\n  getAggregationInterval() {\n    return this._aggregationInterval;\n  },\n\n  createTicks: function (canvas) {\n    var that = this;\n    var renderer = that._renderer;\n    var options = that._options;\n\n    if (!canvas) {\n      return;\n    }\n\n    that._isSynchronized = false;\n    that.updateCanvas(canvas);\n\n    var range = that._getViewportRange();\n\n    that._initialBreaks = range.breaks = this._seriesData.breaks = that._filterBreaks(this._seriesData.userBreaks, range, options.breakStyle);\n    that._estimatedTickInterval = that._getTicks(that.adjustViewport(this._seriesData), _noop, true).tickInterval;\n\n    var margins = this._calculateValueMargins();\n\n    range.addRange({\n      minVisible: margins.minValue,\n      maxVisible: margins.maxValue,\n      isSpacedMargin: margins.isSpacedMargin\n    });\n\n    var ticks = that._createTicksAndLabelFormat(range);\n\n    var boundaryTicks = that._getBoundaryTicks(ticks.ticks, that._getViewportRange());\n\n    if (options.showCustomBoundaryTicks && boundaryTicks.length) {\n      that._boundaryTicks = [boundaryTicks[0]].map(createBoundaryTick(that, renderer, true));\n\n      if (boundaryTicks.length > 1) {\n        that._boundaryTicks = that._boundaryTicks.concat([boundaryTicks[1]].map(createBoundaryTick(that, renderer, false)));\n      }\n    } else {\n      that._boundaryTicks = [];\n    }\n\n    var minors = (ticks.minorTicks || []).filter(function (minor) {\n      return !boundaryTicks.some(function (boundary) {\n        return valueOf(boundary) === valueOf(minor);\n      });\n    });\n    that._tickInterval = ticks.tickInterval;\n    that._minorTickInterval = ticks.minorTickInterval;\n    var oldMajorTicks = that._majorTicks || [];\n    var majorTicksByValues = oldMajorTicks.reduce((r, t) => {\n      r[t.value.valueOf()] = t;\n      return r;\n    }, {});\n    var sameType = type(ticks.ticks[0]) === type(oldMajorTicks[0] && oldMajorTicks[0].value);\n\n    var skippedCategory = that._getSkippedCategory(ticks.ticks);\n\n    var majorTicks = ticks.ticks.map(v => {\n      var tick = majorTicksByValues[v.valueOf()];\n\n      if (tick && sameType) {\n        delete majorTicksByValues[v.valueOf()];\n        tick.setSkippedCategory(skippedCategory);\n        return tick;\n      } else {\n        return createMajorTick(that, renderer, skippedCategory)(v);\n      }\n    });\n    that._majorTicks = majorTicks;\n    var oldMinorTicks = that._minorTicks || [];\n    that._minorTicks = minors.map((v, i) => {\n      var minorTick = oldMinorTicks[i];\n\n      if (minorTick) {\n        minorTick.updateValue(v);\n        return minorTick;\n      }\n\n      return createMinorTick(that, renderer)(v);\n    });\n    that._ticksToRemove = Object.keys(majorTicksByValues).map(k => majorTicksByValues[k]).concat(oldMinorTicks.slice(that._minorTicks.length, oldMinorTicks.length));\n\n    that._ticksToRemove.forEach(t => {\n      var _t$label;\n\n      return null === (_t$label = t.label) || void 0 === _t$label ? void 0 : _t$label.removeTitle();\n    });\n\n    if (ticks.breaks) {\n      that._seriesData.breaks = ticks.breaks;\n    }\n\n    that._reinitTranslator(that._getViewportRange());\n  },\n  _reinitTranslator: function (range) {\n    var translator = this._translator;\n\n    if (this._isSynchronized) {\n      return;\n    }\n\n    translator.updateBusinessRange(range);\n  },\n\n  _getViewportRange() {\n    return this.adjustViewport(this._seriesData);\n  },\n\n  setMarginOptions: function (options) {\n    this._marginOptions = options;\n  },\n\n  getMarginOptions() {\n    var _this$_marginOptions;\n\n    return null !== (_this$_marginOptions = this._marginOptions) && void 0 !== _this$_marginOptions ? _this$_marginOptions : {};\n  },\n\n  _calculateRangeInterval: function (interval) {\n    var isDateTime = \"datetime\" === this._options.dataType;\n    var minArgs = [];\n\n    var addToArgs = function (value) {\n      isDefined(value) && minArgs.push(isDateTime ? dateUtils.dateToMilliseconds(value) : value);\n    };\n\n    addToArgs(this._tickInterval);\n    addToArgs(this._estimatedTickInterval);\n    isDefined(interval) && minArgs.push(interval);\n    addToArgs(this._aggregationInterval);\n    return this._calculateWorkWeekInterval(_min.apply(this, minArgs));\n  },\n\n  _calculateWorkWeekInterval(businessInterval) {\n    var options = this._options;\n\n    if (\"datetime\" === options.dataType && options.workdaysOnly && businessInterval) {\n      var workWeek = options.workWeek.length * dateIntervals.day;\n      var weekend = dateIntervals.week - workWeek;\n\n      if (workWeek !== businessInterval && weekend < businessInterval) {\n        var weekendsCount = Math.ceil(businessInterval / dateIntervals.week);\n        businessInterval -= weekend * weekendsCount;\n      } else if (weekend >= businessInterval && businessInterval > dateIntervals.day) {\n        businessInterval = dateIntervals.day;\n      }\n    }\n\n    return businessInterval;\n  },\n\n  _getConvertIntervalCoefficient(intervalInPx, screenDelta) {\n    var ratioOfCanvasRange = this._translator.ratioOfCanvasRange();\n\n    return ratioOfCanvasRange / (ratioOfCanvasRange * screenDelta / (intervalInPx + screenDelta));\n  },\n\n  _calculateValueMargins(ticks) {\n    this._resetMargins();\n\n    var margins = this.getMarginOptions();\n    var marginSize = (margins.size || 0) / 2;\n    var options = this._options;\n\n    var dataRange = this._getViewportRange();\n\n    var viewPort = this.getViewport();\n\n    var screenDelta = this._getScreenDelta();\n\n    var isDiscrete = -1 !== (options.type || \"\").indexOf(constants.discrete);\n    var valueMarginsEnabled = options.valueMarginsEnabled && !isDiscrete && !this.customPositionIsBoundaryOrthogonalAxis();\n    var translator = this._translator;\n    var minValueMargin = options.minValueMargin;\n    var maxValueMargin = options.maxValueMargin;\n    var minPadding = 0;\n    var maxPadding = 0;\n    var interval = 0;\n    var rangeInterval;\n\n    if (dataRange.stubData || !screenDelta) {\n      return {\n        startPadding: 0,\n        endPadding: 0\n      };\n    }\n\n    if (this.isArgumentAxis && margins.checkInterval) {\n      rangeInterval = this._calculateRangeInterval(dataRange.interval);\n      var pxInterval = translator.getInterval(rangeInterval);\n\n      if (isFinite(pxInterval)) {\n        interval = Math.ceil(pxInterval / (2 * this._getConvertIntervalCoefficient(pxInterval, screenDelta)));\n      } else {\n        rangeInterval = 0;\n      }\n    }\n\n    var minPercentPadding;\n    var maxPercentPadding;\n    var maxPaddingValue = screenDelta * MAX_MARGIN_VALUE / 2;\n\n    if (valueMarginsEnabled) {\n      if (isDefined(minValueMargin)) {\n        minPercentPadding = isFinite(minValueMargin) ? minValueMargin : 0;\n      } else if (!this.isArgumentAxis && margins.checkInterval && valueOf(dataRange.minVisible) > 0 && valueOf(dataRange.minVisible) === valueOf(dataRange.min)) {\n        minPadding = MIN_BAR_MARGIN;\n      } else {\n        minPadding = Math.max(marginSize, interval);\n        minPadding = Math.min(maxPaddingValue, minPadding);\n      }\n\n      if (isDefined(maxValueMargin)) {\n        maxPercentPadding = isFinite(maxValueMargin) ? maxValueMargin : 0;\n      } else if (!this.isArgumentAxis && margins.checkInterval && valueOf(dataRange.maxVisible) < 0 && valueOf(dataRange.maxVisible) === valueOf(dataRange.max)) {\n        maxPadding = MIN_BAR_MARGIN;\n      } else {\n        maxPadding = Math.max(marginSize, interval);\n        maxPadding = Math.min(maxPaddingValue, maxPadding);\n      }\n    }\n\n    var percentStick = margins.percentStick && !this.isArgumentAxis;\n\n    if (percentStick) {\n      if (1 === _abs(dataRange.max)) {\n        maxPadding = 0;\n      }\n\n      if (1 === _abs(dataRange.min)) {\n        minPadding = 0;\n      }\n    }\n\n    var canvasStartEnd = this._getCanvasStartEnd();\n\n    var commonMargin = 1 + (minPercentPadding || 0) + (maxPercentPadding || 0);\n    var screenDeltaWithMargins = (screenDelta - minPadding - maxPadding) / commonMargin || screenDelta;\n\n    if (void 0 !== minPercentPadding || void 0 !== maxPercentPadding) {\n      if (void 0 !== minPercentPadding) {\n        minPadding = screenDeltaWithMargins * minPercentPadding;\n      }\n\n      if (void 0 !== maxPercentPadding) {\n        maxPadding = screenDeltaWithMargins * maxPercentPadding;\n      }\n    }\n\n    var minValue;\n    var maxValue;\n\n    if (options.type !== constants.discrete && ticks && ticks.length > 1 && !options.skipViewportExtending && !viewPort.action && false !== options.endOnTick) {\n      var length = ticks.length;\n      var firstTickPosition = translator.translate(ticks[0].value);\n      var lastTickPosition = translator.translate(ticks[length - 1].value);\n      var invertMultiplier = firstTickPosition > lastTickPosition ? -1 : 1;\n\n      var minTickPadding = _max(invertMultiplier * (canvasStartEnd.start - firstTickPosition), 0);\n\n      var maxTickPadding = _max(invertMultiplier * (lastTickPosition - canvasStartEnd.end), 0);\n\n      if (minTickPadding > minPadding || maxTickPadding > maxPadding) {\n        var commonPadding = maxTickPadding + minTickPadding;\n\n        var coeff = this._getConvertIntervalCoefficient(commonPadding, screenDelta);\n\n        if (minTickPadding >= minPadding) {\n          minValue = ticks[0].value;\n        }\n\n        if (maxTickPadding >= maxPadding) {\n          maxValue = ticks[length - 1].value;\n        }\n\n        minPadding = _max(minTickPadding, minPadding) / coeff;\n        maxPadding = _max(maxTickPadding, maxPadding) / coeff;\n      }\n    }\n\n    minPercentPadding = void 0 === minPercentPadding ? minPadding / screenDeltaWithMargins : minPercentPadding;\n    maxPercentPadding = void 0 === maxPercentPadding ? maxPadding / screenDeltaWithMargins : maxPercentPadding;\n\n    if (!isDiscrete) {\n      if (this._translator.isInverted()) {\n        var _minValue, _maxValue;\n\n        minValue = null !== (_minValue = minValue) && void 0 !== _minValue ? _minValue : translator.from(canvasStartEnd.start + screenDelta * minPercentPadding, -1);\n        maxValue = null !== (_maxValue = maxValue) && void 0 !== _maxValue ? _maxValue : translator.from(canvasStartEnd.end - screenDelta * maxPercentPadding, 1);\n      } else {\n        var _minValue2, _maxValue2;\n\n        minValue = null !== (_minValue2 = minValue) && void 0 !== _minValue2 ? _minValue2 : translator.from(canvasStartEnd.start - screenDelta * minPercentPadding, -1);\n        maxValue = null !== (_maxValue2 = maxValue) && void 0 !== _maxValue2 ? _maxValue2 : translator.from(canvasStartEnd.end + screenDelta * maxPercentPadding, 1);\n      }\n    }\n\n    var {\n      correctedMin: correctedMin,\n      correctedMax: correctedMax,\n      start: start,\n      end: end\n    } = this.getCorrectedValuesToZero(minValue, maxValue);\n    minPadding = null !== start && void 0 !== start ? start : minPadding;\n    maxPadding = null !== end && void 0 !== end ? end : maxPadding;\n    return {\n      startPadding: translator.isInverted() ? maxPadding : minPadding,\n      endPadding: translator.isInverted() ? minPadding : maxPadding,\n      minValue: null !== correctedMin && void 0 !== correctedMin ? correctedMin : minValue,\n      maxValue: null !== correctedMax && void 0 !== correctedMax ? correctedMax : maxValue,\n      interval: rangeInterval,\n      isSpacedMargin: minPadding === maxPadding && 0 !== minPadding\n    };\n  },\n\n  getCorrectedValuesToZero(minValue, maxValue) {\n    var that = this;\n    var translator = that._translator;\n\n    var canvasStartEnd = that._getCanvasStartEnd();\n\n    var dataRange = that._getViewportRange();\n\n    var screenDelta = that._getScreenDelta();\n\n    var options = that._options;\n    var start;\n    var end;\n    var correctedMin;\n    var correctedMax;\n\n    var correctZeroLevel = (minPoint, maxPoint) => {\n      var minExpectedPadding = _abs(canvasStartEnd.start - minPoint);\n\n      var maxExpectedPadding = _abs(canvasStartEnd.end - maxPoint);\n\n      var coeff = that._getConvertIntervalCoefficient(minExpectedPadding + maxExpectedPadding, screenDelta);\n\n      start = minExpectedPadding / coeff;\n      end = maxExpectedPadding / coeff;\n    };\n\n    if (!that.isArgumentAxis && \"datetime\" !== options.dataType) {\n      if (minValue * dataRange.min <= 0 && minValue * dataRange.minVisible <= 0) {\n        correctZeroLevel(translator.translate(0), translator.translate(maxValue));\n        correctedMin = 0;\n      }\n\n      if (maxValue * dataRange.max <= 0 && maxValue * dataRange.maxVisible <= 0) {\n        correctZeroLevel(translator.translate(minValue), translator.translate(0));\n        correctedMax = 0;\n      }\n    }\n\n    return {\n      start: isFinite(start) ? start : null,\n      end: isFinite(end) ? end : null,\n      correctedMin: correctedMin,\n      correctedMax: correctedMax\n    };\n  },\n\n  applyMargins() {\n    if (this._isSynchronized) {\n      return;\n    }\n\n    var margins = this._calculateValueMargins(this._majorTicks);\n\n    var canvas = extend({}, this._canvas, {\n      startPadding: margins.startPadding,\n      endPadding: margins.endPadding\n    });\n\n    this._translator.updateCanvas(this._processCanvas(canvas));\n\n    if (isFinite(margins.interval)) {\n      var br = this._translator.getBusinessRange();\n\n      br.addRange({\n        interval: margins.interval\n      });\n\n      this._translator.updateBusinessRange(br);\n    }\n  },\n\n  _resetMargins: function () {\n    this._reinitTranslator(this._getViewportRange());\n\n    if (this._canvas) {\n      this._translator.updateCanvas(this._processCanvas(this._canvas));\n    }\n  },\n\n  _createConstantLines() {\n    var constantLines = (this._options.constantLines || []).map(o => createConstantLine(this, o));\n    this._outsideConstantLines = constantLines.filter(l => \"outside\" === l.labelPosition);\n    this._insideConstantLines = constantLines.filter(l => \"inside\" === l.labelPosition);\n  },\n\n  draw: function (canvas, borderOptions) {\n    var that = this;\n    var options = this._options;\n    that.borderOptions = borderOptions || {\n      visible: false\n    };\n\n    that._resetMargins();\n\n    that.createTicks(canvas);\n    that.applyMargins();\n\n    that._clearAxisGroups();\n\n    initTickCoords(that._majorTicks);\n    initTickCoords(that._minorTicks);\n    initTickCoords(that._boundaryTicks);\n\n    that._axisGroup.append(that._axesContainerGroup);\n\n    that._drawAxis();\n\n    that._drawTitle();\n\n    drawTickMarks(that._majorTicks, options.tick);\n    drawTickMarks(that._minorTicks, options.minorTick);\n    drawTickMarks(that._boundaryTicks, options.tick);\n\n    var drawGridLine = that._getGridLineDrawer();\n\n    drawGrids(that._majorTicks, drawGridLine);\n    drawGrids(that._minorTicks, drawGridLine);\n    callAction(that._majorTicks, \"drawLabel\", that._getViewportRange(), that._getTemplate(options.label.template));\n    that._templatesRendered && that._templatesRendered.reject();\n    that._templatesRendered = new Deferred();\n\n    that._majorTicks.forEach(function (tick) {\n      tick.labelRotationAngle = 0;\n      tick.labelAlignment = void 0;\n      tick.labelOffset = 0;\n    });\n\n    callAction(that._outsideConstantLines.concat(that._insideConstantLines), \"draw\");\n    callAction(that._strips, \"draw\");\n    that._dateMarkers = that._drawDateMarkers() || [];\n    that._stripLabelAxesGroup && that._axisStripLabelGroup.append(that._stripLabelAxesGroup);\n    that._gridContainerGroup && that._axisGridGroup.append(that._gridContainerGroup);\n    that._stripsGroup && that._axisStripGroup.append(that._stripsGroup);\n    that._labelsAxesGroup && that._axisElementsGroup.append(that._labelsAxesGroup);\n\n    if (that._constantLinesGroup) {\n      that._axisConstantLineGroups.above.inside.append(that._constantLinesGroup.above);\n\n      that._axisConstantLineGroups.above.outside1.append(that._constantLinesGroup.above);\n\n      that._axisConstantLineGroups.above.outside2.append(that._constantLinesGroup.above);\n\n      that._axisConstantLineGroups.under.inside.append(that._constantLinesGroup.under);\n\n      that._axisConstantLineGroups.under.outside1.append(that._constantLinesGroup.under);\n\n      that._axisConstantLineGroups.under.outside2.append(that._constantLinesGroup.under);\n    }\n\n    that._measureTitle();\n\n    measureLabels(that._majorTicks);\n    !options.label.template && that._applyWordWrap();\n    measureLabels(that._outsideConstantLines);\n    measureLabels(that._insideConstantLines);\n    measureLabels(that._strips);\n    measureLabels(that._dateMarkers);\n\n    that._adjustConstantLineLabels(that._insideConstantLines);\n\n    that._adjustStripLabels();\n\n    var offset = that._constantLabelOffset = that._adjustConstantLineLabels(that._outsideConstantLines);\n\n    if (!that._translator.getBusinessRange().isEmpty()) {\n      that._setLabelsPlacement();\n\n      offset = that._adjustLabels(offset);\n    }\n\n    when.apply(this, that._majorTicks.map(tick => tick.getTemplateDeferred())).done(() => {\n      that._templatesRendered.resolve();\n    });\n    offset = that._adjustDateMarkers(offset);\n\n    that._adjustTitle(offset);\n  },\n\n  getTemplatesDef() {\n    return this._templatesRendered;\n  },\n\n  setRenderedState(state) {\n    this._drawn = state;\n  },\n\n  isRendered() {\n    return this._drawn;\n  },\n\n  _applyWordWrap() {\n    var convertedTickInterval;\n    var textWidth;\n    var textHeight;\n    var options = this._options;\n    var tickInterval = this._tickInterval;\n\n    if (isDefined(tickInterval)) {\n      convertedTickInterval = this.getTranslator().getInterval(\"datetime\" === options.dataType ? dateUtils.dateToMilliseconds(tickInterval) : tickInterval);\n    }\n\n    var displayMode = this._validateDisplayMode(options.label.displayMode);\n\n    var overlappingMode = this._validateOverlappingMode(options.label.overlappingBehavior, displayMode);\n\n    var wordWrapMode = options.label.wordWrap || \"none\";\n    var overflowMode = options.label.textOverflow || \"none\";\n\n    if ((\"none\" !== wordWrapMode || \"none\" !== overflowMode) && displayMode !== ROTATE && overlappingMode !== ROTATE && \"auto\" !== overlappingMode) {\n      var usefulSpace = isDefined(options.placeholderSize) ? options.placeholderSize - options.label.indentFromAxis : void 0;\n\n      if (this._isHorizontal) {\n        textWidth = convertedTickInterval;\n        textHeight = usefulSpace;\n      } else {\n        textWidth = usefulSpace;\n        textHeight = convertedTickInterval;\n      }\n\n      var correctByWidth = false;\n      var correctByHeight = false;\n\n      if (textWidth) {\n        if (this._majorTicks.some(tick => tick.labelBBox.width > textWidth)) {\n          correctByWidth = true;\n        }\n      }\n\n      if (textHeight) {\n        if (this._majorTicks.some(tick => tick.labelBBox.height > textHeight)) {\n          correctByHeight = true;\n        }\n      }\n\n      if (correctByWidth || correctByHeight) {\n        this._majorTicks.forEach(tick => {\n          tick.label && tick.label.setMaxSize(textWidth, textHeight, options.label);\n        });\n\n        measureLabels(this._majorTicks);\n      }\n    }\n  },\n\n  _measureTitle: _noop,\n\n  animate() {\n    callAction(this._majorTicks, \"animateLabels\");\n  },\n\n  updateSize(canvas, animate) {\n    var updateTitle = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : true;\n    this.updateCanvas(canvas);\n\n    if (updateTitle) {\n      this._checkTitleOverflow();\n\n      this._measureTitle();\n\n      this._updateTitleCoords();\n    }\n\n    this._reinitTranslator(this._getViewportRange());\n\n    this.applyMargins();\n    var animationEnabled = !this._firstDrawing && animate;\n    var options = this._options;\n    initTickCoords(this._majorTicks);\n    initTickCoords(this._minorTicks);\n    initTickCoords(this._boundaryTicks);\n\n    if (this._resetApplyingAnimation && !this._firstDrawing) {\n      this._resetStartCoordinates();\n    }\n\n    cleanUpInvalidTicks(this._majorTicks);\n    cleanUpInvalidTicks(this._minorTicks);\n    cleanUpInvalidTicks(this._boundaryTicks);\n\n    if (this._axisElement) {\n      this._updateAxisElementPosition();\n    }\n\n    updateTicksPosition(this._majorTicks, options.tick, animationEnabled);\n    updateTicksPosition(this._minorTicks, options.minorTick, animationEnabled);\n    updateTicksPosition(this._boundaryTicks, options.tick);\n    callAction(this._majorTicks, \"updateLabelPosition\", animationEnabled);\n\n    this._outsideConstantLines.concat(this._insideConstantLines || []).forEach(l => l.updatePosition(animationEnabled));\n\n    callAction(this._strips, \"updatePosition\", animationEnabled);\n    updateGridsPosition(this._majorTicks, animationEnabled);\n    updateGridsPosition(this._minorTicks, animationEnabled);\n\n    if (animationEnabled) {\n      callAction(this._ticksToRemove || [], \"fadeOutElements\");\n    }\n\n    this.prepareAnimation();\n    this._ticksToRemove = null;\n\n    if (!this._translator.getBusinessRange().isEmpty()) {\n      this._firstDrawing = false;\n    }\n\n    this._resetApplyingAnimation = false;\n\n    this._updateLabelsPosition();\n  },\n\n  _updateLabelsPosition: _noop,\n\n  prepareAnimation() {\n    var action = \"saveCoords\";\n    callAction(this._majorTicks, action);\n    callAction(this._minorTicks, action);\n    callAction(this._insideConstantLines, action);\n    callAction(this._outsideConstantLines, action);\n    callAction(this._strips, action);\n  },\n\n  _resetStartCoordinates() {\n    var action = \"resetCoordinates\";\n    callAction(this._majorTicks, action);\n    callAction(this._minorTicks, action);\n    callAction(this._insideConstantLines, action);\n    callAction(this._outsideConstantLines, action);\n    callAction(this._strips, action);\n  },\n\n  applyClipRects: function (elementsClipID, canvasClipID) {\n    this._axisGroup.attr({\n      \"clip-path\": canvasClipID\n    });\n\n    this._axisStripGroup.attr({\n      \"clip-path\": elementsClipID\n    });\n\n    this._axisElementsGroup.attr({\n      \"clip-path\": canvasClipID\n    });\n  },\n\n  _validateVisualRange(optionValue) {\n    var range = getVizRangeObject(optionValue);\n\n    if (void 0 !== range.startValue) {\n      range.startValue = this.validateUnit(range.startValue);\n    }\n\n    if (void 0 !== range.endValue) {\n      range.endValue = this.validateUnit(range.endValue);\n    }\n\n    return convertVisualRangeObject(range, !_isArray(optionValue));\n  },\n\n  _validateOptions(options) {\n    options.wholeRange = this._validateVisualRange(options.wholeRange);\n    options.visualRange = options._customVisualRange = this._validateVisualRange(options._customVisualRange);\n\n    this._setVisualRange(options._customVisualRange);\n  },\n\n  validate() {\n    var options = this._options;\n    var dataType = this.isArgumentAxis ? options.argumentType : options.valueType;\n    var parser = dataType ? getParser(dataType) : function (unit) {\n      return unit;\n    };\n    this.parser = parser;\n    options.dataType = dataType;\n\n    this._validateOptions(options);\n  },\n\n  resetVisualRange(isSilent) {\n    this._seriesData.minVisible = this._seriesData.min;\n    this._seriesData.maxVisible = this._seriesData.max;\n    this.handleZooming([null, null], {\n      start: !!isSilent,\n      end: !!isSilent\n    });\n  },\n\n  _setVisualRange(visualRange, allowPartialUpdate) {\n    var range = this.adjustRange(getVizRangeObject(visualRange));\n\n    if (allowPartialUpdate) {\n      isDefined(range.startValue) && (this._viewport.startValue = range.startValue);\n      isDefined(range.endValue) && (this._viewport.endValue = range.endValue);\n    } else {\n      this._viewport = range;\n    }\n  },\n\n  _applyZooming(visualRange, allowPartialUpdate) {\n    this._resetVisualRangeOption();\n\n    this._setVisualRange(visualRange, allowPartialUpdate);\n\n    var viewPort = this.getViewport();\n    this._seriesData.userBreaks = this._getScaleBreaks(this._options, {\n      minVisible: viewPort.startValue,\n      maxVisible: viewPort.endValue\n    }, this._series, this.isArgumentAxis);\n\n    this._translator.updateBusinessRange(this._getViewportRange());\n  },\n\n  getZoomStartEventArg(event, actionType) {\n    return {\n      axis: this,\n      range: this.visualRange(),\n      cancel: false,\n      event: event,\n      actionType: actionType\n    };\n  },\n\n  _getZoomEndEventArg(previousRange, event, actionType, zoomFactor, shift) {\n    var newRange = this.visualRange();\n    return {\n      axis: this,\n      previousRange: previousRange,\n      range: newRange,\n      cancel: false,\n      event: event,\n      actionType: actionType,\n      zoomFactor: zoomFactor,\n      shift: shift,\n      rangeStart: newRange.startValue,\n      rangeEnd: newRange.endValue\n    };\n  },\n\n  getZoomBounds() {\n    var wholeRange = getVizRangeObject(this._options.wholeRange);\n    var range = this.getTranslator().getBusinessRange();\n    var secondPriorityRange = {\n      startValue: getZoomBoundValue(this._initRange.startValue, range.min),\n      endValue: getZoomBoundValue(this._initRange.endValue, range.max)\n    };\n    return {\n      startValue: getZoomBoundValue(wholeRange.startValue, secondPriorityRange.startValue),\n      endValue: getZoomBoundValue(wholeRange.endValue, secondPriorityRange.endValue)\n    };\n  },\n\n  setInitRange() {\n    this._initRange = {};\n\n    if (0 === Object.keys(this._options.wholeRange || {}).length) {\n      this._initRange = this.getZoomBounds();\n    }\n  },\n\n  _resetVisualRangeOption() {\n    this._options._customVisualRange = {};\n  },\n\n  getTemplatesGroups() {\n    var ticks = this._majorTicks;\n\n    if (ticks) {\n      return this._majorTicks.map(tick => tick.templateContainer).filter(item => isDefined(item));\n    } else {\n      return [];\n    }\n  },\n\n  setCustomVisualRange(range) {\n    this._options._customVisualRange = range;\n  },\n\n  visualRange() {\n    var args = arguments;\n    var visualRange;\n\n    if (0 === args.length) {\n      var adjustedRange = this._getAdjustedBusinessRange();\n\n      var startValue = adjustedRange.minVisible;\n      var endValue = adjustedRange.maxVisible;\n\n      if (this._options.type === constants.discrete) {\n        var _startValue, _endValue;\n\n        startValue = null !== (_startValue = startValue) && void 0 !== _startValue ? _startValue : adjustedRange.categories[0];\n        endValue = null !== (_endValue = endValue) && void 0 !== _endValue ? _endValue : adjustedRange.categories[adjustedRange.categories.length - 1];\n        return {\n          startValue: startValue,\n          endValue: endValue,\n          categories: getCategoriesInfo(adjustedRange.categories, startValue, endValue).categories\n        };\n      }\n\n      return {\n        startValue: startValue,\n        endValue: endValue\n      };\n    } else if (_isArray(args[0])) {\n      visualRange = args[0];\n    } else if (isPlainObject(args[0])) {\n      visualRange = extend({}, args[0]);\n    } else {\n      visualRange = [args[0], args[1]];\n    }\n\n    var zoomResults = this.handleZooming(visualRange, args[1]);\n\n    if (!zoomResults.isPrevented) {\n      this._visualRange(this, zoomResults);\n    }\n  },\n\n  handleZooming(visualRange, preventEvents, domEvent, action) {\n    preventEvents = preventEvents || {};\n\n    if (isDefined(visualRange)) {\n      visualRange = this._validateVisualRange(visualRange);\n      visualRange.action = action;\n    }\n\n    var zoomStartEvent = this.getZoomStartEventArg(domEvent, action);\n    var previousRange = zoomStartEvent.range;\n    !preventEvents.start && this._eventTrigger(\"zoomStart\", zoomStartEvent);\n    var zoomResults = {\n      isPrevented: zoomStartEvent.cancel,\n      skipEventRising: preventEvents.skipEventRising,\n      range: visualRange || zoomStartEvent.range\n    };\n\n    if (!zoomStartEvent.cancel) {\n      isDefined(visualRange) && this._applyZooming(visualRange, preventEvents.allowPartialUpdate);\n\n      if (!isDefined(this._storedZoomEndParams)) {\n        this._storedZoomEndParams = {\n          startRange: previousRange,\n          type: this.getOptions().type\n        };\n      }\n\n      this._storedZoomEndParams.event = domEvent;\n      this._storedZoomEndParams.action = action;\n      this._storedZoomEndParams.prevent = !!preventEvents.end;\n    }\n\n    return zoomResults;\n  },\n\n  handleZoomEnd() {\n    if (isDefined(this._storedZoomEndParams) && !this._storedZoomEndParams.prevent) {\n      var previousRange = this._storedZoomEndParams.startRange;\n      var domEvent = this._storedZoomEndParams.event;\n      var action = this._storedZoomEndParams.action;\n      var previousBusinessRange = {\n        minVisible: previousRange.startValue,\n        maxVisible: previousRange.endValue,\n        categories: previousRange.categories\n      };\n\n      var typeIsNotChanged = this.getOptions().type === this._storedZoomEndParams.type;\n\n      var shift = typeIsNotChanged ? adjust(this.getVisualRangeCenter() - this.getVisualRangeCenter(previousBusinessRange, false)) : NaN;\n      var zoomFactor = typeIsNotChanged ? +(Math.round(this.getVisualRangeLength(previousBusinessRange) / (this.getVisualRangeLength() || 1) + \"e+2\") + \"e-2\") : NaN;\n\n      var zoomEndEvent = this._getZoomEndEventArg(previousRange, domEvent, action, zoomFactor, shift);\n\n      zoomEndEvent.cancel = this.checkZoomingLowerLimitOvercome(1 === zoomFactor ? \"pan\" : \"zoom\", zoomFactor).stopInteraction;\n\n      this._eventTrigger(\"zoomEnd\", zoomEndEvent);\n\n      if (zoomEndEvent.cancel) {\n        this._restorePreviousVisualRange(previousRange);\n      }\n\n      this._storedZoomEndParams = null;\n    }\n  },\n\n  _restorePreviousVisualRange(previousRange) {\n    this._storedZoomEndParams = null;\n\n    this._applyZooming(previousRange);\n\n    this._visualRange(this, previousRange);\n  },\n\n  checkZoomingLowerLimitOvercome(actionType, zoomFactor, range) {\n    var options = this._options;\n    var translator = this._translator;\n    var minZoom = options.minVisualRangeLength;\n    var correctedRange = range;\n    var visualRange;\n    var isOvercoming = \"zoom\" === actionType && zoomFactor >= 1;\n    var businessRange = translator.getBusinessRange();\n\n    if (range) {\n      visualRange = this.adjustRange(getVizRangeObject(range));\n      visualRange = {\n        minVisible: visualRange.startValue,\n        maxVisible: visualRange.endValue,\n        categories: businessRange.categories\n      };\n    }\n\n    var beforeVisualRangeLength = this.getVisualRangeLength(businessRange);\n    var afterVisualRangeLength = this.getVisualRangeLength(visualRange);\n\n    if (isDefined(minZoom) || \"discrete\" === options.type) {\n      minZoom = translator.convert(minZoom);\n\n      if (visualRange && minZoom < beforeVisualRangeLength && minZoom >= afterVisualRangeLength) {\n        correctedRange = getVizRangeObject(translator.getRangeByMinZoomValue(minZoom, visualRange));\n        isOvercoming = false;\n      } else {\n        isOvercoming &= minZoom > afterVisualRangeLength;\n      }\n    } else {\n      var canvasLength = this._translator.canvasLength;\n      var fullRange = {\n        minVisible: businessRange.min,\n        maxVisible: businessRange.max,\n        categories: businessRange.categories\n      };\n      isOvercoming &= this.getVisualRangeLength(fullRange) / canvasLength >= afterVisualRangeLength;\n    }\n\n    return {\n      stopInteraction: !!isOvercoming,\n      correctedRange: correctedRange\n    };\n  },\n\n  isExtremePosition(isMax) {\n    var extremeDataValue;\n    var seriesData;\n\n    if (\"discrete\" === this._options.type) {\n      seriesData = this._translator.getBusinessRange();\n      extremeDataValue = isMax ? seriesData.categories[seriesData.categories.length - 1] : seriesData.categories[0];\n    } else {\n      seriesData = this.getZoomBounds();\n      extremeDataValue = isMax ? seriesData.endValue : seriesData.startValue;\n    }\n\n    var translator = this.getTranslator();\n    var extremePoint = translator.translate(extremeDataValue);\n    var visualRange = this.visualRange();\n    var visualRangePoint = isMax ? translator.translate(visualRange.endValue) : translator.translate(visualRange.startValue);\n    return _abs(visualRangePoint - extremePoint) < SCROLL_THRESHOLD;\n  },\n\n  getViewport() {\n    return this._viewport;\n  },\n\n  getFullTicks: function () {\n    var majors = this._majorTicks || [];\n\n    if (this._options.type === constants.discrete) {\n      return convertTicksToValues(majors);\n    } else {\n      return convertTicksToValues(majors.concat(this._minorTicks, this._boundaryTicks)).sort(function (a, b) {\n        return valueOf(a) - valueOf(b);\n      });\n    }\n  },\n  measureLabels: function (canvas, withIndents) {\n    var that = this;\n    var options = that._options;\n    var widthAxis = options.visible ? options.width : 0;\n    var ticks;\n    var indent = withIndents ? options.label.indentFromAxis + .5 * options.tick.length : 0;\n    var tickInterval;\n\n    var viewportRange = that._getViewportRange();\n\n    if (viewportRange.isEmpty() || !options.label.visible || !that._axisElementsGroup) {\n      return {\n        height: widthAxis,\n        width: widthAxis,\n        x: 0,\n        y: 0\n      };\n    }\n\n    if (that._majorTicks) {\n      ticks = convertTicksToValues(that._majorTicks);\n    } else {\n      that.updateCanvas(canvas);\n      ticks = that._createTicksAndLabelFormat(viewportRange, _noop);\n      tickInterval = ticks.tickInterval;\n      ticks = ticks.ticks;\n    }\n\n    var maxText = ticks.reduce(function (prevLabel, tick, index) {\n      var label = that.formatLabel(tick, options.label, viewportRange, void 0, tickInterval, ticks);\n\n      if (prevLabel.length < label.length) {\n        return label;\n      } else {\n        return prevLabel;\n      }\n    }, that.formatLabel(ticks[0], options.label, viewportRange, void 0, tickInterval, ticks));\n\n    var text = that._renderer.text(maxText, 0, 0).css(that._textFontStyles).attr(that._textOptions).append(that._renderer.root);\n\n    var box = text.getBBox();\n    text.remove();\n    return {\n      x: box.x,\n      y: box.y,\n      width: box.width + indent,\n      height: box.height + indent\n    };\n  },\n  _setLabelsPlacement: function () {\n    if (!this._options.label.visible) {\n      return;\n    }\n\n    var labelOpt = this._options.label;\n\n    var displayMode = this._validateDisplayMode(labelOpt.displayMode);\n\n    var overlappingMode = this._validateOverlappingMode(labelOpt.overlappingBehavior, displayMode);\n\n    var ignoreOverlapping = \"none\" === overlappingMode || \"ignore\" === overlappingMode;\n    var behavior = {\n      rotationAngle: labelOpt.rotationAngle,\n      staggeringSpacing: labelOpt.staggeringSpacing\n    };\n    var notRecastStep;\n\n    var boxes = this._majorTicks.map(function (tick) {\n      return tick.labelBBox;\n    });\n\n    var step = this._getStep(boxes);\n\n    switch (displayMode) {\n      case ROTATE:\n        if (ignoreOverlapping) {\n          notRecastStep = true;\n          step = 1;\n        }\n\n        this._applyLabelMode(displayMode, step, boxes, labelOpt, notRecastStep);\n\n        break;\n\n      case \"stagger\":\n        if (ignoreOverlapping) {\n          step = 2;\n        }\n\n        this._applyLabelMode(displayMode, _max(step, 2), boxes, labelOpt);\n\n        break;\n\n      default:\n        this._applyLabelOverlapping(boxes, overlappingMode, step, behavior);\n\n    }\n  },\n  _applyLabelOverlapping: function (boxes, mode, step, behavior) {\n    var labelOpt = this._options.label;\n    var majorTicks = this._majorTicks;\n\n    if (\"none\" === mode || \"ignore\" === mode) {\n      return;\n    }\n\n    if (step > 1 && boxes.some(function (box, index, array) {\n      if (0 === index) {\n        return false;\n      }\n\n      return constants.areLabelsOverlap(box, array[index - 1], labelOpt.minSpacing, labelOpt.alignment);\n    })) {\n      this._applyLabelMode(mode, step, boxes, behavior);\n    }\n\n    this._checkBoundedLabelsOverlapping(majorTicks, boxes, mode);\n\n    this._checkShiftedLabels(majorTicks, boxes, labelOpt.minSpacing, labelOpt.alignment);\n  },\n  _applyLabelMode: function (mode, step, boxes, behavior, notRecastStep) {\n    var majorTicks = this._majorTicks;\n    var labelOpt = this._options.label;\n    var angle = behavior.rotationAngle;\n    var labelHeight;\n    var alignment;\n    var func;\n\n    switch (mode) {\n      case ROTATE:\n        if (!labelOpt.userAlignment) {\n          alignment = angle < 0 ? RIGHT : LEFT;\n\n          if (angle % 90 === 0) {\n            alignment = CENTER;\n          }\n        }\n\n        step = notRecastStep ? step : this._getStep(boxes, angle);\n\n        func = function (tick) {\n          var contentContainer = tick.getContentContainer();\n\n          if (!contentContainer) {\n            return;\n          }\n\n          contentContainer.rotate(angle);\n          tick.labelRotationAngle = angle;\n          alignment && (tick.labelAlignment = alignment);\n        };\n\n        updateLabels(majorTicks, step, func);\n        break;\n\n      case \"stagger\":\n        labelHeight = this._getMaxLabelHeight(boxes, behavior.staggeringSpacing);\n\n        func = function (tick, index) {\n          if (index / (step - 1) % 2 !== 0) {\n            tick.labelOffset = labelHeight;\n          }\n        };\n\n        updateLabels(majorTicks, step - 1, func);\n        break;\n\n      case \"auto\":\n      case \"_auto\":\n        if (2 === step) {\n          this._applyLabelMode(\"stagger\", step, boxes, behavior);\n        } else {\n          this._applyLabelMode(ROTATE, step, boxes, {\n            rotationAngle: getOptimalAngle(boxes, labelOpt)\n          });\n        }\n\n        break;\n\n      default:\n        updateLabels(majorTicks, step);\n    }\n  },\n  getMarkerTrackers: _noop,\n  _drawDateMarkers: _noop,\n  _adjustDateMarkers: _noop,\n  coordsIn: _noop,\n  areCoordsOutsideAxis: _noop,\n  _getSkippedCategory: _noop,\n  _initAxisPositions: _noop,\n  _drawTitle: _noop,\n  _updateTitleCoords: _noop,\n  _adjustConstantLineLabels: _noop,\n  _createTranslator: function () {\n    return new Translator2D({}, {}, {});\n  },\n  _updateTranslator: function () {\n    var translator = this._translator;\n    translator.update(translator.getBusinessRange(), this._canvas || {}, this._getTranslatorOptions());\n  },\n  _getTranslatorOptions: function () {\n    var _options$workWeek2, _options$breakStyle$w, _options$breakStyle;\n\n    var options = this._options;\n    return {\n      isHorizontal: this._isHorizontal,\n      shiftZeroValue: !this.isArgumentAxis,\n      interval: options.semiDiscreteInterval,\n      firstDayOfWeek: null === (_options$workWeek2 = options.workWeek) || void 0 === _options$workWeek2 ? void 0 : _options$workWeek2[0],\n      stick: this._getStick(),\n      breaksSize: null !== (_options$breakStyle$w = null === (_options$breakStyle = options.breakStyle) || void 0 === _options$breakStyle ? void 0 : _options$breakStyle.width) && void 0 !== _options$breakStyle$w ? _options$breakStyle$w : 0\n    };\n  },\n\n  getVisibleArea() {\n    var canvas = this._getCanvasStartEnd();\n\n    return [canvas.start, canvas.end].sort((a, b) => a - b);\n  },\n\n  _getCanvasStartEnd: function () {\n    var isHorizontal = this._isHorizontal;\n    var canvas = this._canvas || {};\n\n    var invert = this._translator.getBusinessRange().invert;\n\n    var coords = isHorizontal ? [canvas.left, canvas.width - canvas.right] : [canvas.height - canvas.bottom, canvas.top];\n    invert && coords.reverse();\n    return {\n      start: coords[0],\n      end: coords[1]\n    };\n  },\n  _getScreenDelta: function () {\n    var canvas = this._getCanvasStartEnd();\n\n    var breaks = this._seriesData ? this._seriesData.breaks || [] : [];\n    var breaksLength = breaks.length;\n\n    var screenDelta = _abs(canvas.start - canvas.end);\n\n    return screenDelta - (breaksLength ? breaks[breaksLength - 1].cumulativeWidth : 0);\n  },\n  _getScaleBreaks: function () {\n    return [];\n  },\n  _filterBreaks: function () {\n    return [];\n  },\n  _adjustTitle: _noop,\n  _checkTitleOverflow: _noop,\n  getSpiderTicks: _noop,\n  setSpiderTicks: _noop,\n  _checkBoundedLabelsOverlapping: _noop,\n  _checkShiftedLabels: _noop,\n  drawScaleBreaks: _noop,\n  _visualRange: _noop,\n  _rotateConstantLine: _noop,\n\n  applyVisualRangeSetter(visualRangeSetter) {\n    this._visualRange = visualRangeSetter;\n  },\n\n  getCategoriesSorter(argCategories) {\n    var sort;\n\n    if (this.isArgumentAxis) {\n      sort = argCategories;\n    } else {\n      var categoriesSortingMethod = this._options.categoriesSortingMethod;\n      sort = null !== categoriesSortingMethod && void 0 !== categoriesSortingMethod ? categoriesSortingMethod : this._options.categories;\n    }\n\n    return sort;\n  },\n\n  _getAdjustedBusinessRange() {\n    return this.adjustViewport(this._translator.getBusinessRange());\n  }\n\n};","map":{"version":3,"names":["smartFormatter","_format","formatRange","patchFontOptions","getVizRangeObject","getLogExt","getLog","raiseToExt","raiseTo","valueOf","rotateBBox","getCategoriesInfo","adjustVisualRange","getAddFunction","convertVisualRangeObject","isDefined","isFunction","isPlainObject","type","constants","extend","formatHelper","getParser","tickGenerator","Translator2D","Range","tick","adjust","dateUtils","noop","_noop","xyMethods","polarMethods","createConstantLine","createStrip","Deferred","when","calculateCanvasMargins","measureLabels","convertTicksToValues","_math","Math","_abs","abs","_max","max","_min","min","_isArray","Array","isArray","DEFAULT_AXIS_LABEL_SPACING","MAX_GRID_BORDER_ADHENSION","TOP","top","BOTTOM","bottom","LEFT","left","RIGHT","right","CENTER","center","KEEP","SHIFT","RESET","ROTATE","DEFAULT_AXIS_DIVISION_FACTOR","DEFAULT_MINOR_AXIS_DIVISION_FACTOR","SCROLL_THRESHOLD","MIN_BAR_MARGIN","MAX_MARGIN_VALUE","dateIntervals","day","week","getTickGenerator","options","incidentOccurred","skipTickGeneration","rangeIsEmpty","adjustDivisionFactor","_ref","_options$workWeek","allowNegatives","linearThreshold","axisType","dataType","logBase","logarithmBase","axisDivisionFactor","minorAxisDivisionFactor","numberMultipliers","calculateMinors","minorTick","visible","minorGrid","allowDecimals","endOnTick","firstDayOfWeek","workWeek","skipCalculationLimits","generateExtraTick","minTickInterval","createMajorTick","axis","renderer","skippedCategory","getOptions","grid","createMinorTick","createBoundaryTick","isFirst","showCustomBoundaryTicks","callAction","elements","action","actionArgument1","actionArgument2","forEach","e","initTickCoords","ticks","drawTickMarks","drawGrids","drawLine","updateTicksPosition","animate","updateGridsPosition","cleanUpInvalidTicks","i","length","removeInvalidTick","coords","x","y","splice","validateAxisOptions","_labelOptions$minSpac","labelOptions","label","position","defaultPosition","isHorizontal","secondaryPosition","labelPosition","alignment","userAlignment","hoverMode","toLowerCase","minSpacing","argumentType","valueType","getOptimalAngle","boxes","labelOpt","angle","asin","height","PI","updateLabels","step","func","index","getContentContainer","removeLabel","getZoomBoundValue","optionValue","dataValue","configureGenerator","viewPort","screenDelta","tickGeneratorOptions","tickInterval","breaks","isEmpty","v","categories","isSpacedMargin","getConstantLineSharpDirection","coord","axisCanvas","start","end","Axis","renderSettings","_renderer","_incidentOccurred","_eventTrigger","eventTrigger","_stripsGroup","stripsGroup","_stripLabelAxesGroup","stripLabelAxesGroup","_labelsAxesGroup","labelsAxesGroup","_constantLinesGroup","constantLinesGroup","_scaleBreaksGroup","scaleBreaksGroup","_axesContainerGroup","axesContainerGroup","_gridContainerGroup","gridGroup","_axisCssPrefix","widgetClass","axisClass","_setType","drawingType","_createAxisGroups","_translator","_createTranslator","isArgumentAxis","_viewport","_prevDataInfo","_firstDrawing","_initRange","_getTemplate","getTemplate","prototype","constructor","_drawAxis","_options","_axisElement","_createAxisElement","_updateAxisElementPosition","attr","width","stroke","color","opacity","sharp","_getSharpParam","getAxisSharpDirection","append","_axisLineGroup","_createPathElement","points","sharpDirection","path","svgElement","arguments","customPositionIsAvailable","getOrthogonalAxis","getCustomPosition","getCustomBoundaryPosition","resolveOverlappingForCustomPositioning","hasNonBoundaryPosition","customPositionIsBoundaryOrthogonalAxis","getResolvedBoundaryPosition","getSharpDirectionByCoords","canvas","_getCanvasStartEnd","maxCoord","getRadius","_isHorizontal","_getGridLineDrawer","that","gridStyle","_getGridPoints","tickPositionField","orthogonalPositions","_orthogonalPositions","positionFrom","positionTo","borderOptions","canvasStart","canvasEnd","getCanvas","firstBorderLinePosition","lastBorderLinePosition","minDelta","maxDelta","areCoordsOutsideAxis","_getConstantLinePos","parsedValue","value","_getTranslatedCoord","_getConstantLineGraphicAttributes","_createConstantLine","_drawConstantLineLabelText","text","_ref2","group","font","cssClass","css","align","class","_drawConstantLineLabels","lineLabelOptions","_text","_checkAlignmentConstantLineLabels","formatLabel","_getConstantLineLabelsCoords","_getStripPos","startValue","endValue","range","isContinuous","minVisible","maxVisible","reduce","result","cat","push","swap","startCategoryIndex","endCategoryIndex","_parsedStartValue$val","_parsedEndValue$value","parsedStartValue","parser","parsedEndValue","indexOf","from","to","outOfCanvas","validateUnit","stripPosition","visibleArea","getVisibleArea","_getStripGraphicAttributes","fromPoint","toPoint","_createStrip","attrs","rect","_adjustStripLabels","_strips","strip","_getAdjustedStripLabelCoords","_adjustLabelsCoord","offset","maxWidth","checkCanvas","getContainerAttrs","_getLabelAdjustedCoord","labelOffset","_majorTicks","updateMultilineTextAlignment","templateContainer","_adjustLabels","positionsAreConsistent","maxSize","size","bBox","labelRotationAngle","labelBBox","labelCoords","additionalOffset","indentFromAxis","templateBox","getBBox","box","textAlign","labelAlignment","isDiscrete","isFlatLabel","axisPosition","_axisPosition","labelX","translateX","translateY","_createAxisConstantLineGroups","classSelector","constantLinesClass","insideGroup","g","outsideGroup1","outsideGroup2","inside","outside1","outside2","remove","clear","_axisGroup","enableLinks","_axisStripGroup","_axisGridGroup","_axisElementsGroup","linkOn","linkAppend","_axisTitleGroup","_axisConstantLineGroups","above","under","_axisStripLabelGroup","_clearAxisGroups","template","isRendered","_getLabelFormatObject","point","_getViewportRange","formatObject","valueText","_tickInterval","showTransition","marker","customizeText","call","formatHint","customizeHint","interval","argumentFormat","axisOptions","_setTickOffset","discreteAxisDivisionMode","_tickOffset","aggregatedPointBetweenTicks","aggregatedPointsPosition","resetApplyingAnimation","isFirstDrawing","_resetApplyingAnimation","getMargins","customPosition","placeholderSize","crosshairMargin","isDefinedCustomPositionOption","boundaryPosition","cLeft","cTop","cRight","cBottom","edgeMarginCorrection","constantLineAboveSeries","constantLineUnderSeries","map","concat","margins","moveByOffset","customPositionIsBoundary","unit","idError","parameters","axisTypeMethods","_disposeBreaksGroup","dispose","_title","_axisBreaksGroup","_textOptions","_textFontStyles","_minorTicks","_templatesRendered","reject","setPane","pane","setTypes","typeSelector","_updateTranslator","resetTypes","_initTypes","getTranslator","updateOptions","title","name","priority","_hasLabelFormat","format","logarithmic","logarithmBaseError","_createConstantLines","strips","o","calculateInterval","prevValue","getBusinessRange","getCanvasRange","translator","translate","_processCanvas","updateCanvas","canvasRedesign","positions","_canvas","_initAxisPositions","getAxisShift","_axisShift","hideTitle","getTitle","hideOuterElements","_outsideConstantLines","_resolveLogarithmicOptionsForRange","addRange","isNaN","adjustViewport","businessRange","discrete","_seriesData","wholeRange","adjustRange","visualRange","getViewport","_addConstantLinesToRange","minDefined","maxDefined","_wholeRange$startValu","_wholeRange$endValue","categoriesInfo","adjustedVisualRange","base","isLogarithmic","disabledNegatives","tmp","_getVisualRangeUpdateMode","viewport","newRange","oppositeValue","visualRangeUpdateMode","prevDataInfo","containsConstantLine","newCategories","c","join","minPoint","minVisiblePoint","maxPoint","maxVisiblePoint","_handleBusinessRangeChanged","oppositeVisualRangeUpdateMode","axisReinitialized","_lastVisualRangeUpdateMode","_setVisualRange","getVisualRangeLength","currentBusinessRange","getVisualRangeCenter","useMerge","ceil","toValue","setBusinessRange","argCategories","_that$_seriesData$min","_that$_seriesData$max","dataIsEmpty","rangeWithConstantLines","invert","inverted","synchronizedValue","showZero","correctValueZeroLevel","sortCategories","getCategoriesSorter","userBreaks","_getScaleBreaks","_series","updateBusinessRange","dataRange","minValueField","maxValueField","_insideConstantLines","cl","extendAxis","getParsedValue","setGroupSeries","series","getLabelsPosition","labelShift","_constantLabelOffset","getFormattedValue","_getBoundaryTicks","majors","customBounds","customBoundTicks","addMinMax","_boundaryTicksVisibility","boundaryTicks","setPercentLabelFormat","resetAutoLabelFormat","getMultipleAxesSpacing","multipleAxesSpacing","getTicksValues","majorTicksValues","minorTicksValues","estimateTickInterval","_getTicks","setTicks","majorTicks","_getSkippedCategory","minorTicks","_isSynchronized","_adjustDivisionFactor","val","customTicks","customMinorTicks","bind","_getScreenDelta","overlappingBehavior","forceUserTickInterval","minors","minorTickInterval","minorTickCount","_initialBreaks","_createTicksAndLabelFormat","getDateFormatByTicks","getAggregationInfo","useAllAggregatedPoints","_visualRange$startVal","_visualRange$endValue","_that$_seriesData","marginOptions","_marginOptions","aggregateByCategory","aggregationInterval","aggregationGroupWidth","checkInterval","sizePointNormalState","minInterval","generateTicks","add","maxMinDistance","dateToMilliseconds","filteredBreaks","_filterBreaks","breakStyle","_aggregationInterval","getTickInterval","getAggregationInterval","createTicks","_estimatedTickInterval","_calculateValueMargins","minValue","maxValue","_boundaryTicks","filter","minor","some","boundary","_minorTickInterval","oldMajorTicks","majorTicksByValues","r","t","sameType","setSkippedCategory","oldMinorTicks","updateValue","_ticksToRemove","Object","keys","k","slice","_t$label","removeTitle","_reinitTranslator","setMarginOptions","getMarginOptions","_this$_marginOptions","_calculateRangeInterval","isDateTime","minArgs","addToArgs","_calculateWorkWeekInterval","apply","businessInterval","workdaysOnly","weekend","weekendsCount","_getConvertIntervalCoefficient","intervalInPx","ratioOfCanvasRange","_resetMargins","marginSize","valueMarginsEnabled","minValueMargin","maxValueMargin","minPadding","maxPadding","rangeInterval","stubData","startPadding","endPadding","pxInterval","getInterval","isFinite","minPercentPadding","maxPercentPadding","maxPaddingValue","percentStick","canvasStartEnd","commonMargin","screenDeltaWithMargins","skipViewportExtending","firstTickPosition","lastTickPosition","invertMultiplier","minTickPadding","maxTickPadding","commonPadding","coeff","isInverted","_minValue","_maxValue","_minValue2","_maxValue2","correctedMin","correctedMax","getCorrectedValuesToZero","correctZeroLevel","minExpectedPadding","maxExpectedPadding","applyMargins","br","constantLines","l","draw","_drawTitle","drawGridLine","_dateMarkers","_drawDateMarkers","_measureTitle","_applyWordWrap","_adjustConstantLineLabels","_setLabelsPlacement","getTemplateDeferred","done","resolve","_adjustDateMarkers","_adjustTitle","getTemplatesDef","setRenderedState","state","_drawn","convertedTickInterval","textWidth","textHeight","displayMode","_validateDisplayMode","overlappingMode","_validateOverlappingMode","wordWrapMode","wordWrap","overflowMode","textOverflow","usefulSpace","correctByWidth","correctByHeight","setMaxSize","updateSize","updateTitle","_checkTitleOverflow","_updateTitleCoords","animationEnabled","_resetStartCoordinates","updatePosition","prepareAnimation","_updateLabelsPosition","applyClipRects","elementsClipID","canvasClipID","_validateVisualRange","_validateOptions","_customVisualRange","validate","resetVisualRange","isSilent","handleZooming","allowPartialUpdate","_applyZooming","_resetVisualRangeOption","getZoomStartEventArg","event","actionType","cancel","_getZoomEndEventArg","previousRange","zoomFactor","shift","rangeStart","rangeEnd","getZoomBounds","secondPriorityRange","setInitRange","getTemplatesGroups","item","setCustomVisualRange","args","adjustedRange","_getAdjustedBusinessRange","_startValue","_endValue","zoomResults","isPrevented","_visualRange","preventEvents","domEvent","zoomStartEvent","skipEventRising","_storedZoomEndParams","startRange","prevent","handleZoomEnd","previousBusinessRange","typeIsNotChanged","NaN","round","zoomEndEvent","checkZoomingLowerLimitOvercome","stopInteraction","_restorePreviousVisualRange","minZoom","minVisualRangeLength","correctedRange","isOvercoming","beforeVisualRangeLength","afterVisualRangeLength","convert","getRangeByMinZoomValue","canvasLength","fullRange","isExtremePosition","isMax","extremeDataValue","seriesData","extremePoint","visualRangePoint","getFullTicks","sort","a","b","withIndents","widthAxis","indent","viewportRange","maxText","prevLabel","root","ignoreOverlapping","behavior","rotationAngle","staggeringSpacing","notRecastStep","_getStep","_applyLabelMode","_applyLabelOverlapping","mode","array","areLabelsOverlap","_checkBoundedLabelsOverlapping","_checkShiftedLabels","labelHeight","contentContainer","rotate","_getMaxLabelHeight","getMarkerTrackers","coordsIn","update","_getTranslatorOptions","_options$workWeek2","_options$breakStyle$w","_options$breakStyle","shiftZeroValue","semiDiscreteInterval","stick","_getStick","breaksSize","reverse","breaksLength","cumulativeWidth","getSpiderTicks","setSpiderTicks","drawScaleBreaks","_rotateConstantLine","applyVisualRangeSetter","visualRangeSetter","categoriesSortingMethod"],"sources":["E:/MisaProject/W2022_06/misa_emis/node_modules/devextreme/esm/viz/axes/base_axis.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/viz/axes/base_axis.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    smartFormatter as _format,\r\n    formatRange\r\n} from \"./smart_formatter\";\r\nimport {\r\n    patchFontOptions,\r\n    getVizRangeObject,\r\n    getLogExt as getLog,\r\n    raiseToExt as raiseTo,\r\n    valueOf,\r\n    rotateBBox,\r\n    getCategoriesInfo,\r\n    adjustVisualRange,\r\n    getAddFunction,\r\n    convertVisualRangeObject\r\n} from \"../core/utils\";\r\nimport {\r\n    isDefined,\r\n    isFunction,\r\n    isPlainObject,\r\n    type\r\n} from \"../../core/utils/type\";\r\nimport constants from \"./axes_constants\";\r\nimport {\r\n    extend\r\n} from \"../../core/utils/extend\";\r\nimport formatHelper from \"../../format_helper\";\r\nimport {\r\n    getParser\r\n} from \"../components/parse_utils\";\r\nimport {\r\n    tickGenerator\r\n} from \"./tick_generator\";\r\nimport {\r\n    Translator2D\r\n} from \"../translators/translator2d\";\r\nimport {\r\n    Range\r\n} from \"../translators/range\";\r\nimport {\r\n    tick\r\n} from \"./tick\";\r\nimport {\r\n    adjust\r\n} from \"../../core/utils/math\";\r\nimport dateUtils from \"../../core/utils/date\";\r\nimport {\r\n    noop as _noop\r\n} from \"../../core/utils/common\";\r\nimport xyMethods from \"./xy_axes\";\r\nimport * as polarMethods from \"./polar_axes\";\r\nimport createConstantLine from \"./constant_line\";\r\nimport createStrip from \"./strip\";\r\nimport {\r\n    Deferred,\r\n    when\r\n} from \"../../core/utils/deferred\";\r\nimport {\r\n    calculateCanvasMargins,\r\n    measureLabels\r\n} from \"./axes_utils\";\r\nvar convertTicksToValues = constants.convertTicksToValues;\r\nvar _math = Math;\r\nvar _abs = _math.abs;\r\nvar _max = _math.max;\r\nvar _min = _math.min;\r\nvar _isArray = Array.isArray;\r\nvar DEFAULT_AXIS_LABEL_SPACING = 5;\r\nvar MAX_GRID_BORDER_ADHENSION = 4;\r\nvar TOP = constants.top;\r\nvar BOTTOM = constants.bottom;\r\nvar LEFT = constants.left;\r\nvar RIGHT = constants.right;\r\nvar CENTER = constants.center;\r\nvar KEEP = \"keep\";\r\nvar SHIFT = \"shift\";\r\nvar RESET = \"reset\";\r\nvar ROTATE = \"rotate\";\r\nvar DEFAULT_AXIS_DIVISION_FACTOR = 50;\r\nvar DEFAULT_MINOR_AXIS_DIVISION_FACTOR = 15;\r\nvar SCROLL_THRESHOLD = 5;\r\nvar MIN_BAR_MARGIN = 5;\r\nvar MAX_MARGIN_VALUE = .8;\r\nvar dateIntervals = {\r\n    day: 864e5,\r\n    week: 6048e5\r\n};\r\n\r\nfunction getTickGenerator(options, incidentOccurred, skipTickGeneration, rangeIsEmpty, adjustDivisionFactor, _ref) {\r\n    var _options$workWeek;\r\n    var {\r\n        allowNegatives: allowNegatives,\r\n        linearThreshold: linearThreshold\r\n    } = _ref;\r\n    return tickGenerator({\r\n        axisType: options.type,\r\n        dataType: options.dataType,\r\n        logBase: options.logarithmBase,\r\n        allowNegatives: allowNegatives,\r\n        linearThreshold: linearThreshold,\r\n        axisDivisionFactor: adjustDivisionFactor(options.axisDivisionFactor || DEFAULT_AXIS_DIVISION_FACTOR),\r\n        minorAxisDivisionFactor: adjustDivisionFactor(options.minorAxisDivisionFactor || DEFAULT_MINOR_AXIS_DIVISION_FACTOR),\r\n        numberMultipliers: options.numberMultipliers,\r\n        calculateMinors: options.minorTick.visible || options.minorGrid.visible || options.calculateMinors,\r\n        allowDecimals: options.allowDecimals,\r\n        endOnTick: options.endOnTick,\r\n        incidentOccurred: incidentOccurred,\r\n        firstDayOfWeek: null === (_options$workWeek = options.workWeek) || void 0 === _options$workWeek ? void 0 : _options$workWeek[0],\r\n        skipTickGeneration: skipTickGeneration,\r\n        skipCalculationLimits: options.skipCalculationLimits,\r\n        generateExtraTick: options.generateExtraTick,\r\n        minTickInterval: options.minTickInterval,\r\n        rangeIsEmpty: rangeIsEmpty\r\n    })\r\n}\r\n\r\nfunction createMajorTick(axis, renderer, skippedCategory) {\r\n    var options = axis.getOptions();\r\n    return tick(axis, renderer, options.tick, options.grid, skippedCategory, false)\r\n}\r\n\r\nfunction createMinorTick(axis, renderer) {\r\n    var options = axis.getOptions();\r\n    return tick(axis, renderer, options.minorTick, options.minorGrid)\r\n}\r\n\r\nfunction createBoundaryTick(axis, renderer, isFirst) {\r\n    var options = axis.getOptions();\r\n    return tick(axis, renderer, extend({}, options.tick, {\r\n        visible: options.showCustomBoundaryTicks\r\n    }), options.grid, void 0, false, isFirst ? -1 : 1)\r\n}\r\n\r\nfunction callAction(elements, action, actionArgument1, actionArgument2) {\r\n    (elements || []).forEach(e => e[action](actionArgument1, actionArgument2))\r\n}\r\n\r\nfunction initTickCoords(ticks) {\r\n    callAction(ticks, \"initCoords\")\r\n}\r\n\r\nfunction drawTickMarks(ticks, options) {\r\n    callAction(ticks, \"drawMark\", options)\r\n}\r\n\r\nfunction drawGrids(ticks, drawLine) {\r\n    callAction(ticks, \"drawGrid\", drawLine)\r\n}\r\n\r\nfunction updateTicksPosition(ticks, options, animate) {\r\n    callAction(ticks, \"updateTickPosition\", options, animate)\r\n}\r\n\r\nfunction updateGridsPosition(ticks, animate) {\r\n    callAction(ticks, \"updateGridPosition\", animate)\r\n}\r\n\r\nfunction cleanUpInvalidTicks(ticks) {\r\n    var i = ticks.length - 1;\r\n    for (i; i >= 0; i--) {\r\n        if (!removeInvalidTick(ticks, i)) {\r\n            break\r\n        }\r\n    }\r\n    for (i = 0; i < ticks.length; i++) {\r\n        if (removeInvalidTick(ticks, i)) {\r\n            i--\r\n        } else {\r\n            break\r\n        }\r\n    }\r\n}\r\n\r\nfunction removeInvalidTick(ticks, i) {\r\n    if (null === ticks[i].coords.x || null === ticks[i].coords.y) {\r\n        ticks.splice(i, 1);\r\n        return true\r\n    }\r\n    return false\r\n}\r\n\r\nfunction validateAxisOptions(options) {\r\n    var _labelOptions$minSpac;\r\n    var labelOptions = options.label;\r\n    var position = options.position;\r\n    var defaultPosition = options.isHorizontal ? BOTTOM : LEFT;\r\n    var secondaryPosition = options.isHorizontal ? TOP : RIGHT;\r\n    var labelPosition = labelOptions.position;\r\n    if (position !== defaultPosition && position !== secondaryPosition) {\r\n        position = defaultPosition\r\n    }\r\n    if (!labelPosition || \"outside\" === labelPosition) {\r\n        labelPosition = position\r\n    } else if (\"inside\" === labelPosition) {\r\n        labelPosition = {\r\n            [TOP]: BOTTOM,\r\n            [BOTTOM]: TOP,\r\n            [LEFT]: RIGHT,\r\n            [RIGHT]: LEFT\r\n        } [position]\r\n    }\r\n    if (labelPosition !== defaultPosition && labelPosition !== secondaryPosition) {\r\n        labelPosition = position\r\n    }\r\n    if (labelOptions.alignment !== CENTER && !labelOptions.userAlignment) {\r\n        labelOptions.alignment = {\r\n            [TOP]: CENTER,\r\n            [BOTTOM]: CENTER,\r\n            [LEFT]: RIGHT,\r\n            [RIGHT]: LEFT\r\n        } [labelPosition]\r\n    }\r\n    options.position = position;\r\n    labelOptions.position = labelPosition;\r\n    options.hoverMode = options.hoverMode ? options.hoverMode.toLowerCase() : \"none\";\r\n    labelOptions.minSpacing = null !== (_labelOptions$minSpac = labelOptions.minSpacing) && void 0 !== _labelOptions$minSpac ? _labelOptions$minSpac : DEFAULT_AXIS_LABEL_SPACING;\r\n    options.type && (options.type = options.type.toLowerCase());\r\n    options.argumentType && (options.argumentType = options.argumentType.toLowerCase());\r\n    options.valueType && (options.valueType = options.valueType.toLowerCase())\r\n}\r\n\r\nfunction getOptimalAngle(boxes, labelOpt) {\r\n    var angle = 180 * _math.asin((boxes[0].height + labelOpt.minSpacing) / (boxes[1].x - boxes[0].x)) / _math.PI;\r\n    return angle < 45 ? -45 : -90\r\n}\r\n\r\nfunction updateLabels(ticks, step, func) {\r\n    ticks.forEach((function(tick, index) {\r\n        if (tick.getContentContainer()) {\r\n            if (index % step !== 0) {\r\n                tick.removeLabel()\r\n            } else if (func) {\r\n                func(tick, index)\r\n            }\r\n        }\r\n    }))\r\n}\r\n\r\nfunction getZoomBoundValue(optionValue, dataValue) {\r\n    if (void 0 === optionValue) {\r\n        return dataValue\r\n    } else if (null === optionValue) {\r\n        return\r\n    } else {\r\n        return optionValue\r\n    }\r\n}\r\n\r\nfunction configureGenerator(options, axisDivisionFactor, viewPort, screenDelta, minTickInterval) {\r\n    var tickGeneratorOptions = extend({}, options, {\r\n        endOnTick: true,\r\n        axisDivisionFactor: axisDivisionFactor,\r\n        skipCalculationLimits: true,\r\n        generateExtraTick: true,\r\n        minTickInterval: minTickInterval\r\n    });\r\n    return function(tickInterval, skipTickGeneration, min, max, breaks) {\r\n        return getTickGenerator(tickGeneratorOptions, _noop, skipTickGeneration, viewPort.isEmpty(), v => v, viewPort)({\r\n            min: min,\r\n            max: max,\r\n            categories: viewPort.categories,\r\n            isSpacedMargin: viewPort.isSpacedMargin\r\n        }, screenDelta, tickInterval, isDefined(tickInterval), void 0, void 0, void 0, breaks)\r\n    }\r\n}\r\n\r\nfunction getConstantLineSharpDirection(coord, axisCanvas) {\r\n    return Math.max(axisCanvas.start, axisCanvas.end) !== coord ? 1 : -1\r\n}\r\nexport var Axis = function(renderSettings) {\r\n    this._renderer = renderSettings.renderer;\r\n    this._incidentOccurred = renderSettings.incidentOccurred;\r\n    this._eventTrigger = renderSettings.eventTrigger;\r\n    this._stripsGroup = renderSettings.stripsGroup;\r\n    this._stripLabelAxesGroup = renderSettings.stripLabelAxesGroup;\r\n    this._labelsAxesGroup = renderSettings.labelsAxesGroup;\r\n    this._constantLinesGroup = renderSettings.constantLinesGroup;\r\n    this._scaleBreaksGroup = renderSettings.scaleBreaksGroup;\r\n    this._axesContainerGroup = renderSettings.axesContainerGroup;\r\n    this._gridContainerGroup = renderSettings.gridGroup;\r\n    this._axisCssPrefix = renderSettings.widgetClass + \"-\" + (renderSettings.axisClass ? renderSettings.axisClass + \"-\" : \"\");\r\n    this._setType(renderSettings.axisType, renderSettings.drawingType);\r\n    this._createAxisGroups();\r\n    this._translator = this._createTranslator();\r\n    this.isArgumentAxis = renderSettings.isArgumentAxis;\r\n    this._viewport = {};\r\n    this._prevDataInfo = {};\r\n    this._firstDrawing = true;\r\n    this._initRange = {};\r\n    this._getTemplate = renderSettings.getTemplate\r\n};\r\nAxis.prototype = {\r\n    constructor: Axis,\r\n    _drawAxis() {\r\n        var options = this._options;\r\n        if (!options.visible) {\r\n            return\r\n        }\r\n        this._axisElement = this._createAxisElement();\r\n        this._updateAxisElementPosition();\r\n        this._axisElement.attr({\r\n            \"stroke-width\": options.width,\r\n            stroke: options.color,\r\n            \"stroke-opacity\": options.opacity\r\n        }).sharp(this._getSharpParam(true), this.getAxisSharpDirection()).append(this._axisLineGroup)\r\n    },\r\n    _createPathElement(points, attr, sharpDirection) {\r\n        return this.sharp(this._renderer.path(points, \"line\").attr(attr), sharpDirection)\r\n    },\r\n    sharp(svgElement) {\r\n        var sharpDirection = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\r\n        return svgElement.sharp(this._getSharpParam(), sharpDirection)\r\n    },\r\n    customPositionIsAvailable: () => false,\r\n    getOrthogonalAxis: _noop,\r\n    getCustomPosition: _noop,\r\n    getCustomBoundaryPosition: _noop,\r\n    resolveOverlappingForCustomPositioning: _noop,\r\n    hasNonBoundaryPosition: () => false,\r\n    customPositionIsBoundaryOrthogonalAxis: () => false,\r\n    getResolvedBoundaryPosition() {\r\n        return this.getOptions().position\r\n    },\r\n    getAxisSharpDirection() {\r\n        var position = this.getResolvedBoundaryPosition();\r\n        return this.hasNonBoundaryPosition() || position !== BOTTOM && position !== RIGHT ? 1 : -1\r\n    },\r\n    getSharpDirectionByCoords(coords) {\r\n        var canvas = this._getCanvasStartEnd();\r\n        var maxCoord = Math.max(canvas.start, canvas.end);\r\n        return this.getRadius ? 0 : maxCoord !== coords[this._isHorizontal ? \"x\" : \"y\"] ? 1 : -1\r\n    },\r\n    _getGridLineDrawer: function() {\r\n        var that = this;\r\n        return function(tick, gridStyle) {\r\n            var grid = that._getGridPoints(tick.coords);\r\n            if (grid.points) {\r\n                return that._createPathElement(grid.points, gridStyle, that.getSharpDirectionByCoords(tick.coords))\r\n            }\r\n            return null\r\n        }\r\n    },\r\n    _getGridPoints: function(coords) {\r\n        var isHorizontal = this._isHorizontal;\r\n        var tickPositionField = isHorizontal ? \"x\" : \"y\";\r\n        var orthogonalPositions = this._orthogonalPositions;\r\n        var positionFrom = orthogonalPositions.start;\r\n        var positionTo = orthogonalPositions.end;\r\n        var borderOptions = this.borderOptions;\r\n        var canvasStart = isHorizontal ? LEFT : TOP;\r\n        var canvasEnd = isHorizontal ? RIGHT : BOTTOM;\r\n        var axisCanvas = this.getCanvas();\r\n        var canvas = {\r\n            left: axisCanvas.left,\r\n            right: axisCanvas.width - axisCanvas.right,\r\n            top: axisCanvas.top,\r\n            bottom: axisCanvas.height - axisCanvas.bottom\r\n        };\r\n        var firstBorderLinePosition = borderOptions.visible && borderOptions[canvasStart] ? canvas[canvasStart] : void 0;\r\n        var lastBorderLinePosition = borderOptions.visible && borderOptions[canvasEnd] ? canvas[canvasEnd] : void 0;\r\n        var minDelta = MAX_GRID_BORDER_ADHENSION + firstBorderLinePosition;\r\n        var maxDelta = lastBorderLinePosition - MAX_GRID_BORDER_ADHENSION;\r\n        if (this.areCoordsOutsideAxis(coords) || void 0 === coords[tickPositionField] || coords[tickPositionField] < minDelta || coords[tickPositionField] > maxDelta) {\r\n            return {\r\n                points: null\r\n            }\r\n        }\r\n        return {\r\n            points: isHorizontal ? null !== coords[tickPositionField] ? [coords[tickPositionField], positionFrom, coords[tickPositionField], positionTo] : null : null !== coords[tickPositionField] ? [positionFrom, coords[tickPositionField], positionTo, coords[tickPositionField]] : null\r\n        }\r\n    },\r\n    _getConstantLinePos: function(parsedValue, canvasStart, canvasEnd) {\r\n        var value = this._getTranslatedCoord(parsedValue);\r\n        if (!isDefined(value) || value < _min(canvasStart, canvasEnd) || value > _max(canvasStart, canvasEnd)) {\r\n            return\r\n        }\r\n        return value\r\n    },\r\n    _getConstantLineGraphicAttributes: function(value) {\r\n        var positionFrom = this._orthogonalPositions.start;\r\n        var positionTo = this._orthogonalPositions.end;\r\n        return {\r\n            points: this._isHorizontal ? [value, positionFrom, value, positionTo] : [positionFrom, value, positionTo, value]\r\n        }\r\n    },\r\n    _createConstantLine: function(value, attr) {\r\n        return this._createPathElement(this._getConstantLineGraphicAttributes(value).points, attr, getConstantLineSharpDirection(value, this._getCanvasStartEnd()))\r\n    },\r\n    _drawConstantLineLabelText: function(text, x, y, _ref2, group) {\r\n        var {\r\n            font: font,\r\n            cssClass: cssClass\r\n        } = _ref2;\r\n        return this._renderer.text(text, x, y).css(patchFontOptions(extend({}, this._options.label.font, font))).attr({\r\n            align: \"center\",\r\n            class: cssClass\r\n        }).append(group)\r\n    },\r\n    _drawConstantLineLabels: function(parsedValue, lineLabelOptions, value, group) {\r\n        var _text;\r\n        var text = lineLabelOptions.text;\r\n        var options = this._options;\r\n        var labelOptions = options.label;\r\n        this._checkAlignmentConstantLineLabels(lineLabelOptions);\r\n        text = null !== (_text = text) && void 0 !== _text ? _text : this.formatLabel(parsedValue, labelOptions);\r\n        var coords = this._getConstantLineLabelsCoords(value, lineLabelOptions);\r\n        return this._drawConstantLineLabelText(text, coords.x, coords.y, lineLabelOptions, group)\r\n    },\r\n    _getStripPos: function(startValue, endValue, canvasStart, canvasEnd, range) {\r\n        var isContinuous = !!(range.minVisible || range.maxVisible);\r\n        var categories = (range.categories || []).reduce((function(result, cat) {\r\n            result.push(cat.valueOf());\r\n            return result\r\n        }), []);\r\n        var start;\r\n        var end;\r\n        var swap;\r\n        var startCategoryIndex;\r\n        var endCategoryIndex;\r\n        if (!isContinuous) {\r\n            if (isDefined(startValue) && isDefined(endValue)) {\r\n                var _parsedStartValue$val, _parsedEndValue$value;\r\n                var parsedStartValue = this.parser(startValue);\r\n                var parsedEndValue = this.parser(endValue);\r\n                startCategoryIndex = categories.indexOf(null !== (_parsedStartValue$val = null === parsedStartValue || void 0 === parsedStartValue ? void 0 : parsedStartValue.valueOf()) && void 0 !== _parsedStartValue$val ? _parsedStartValue$val : void 0);\r\n                endCategoryIndex = categories.indexOf(null !== (_parsedEndValue$value = null === parsedEndValue || void 0 === parsedEndValue ? void 0 : parsedEndValue.valueOf()) && void 0 !== _parsedEndValue$value ? _parsedEndValue$value : void 0);\r\n                if (-1 === startCategoryIndex || -1 === endCategoryIndex) {\r\n                    return {\r\n                        from: 0,\r\n                        to: 0,\r\n                        outOfCanvas: true\r\n                    }\r\n                }\r\n                if (startCategoryIndex > endCategoryIndex) {\r\n                    swap = endValue;\r\n                    endValue = startValue;\r\n                    startValue = swap\r\n                }\r\n            }\r\n        }\r\n        if (isDefined(startValue)) {\r\n            startValue = this.validateUnit(startValue, \"E2105\", \"strip\");\r\n            start = this._getTranslatedCoord(startValue, -1)\r\n        } else {\r\n            start = canvasStart\r\n        }\r\n        if (isDefined(endValue)) {\r\n            endValue = this.validateUnit(endValue, \"E2105\", \"strip\");\r\n            end = this._getTranslatedCoord(endValue, 1)\r\n        } else {\r\n            end = canvasEnd\r\n        }\r\n        var stripPosition = start < end ? {\r\n            from: start,\r\n            to: end\r\n        } : {\r\n            from: end,\r\n            to: start\r\n        };\r\n        var visibleArea = this.getVisibleArea();\r\n        if (stripPosition.from <= visibleArea[0] && stripPosition.to <= visibleArea[0] || stripPosition.from >= visibleArea[1] && stripPosition.to >= visibleArea[1]) {\r\n            stripPosition.outOfCanvas = true\r\n        }\r\n        return stripPosition\r\n    },\r\n    _getStripGraphicAttributes: function(fromPoint, toPoint) {\r\n        var x;\r\n        var y;\r\n        var width;\r\n        var height;\r\n        var orthogonalPositions = this._orthogonalPositions;\r\n        var positionFrom = orthogonalPositions.start;\r\n        var positionTo = orthogonalPositions.end;\r\n        if (this._isHorizontal) {\r\n            x = fromPoint;\r\n            y = _min(positionFrom, positionTo);\r\n            width = toPoint - fromPoint;\r\n            height = _abs(positionFrom - positionTo)\r\n        } else {\r\n            x = _min(positionFrom, positionTo);\r\n            y = fromPoint;\r\n            width = _abs(positionFrom - positionTo);\r\n            height = _abs(fromPoint - toPoint)\r\n        }\r\n        return {\r\n            x: x,\r\n            y: y,\r\n            width: width,\r\n            height: height\r\n        }\r\n    },\r\n    _createStrip: function(attrs) {\r\n        return this._renderer.rect(attrs.x, attrs.y, attrs.width, attrs.height)\r\n    },\r\n    _adjustStripLabels: function() {\r\n        var that = this;\r\n        this._strips.forEach((function(strip) {\r\n            if (strip.label) {\r\n                strip.label.attr(that._getAdjustedStripLabelCoords(strip))\r\n            }\r\n        }))\r\n    },\r\n    _adjustLabelsCoord(offset, maxWidth, checkCanvas) {\r\n        var getContainerAttrs = tick => this._getLabelAdjustedCoord(tick, offset + (tick.labelOffset || 0), maxWidth, checkCanvas);\r\n        this._majorTicks.forEach((function(tick) {\r\n            if (tick.label) {\r\n                tick.updateMultilineTextAlignment();\r\n                tick.label.attr(getContainerAttrs(tick))\r\n            } else {\r\n                tick.templateContainer && tick.templateContainer.attr(getContainerAttrs(tick))\r\n            }\r\n        }))\r\n    },\r\n    _adjustLabels: function(offset) {\r\n        var options = this.getOptions();\r\n        var positionsAreConsistent = options.position === options.label.position;\r\n        var maxSize = this._majorTicks.reduce((function(size, tick) {\r\n            if (!tick.getContentContainer()) {\r\n                return size\r\n            }\r\n            var bBox = tick.labelRotationAngle ? rotateBBox(tick.labelBBox, [tick.labelCoords.x, tick.labelCoords.y], -tick.labelRotationAngle) : tick.labelBBox;\r\n            return {\r\n                width: _max(size.width || 0, bBox.width),\r\n                height: _max(size.height || 0, bBox.height),\r\n                offset: _max(size.offset || 0, tick.labelOffset || 0)\r\n            }\r\n        }), {});\r\n        var additionalOffset = positionsAreConsistent ? this._isHorizontal ? maxSize.height : maxSize.width : 0;\r\n        this._adjustLabelsCoord(offset, maxSize.width);\r\n        return offset + additionalOffset + (additionalOffset && this._options.label.indentFromAxis) + (positionsAreConsistent ? maxSize.offset : 0)\r\n    },\r\n    _getLabelAdjustedCoord: function(tick, offset, maxWidth) {\r\n        offset = offset || 0;\r\n        var options = this._options;\r\n        var templateBox = tick.templateContainer && tick.templateContainer.getBBox();\r\n        var box = templateBox || rotateBBox(tick.labelBBox, [tick.labelCoords.x, tick.labelCoords.y], -tick.labelRotationAngle || 0);\r\n        var textAlign = tick.labelAlignment || options.label.alignment;\r\n        var isDiscrete = \"discrete\" === this._options.type;\r\n        var isFlatLabel = tick.labelRotationAngle % 90 === 0;\r\n        var indentFromAxis = options.label.indentFromAxis;\r\n        var labelPosition = options.label.position;\r\n        var axisPosition = this._axisPosition;\r\n        var labelCoords = tick.labelCoords;\r\n        var labelX = labelCoords.x;\r\n        var translateX;\r\n        var translateY;\r\n        if (this._isHorizontal) {\r\n            if (labelPosition === BOTTOM) {\r\n                translateY = axisPosition + indentFromAxis - box.y + offset\r\n            } else {\r\n                translateY = axisPosition - indentFromAxis - (box.y + box.height) - offset\r\n            }\r\n            if (textAlign === RIGHT) {\r\n                translateX = isDiscrete && isFlatLabel ? tick.coords.x - (box.x + box.width) : labelX - box.x - box.width\r\n            } else if (textAlign === LEFT) {\r\n                translateX = isDiscrete && isFlatLabel ? labelX - box.x - (tick.coords.x - labelX) : labelX - box.x\r\n            } else {\r\n                translateX = labelX - box.x - box.width / 2\r\n            }\r\n        } else {\r\n            translateY = labelCoords.y - box.y - box.height / 2;\r\n            if (labelPosition === LEFT) {\r\n                if (textAlign === LEFT) {\r\n                    translateX = axisPosition - indentFromAxis - maxWidth - box.x\r\n                } else if (textAlign === CENTER) {\r\n                    translateX = axisPosition - indentFromAxis - maxWidth / 2 - box.x - box.width / 2\r\n                } else {\r\n                    translateX = axisPosition - indentFromAxis - box.x - box.width\r\n                }\r\n                translateX -= offset\r\n            } else {\r\n                if (textAlign === RIGHT) {\r\n                    translateX = axisPosition + indentFromAxis + maxWidth - box.x - box.width\r\n                } else if (textAlign === CENTER) {\r\n                    translateX = axisPosition + indentFromAxis + maxWidth / 2 - box.x - box.width / 2\r\n                } else {\r\n                    translateX = axisPosition + indentFromAxis - box.x\r\n                }\r\n                translateX += offset\r\n            }\r\n        }\r\n        return {\r\n            translateX: translateX,\r\n            translateY: translateY\r\n        }\r\n    },\r\n    _createAxisConstantLineGroups: function() {\r\n        var renderer = this._renderer;\r\n        var classSelector = this._axisCssPrefix;\r\n        var constantLinesClass = classSelector + \"constant-lines\";\r\n        var insideGroup = renderer.g().attr({\r\n            class: constantLinesClass\r\n        });\r\n        var outsideGroup1 = renderer.g().attr({\r\n            class: constantLinesClass\r\n        });\r\n        var outsideGroup2 = renderer.g().attr({\r\n            class: constantLinesClass\r\n        });\r\n        return {\r\n            inside: insideGroup,\r\n            outside1: outsideGroup1,\r\n            left: outsideGroup1,\r\n            top: outsideGroup1,\r\n            outside2: outsideGroup2,\r\n            right: outsideGroup2,\r\n            bottom: outsideGroup2,\r\n            remove: function() {\r\n                this.inside.remove();\r\n                this.outside1.remove();\r\n                this.outside2.remove()\r\n            },\r\n            clear: function() {\r\n                this.inside.clear();\r\n                this.outside1.clear();\r\n                this.outside2.clear()\r\n            }\r\n        }\r\n    },\r\n    _createAxisGroups: function() {\r\n        var renderer = this._renderer;\r\n        var classSelector = this._axisCssPrefix;\r\n        this._axisGroup = renderer.g().attr({\r\n            class: classSelector + \"axis\"\r\n        }).enableLinks();\r\n        this._axisStripGroup = renderer.g().attr({\r\n            class: classSelector + \"strips\"\r\n        });\r\n        this._axisGridGroup = renderer.g().attr({\r\n            class: classSelector + \"grid\"\r\n        });\r\n        this._axisElementsGroup = renderer.g().attr({\r\n            class: classSelector + \"elements\"\r\n        });\r\n        this._axisLineGroup = renderer.g().attr({\r\n            class: classSelector + \"line\"\r\n        }).linkOn(this._axisGroup, \"axisLine\").linkAppend();\r\n        this._axisTitleGroup = renderer.g().attr({\r\n            class: classSelector + \"title\"\r\n        }).append(this._axisGroup);\r\n        this._axisConstantLineGroups = {\r\n            above: this._createAxisConstantLineGroups(),\r\n            under: this._createAxisConstantLineGroups()\r\n        };\r\n        this._axisStripLabelGroup = renderer.g().attr({\r\n            class: classSelector + \"axis-labels\"\r\n        })\r\n    },\r\n    _clearAxisGroups: function() {\r\n        this._axisGroup.remove();\r\n        this._axisStripGroup.remove();\r\n        this._axisStripLabelGroup.remove();\r\n        this._axisConstantLineGroups.above.remove();\r\n        this._axisConstantLineGroups.under.remove();\r\n        this._axisGridGroup.remove();\r\n        this._axisTitleGroup.clear();\r\n        if (!this._options.label.template || !this.isRendered()) {\r\n            this._axisElementsGroup.remove();\r\n            this._axisElementsGroup.clear()\r\n        }\r\n        this._axisLineGroup && this._axisLineGroup.clear();\r\n        this._axisStripGroup && this._axisStripGroup.clear();\r\n        this._axisGridGroup && this._axisGridGroup.clear();\r\n        this._axisConstantLineGroups.above.clear();\r\n        this._axisConstantLineGroups.under.clear();\r\n        this._axisStripLabelGroup && this._axisStripLabelGroup.clear()\r\n    },\r\n    _getLabelFormatObject: function(value, labelOptions, range, point, tickInterval, ticks) {\r\n        range = range || this._getViewportRange();\r\n        var formatObject = {\r\n            value: value,\r\n            valueText: _format(value, {\r\n                labelOptions: labelOptions,\r\n                ticks: ticks || convertTicksToValues(this._majorTicks),\r\n                tickInterval: null !== tickInterval && void 0 !== tickInterval ? tickInterval : this._tickInterval,\r\n                dataType: this._options.dataType,\r\n                logarithmBase: this._options.logarithmBase,\r\n                type: this._options.type,\r\n                showTransition: !this._options.marker.visible,\r\n                point: point\r\n            }) || \"\",\r\n            min: range.minVisible,\r\n            max: range.maxVisible\r\n        };\r\n        if (point) {\r\n            formatObject.point = point\r\n        }\r\n        return formatObject\r\n    },\r\n    formatLabel: function(value, labelOptions, range, point, tickInterval, ticks) {\r\n        var formatObject = this._getLabelFormatObject(value, labelOptions, range, point, tickInterval, ticks);\r\n        return isFunction(labelOptions.customizeText) ? labelOptions.customizeText.call(formatObject, formatObject) : formatObject.valueText\r\n    },\r\n    formatHint: function(value, labelOptions, range) {\r\n        var formatObject = this._getLabelFormatObject(value, labelOptions, range);\r\n        return isFunction(labelOptions.customizeHint) ? labelOptions.customizeHint.call(formatObject, formatObject) : void 0\r\n    },\r\n    formatRange(startValue, endValue, interval, argumentFormat) {\r\n        return formatRange({\r\n            startValue: startValue,\r\n            endValue: endValue,\r\n            tickInterval: interval,\r\n            argumentFormat: argumentFormat,\r\n            axisOptions: this.getOptions()\r\n        })\r\n    },\r\n    _setTickOffset: function() {\r\n        var options = this._options;\r\n        var discreteAxisDivisionMode = options.discreteAxisDivisionMode;\r\n        this._tickOffset = +(\"crossLabels\" !== discreteAxisDivisionMode || !discreteAxisDivisionMode)\r\n    },\r\n    aggregatedPointBetweenTicks() {\r\n        return \"crossTicks\" === this._options.aggregatedPointsPosition\r\n    },\r\n    resetApplyingAnimation: function(isFirstDrawing) {\r\n        this._resetApplyingAnimation = true;\r\n        if (isFirstDrawing) {\r\n            this._firstDrawing = true\r\n        }\r\n    },\r\n    isFirstDrawing() {\r\n        return this._firstDrawing\r\n    },\r\n    getMargins: function() {\r\n        var that = this;\r\n        var {\r\n            position: position,\r\n            offset: offset,\r\n            customPosition: customPosition,\r\n            placeholderSize: placeholderSize,\r\n            grid: grid,\r\n            tick: tick,\r\n            crosshairMargin: crosshairMargin\r\n        } = that._options;\r\n        var isDefinedCustomPositionOption = isDefined(customPosition);\r\n        var boundaryPosition = that.getResolvedBoundaryPosition();\r\n        var canvas = that.getCanvas();\r\n        var cLeft = canvas.left;\r\n        var cTop = canvas.top;\r\n        var cRight = canvas.width - canvas.right;\r\n        var cBottom = canvas.height - canvas.bottom;\r\n        var edgeMarginCorrection = _max(grid.visible && grid.width || 0, tick.visible && tick.width || 0);\r\n        var constantLineAboveSeries = that._axisConstantLineGroups.above;\r\n        var constantLineUnderSeries = that._axisConstantLineGroups.under;\r\n        var boxes = [that._axisElementsGroup, constantLineAboveSeries.outside1, constantLineAboveSeries.outside2, constantLineUnderSeries.outside1, constantLineUnderSeries.outside2, that._axisLineGroup].map(group => group && group.getBBox()).concat(function(group) {\r\n            var box = group && group.getBBox();\r\n            if (!box || box.isEmpty) {\r\n                return box\r\n            }\r\n            if (that._isHorizontal) {\r\n                box.x = cLeft;\r\n                box.width = cRight - cLeft\r\n            } else {\r\n                box.y = cTop;\r\n                box.height = cBottom - cTop\r\n            }\r\n            return box\r\n        }(that._axisTitleGroup));\r\n        var margins = calculateCanvasMargins(boxes, canvas);\r\n        margins[position] += crosshairMargin;\r\n        if (that.hasNonBoundaryPosition() && isDefinedCustomPositionOption) {\r\n            margins[boundaryPosition] = 0\r\n        }\r\n        if (placeholderSize) {\r\n            margins[position] = placeholderSize\r\n        }\r\n        if (edgeMarginCorrection) {\r\n            if (that._isHorizontal && canvas.right < edgeMarginCorrection && margins.right < edgeMarginCorrection) {\r\n                margins.right = edgeMarginCorrection\r\n            }\r\n            if (!that._isHorizontal && canvas.bottom < edgeMarginCorrection && margins.bottom < edgeMarginCorrection) {\r\n                margins.bottom = edgeMarginCorrection\r\n            }\r\n        }\r\n        if (!isDefinedCustomPositionOption && isDefined(offset)) {\r\n            var moveByOffset = that.customPositionIsBoundary() && (offset > 0 && (boundaryPosition === LEFT || boundaryPosition === TOP) || offset < 0 && (boundaryPosition === RIGHT || boundaryPosition === BOTTOM));\r\n            margins[boundaryPosition] -= moveByOffset ? offset : 0\r\n        }\r\n        return margins\r\n    },\r\n    validateUnit: function(unit, idError, parameters) {\r\n        unit = this.parser(unit);\r\n        if (void 0 === unit && idError) {\r\n            this._incidentOccurred(idError, [parameters])\r\n        }\r\n        return unit\r\n    },\r\n    _setType: function(axisType, drawingType) {\r\n        var axisTypeMethods;\r\n        switch (axisType) {\r\n            case \"xyAxes\":\r\n                axisTypeMethods = xyMethods;\r\n                break;\r\n            case \"polarAxes\":\r\n                axisTypeMethods = polarMethods\r\n        }\r\n        extend(this, axisTypeMethods[drawingType])\r\n    },\r\n    _getSharpParam: function() {\r\n        return true\r\n    },\r\n    _disposeBreaksGroup: _noop,\r\n    dispose: function() {\r\n        [this._axisElementsGroup, this._axisStripGroup, this._axisGroup].forEach((function(g) {\r\n            g.dispose()\r\n        }));\r\n        this._strips = this._title = null;\r\n        this._axisStripGroup = this._axisConstantLineGroups = this._axisStripLabelGroup = this._axisBreaksGroup = null;\r\n        this._axisLineGroup = this._axisElementsGroup = this._axisGridGroup = null;\r\n        this._axisGroup = this._axisTitleGroup = null;\r\n        this._axesContainerGroup = this._stripsGroup = this._constantLinesGroup = this._labelsAxesGroup = null;\r\n        this._renderer = this._options = this._textOptions = this._textFontStyles = null;\r\n        this._translator = null;\r\n        this._majorTicks = this._minorTicks = null;\r\n        this._disposeBreaksGroup();\r\n        this._templatesRendered && this._templatesRendered.reject()\r\n    },\r\n    getOptions: function() {\r\n        return this._options\r\n    },\r\n    setPane: function(pane) {\r\n        this.pane = pane;\r\n        this._options.pane = pane\r\n    },\r\n    setTypes: function(type, axisType, typeSelector) {\r\n        this._options.type = type || this._options.type;\r\n        this._options[typeSelector] = axisType || this._options[typeSelector];\r\n        this._updateTranslator()\r\n    },\r\n    resetTypes: function(typeSelector) {\r\n        this._options.type = this._initTypes.type;\r\n        this._options[typeSelector] = this._initTypes[typeSelector]\r\n    },\r\n    getTranslator: function() {\r\n        return this._translator\r\n    },\r\n    updateOptions: function(options) {\r\n        var that = this;\r\n        var labelOpt = options.label;\r\n        validateAxisOptions(options);\r\n        that._options = options;\r\n        options.tick = options.tick || {};\r\n        options.minorTick = options.minorTick || {};\r\n        options.grid = options.grid || {};\r\n        options.minorGrid = options.minorGrid || {};\r\n        options.title = options.title || {};\r\n        options.marker = options.marker || {};\r\n        that._initTypes = {\r\n            type: options.type,\r\n            argumentType: options.argumentType,\r\n            valueType: options.valueType\r\n        };\r\n        that._setTickOffset();\r\n        that._isHorizontal = options.isHorizontal;\r\n        that.pane = options.pane;\r\n        that.name = options.name;\r\n        that.priority = options.priority;\r\n        that._hasLabelFormat = \"\" !== labelOpt.format && isDefined(labelOpt.format);\r\n        that._textOptions = {\r\n            opacity: labelOpt.opacity,\r\n            align: \"center\",\r\n            class: labelOpt.cssClass\r\n        };\r\n        that._textFontStyles = patchFontOptions(labelOpt.font);\r\n        if (options.type === constants.logarithmic) {\r\n            if (options.logarithmBaseError) {\r\n                that._incidentOccurred(\"E2104\");\r\n                delete options.logarithmBaseError\r\n            }\r\n        }\r\n        that._updateTranslator();\r\n        that._createConstantLines();\r\n        that._strips = (options.strips || []).map(o => createStrip(that, o));\r\n        that._majorTicks = that._minorTicks = null;\r\n        that._firstDrawing = true\r\n    },\r\n    calculateInterval: function(value, prevValue) {\r\n        var options = this._options;\r\n        if (!options || options.type !== constants.logarithmic) {\r\n            return _abs(value - prevValue)\r\n        }\r\n        var {\r\n            allowNegatives: allowNegatives,\r\n            linearThreshold: linearThreshold\r\n        } = new Range(this.getTranslator().getBusinessRange());\r\n        return _abs(getLog(value, options.logarithmBase, allowNegatives, linearThreshold) - getLog(prevValue, options.logarithmBase, allowNegatives, linearThreshold))\r\n    },\r\n    getCanvasRange() {\r\n        var translator = this._translator;\r\n        return {\r\n            startValue: translator.from(translator.translate(\"canvas_position_start\")),\r\n            endValue: translator.from(translator.translate(\"canvas_position_end\"))\r\n        }\r\n    },\r\n    _processCanvas: function(canvas) {\r\n        return canvas\r\n    },\r\n    updateCanvas: function(canvas, canvasRedesign) {\r\n        if (!canvasRedesign) {\r\n            var positions = this._orthogonalPositions = {\r\n                start: !this._isHorizontal ? canvas.left : canvas.top,\r\n                end: !this._isHorizontal ? canvas.width - canvas.right : canvas.height - canvas.bottom\r\n            };\r\n            positions.center = positions.start + (positions.end - positions.start) / 2\r\n        } else {\r\n            this._orthogonalPositions = null\r\n        }\r\n        this._canvas = canvas;\r\n        this._translator.updateCanvas(this._processCanvas(canvas));\r\n        this._initAxisPositions()\r\n    },\r\n    getCanvas: function() {\r\n        return this._canvas\r\n    },\r\n    getAxisShift() {\r\n        return this._axisShift || 0\r\n    },\r\n    hideTitle: function() {\r\n        if (this._options.title.text) {\r\n            this._incidentOccurred(\"W2105\", [this._isHorizontal ? \"horizontal\" : \"vertical\"]);\r\n            this._axisTitleGroup.clear()\r\n        }\r\n    },\r\n    getTitle: function() {\r\n        return this._title\r\n    },\r\n    hideOuterElements: function() {\r\n        var options = this._options;\r\n        if ((options.label.visible || this._outsideConstantLines.length) && !this._translator.getBusinessRange().isEmpty()) {\r\n            this._incidentOccurred(\"W2106\", [this._isHorizontal ? \"horizontal\" : \"vertical\"]);\r\n            this._axisElementsGroup.clear();\r\n            callAction(this._outsideConstantLines, \"removeLabel\")\r\n        }\r\n    },\r\n    _resolveLogarithmicOptionsForRange(range) {\r\n        var options = this._options;\r\n        if (options.type === constants.logarithmic) {\r\n            range.addRange({\r\n                allowNegatives: void 0 !== options.allowNegatives ? options.allowNegatives : range.min <= 0\r\n            });\r\n            if (!isNaN(options.linearThreshold)) {\r\n                range.linearThreshold = options.linearThreshold\r\n            }\r\n        }\r\n    },\r\n    adjustViewport(businessRange) {\r\n        var options = this._options;\r\n        var isDiscrete = options.type === constants.discrete;\r\n        var categories = this._seriesData && this._seriesData.categories || [];\r\n        var wholeRange = this.adjustRange(getVizRangeObject(options.wholeRange));\r\n        var visualRange = this.getViewport() || {};\r\n        var result = new Range(businessRange);\r\n        this._addConstantLinesToRange(result, \"minVisible\", \"maxVisible\");\r\n        var minDefined = isDefined(visualRange.startValue);\r\n        var maxDefined = isDefined(visualRange.endValue);\r\n        if (!isDiscrete) {\r\n            minDefined = minDefined && (!isDefined(wholeRange.endValue) || visualRange.startValue < wholeRange.endValue);\r\n            maxDefined = maxDefined && (!isDefined(wholeRange.startValue) || visualRange.endValue > wholeRange.startValue)\r\n        }\r\n        var minVisible = minDefined ? visualRange.startValue : result.minVisible;\r\n        var maxVisible = maxDefined ? visualRange.endValue : result.maxVisible;\r\n        if (!isDiscrete) {\r\n            var _wholeRange$startValu, _wholeRange$endValue;\r\n            result.min = null !== (_wholeRange$startValu = wholeRange.startValue) && void 0 !== _wholeRange$startValu ? _wholeRange$startValu : result.min;\r\n            result.max = null !== (_wholeRange$endValue = wholeRange.endValue) && void 0 !== _wholeRange$endValue ? _wholeRange$endValue : result.max\r\n        } else {\r\n            var categoriesInfo = getCategoriesInfo(categories, wholeRange.startValue, wholeRange.endValue);\r\n            categories = categoriesInfo.categories;\r\n            result.categories = categories\r\n        }\r\n        var adjustedVisualRange = adjustVisualRange({\r\n            axisType: options.type,\r\n            dataType: options.dataType,\r\n            base: options.logarithmBase\r\n        }, {\r\n            startValue: minDefined ? visualRange.startValue : void 0,\r\n            endValue: maxDefined ? visualRange.endValue : void 0,\r\n            length: visualRange.length\r\n        }, {\r\n            categories: categories,\r\n            min: wholeRange.startValue,\r\n            max: wholeRange.endValue\r\n        }, {\r\n            categories: categories,\r\n            min: minVisible,\r\n            max: maxVisible\r\n        });\r\n        result.minVisible = adjustedVisualRange.startValue;\r\n        result.maxVisible = adjustedVisualRange.endValue;\r\n        !isDefined(result.min) && (result.min = result.minVisible);\r\n        !isDefined(result.max) && (result.max = result.maxVisible);\r\n        result.addRange({});\r\n        this._resolveLogarithmicOptionsForRange(result);\r\n        return result\r\n    },\r\n    adjustRange(range) {\r\n        range = range || {};\r\n        var isDiscrete = this._options.type === constants.discrete;\r\n        var isLogarithmic = this._options.type === constants.logarithmic;\r\n        var disabledNegatives = false === this._options.allowNegatives;\r\n        if (isLogarithmic) {\r\n            range.startValue = disabledNegatives && range.startValue <= 0 ? null : range.startValue;\r\n            range.endValue = disabledNegatives && range.endValue <= 0 ? null : range.endValue\r\n        }\r\n        if (!isDiscrete && isDefined(range.startValue) && isDefined(range.endValue) && range.startValue > range.endValue) {\r\n            var tmp = range.endValue;\r\n            range.endValue = range.startValue;\r\n            range.startValue = tmp\r\n        }\r\n        return range\r\n    },\r\n    _getVisualRangeUpdateMode(viewport, newRange, oppositeValue) {\r\n        var value = this._options.visualRangeUpdateMode;\r\n        var translator = this._translator;\r\n        var range = this._seriesData;\r\n        var prevDataInfo = this._prevDataInfo;\r\n        if (prevDataInfo.isEmpty && !prevDataInfo.containsConstantLine) {\r\n            return KEEP\r\n        }\r\n        if (!this.isArgumentAxis) {\r\n            var _viewport = this.getViewport();\r\n            if (!isDefined(_viewport.startValue) && !isDefined(_viewport.endValue) && !isDefined(_viewport.length)) {\r\n                return RESET\r\n            }\r\n        }\r\n        if (this.isArgumentAxis) {\r\n            if (-1 === [SHIFT, KEEP, RESET].indexOf(value)) {\r\n                if (range.axisType === constants.discrete) {\r\n                    var categories = range.categories;\r\n                    var newCategories = newRange.categories;\r\n                    var visualRange = this.visualRange();\r\n                    if (categories && newCategories && categories.length && -1 !== newCategories.map(c => c.valueOf()).join(\",\").indexOf(categories.map(c => c.valueOf()).join(\",\")) && (visualRange.startValue.valueOf() !== categories[0].valueOf() || visualRange.endValue.valueOf() !== categories[categories.length - 1].valueOf())) {\r\n                        value = KEEP\r\n                    } else {\r\n                        value = RESET\r\n                    }\r\n                } else {\r\n                    var minPoint = translator.translate(range.min);\r\n                    var minVisiblePoint = translator.translate(viewport.startValue);\r\n                    var maxPoint = translator.translate(range.max);\r\n                    var maxVisiblePoint = translator.translate(viewport.endValue);\r\n                    if (minPoint === minVisiblePoint && maxPoint === maxVisiblePoint) {\r\n                        value = RESET\r\n                    } else if (minPoint !== minVisiblePoint && maxPoint === maxVisiblePoint) {\r\n                        value = SHIFT\r\n                    } else {\r\n                        value = KEEP\r\n                    }\r\n                }\r\n                if (value === KEEP && prevDataInfo.isEmpty && prevDataInfo.containsConstantLine) {\r\n                    value = RESET\r\n                }\r\n            }\r\n        } else if (-1 === [KEEP, RESET].indexOf(value)) {\r\n            if (oppositeValue === KEEP) {\r\n                value = KEEP\r\n            } else {\r\n                value = RESET\r\n            }\r\n        }\r\n        return value\r\n    },\r\n    _handleBusinessRangeChanged(oppositeVisualRangeUpdateMode, axisReinitialized, newRange) {\r\n        var visualRange = this.visualRange();\r\n        if (axisReinitialized || this._translator.getBusinessRange().isEmpty()) {\r\n            return\r\n        }\r\n        var visualRangeUpdateMode = this._lastVisualRangeUpdateMode = this._getVisualRangeUpdateMode(visualRange, newRange, oppositeVisualRangeUpdateMode);\r\n        if (visualRangeUpdateMode === KEEP) {\r\n            this._setVisualRange([visualRange.startValue, visualRange.endValue])\r\n        } else if (visualRangeUpdateMode === RESET) {\r\n            this._setVisualRange([null, null])\r\n        } else if (visualRangeUpdateMode === SHIFT) {\r\n            this._setVisualRange({\r\n                length: this.getVisualRangeLength()\r\n            })\r\n        }\r\n    },\r\n    getVisualRangeLength(range) {\r\n        var currentBusinessRange = range || this._translator.getBusinessRange();\r\n        var {\r\n            type: type\r\n        } = this._options;\r\n        var length;\r\n        if (type === constants.logarithmic) {\r\n            length = adjust(this.calculateInterval(currentBusinessRange.maxVisible, currentBusinessRange.minVisible))\r\n        } else if (type === constants.discrete) {\r\n            var categoriesInfo = getCategoriesInfo(currentBusinessRange.categories, currentBusinessRange.minVisible, currentBusinessRange.maxVisible);\r\n            length = categoriesInfo.categories.length\r\n        } else {\r\n            length = currentBusinessRange.maxVisible - currentBusinessRange.minVisible\r\n        }\r\n        return length\r\n    },\r\n    getVisualRangeCenter(range, useMerge) {\r\n        var translator = this.getTranslator();\r\n        var businessRange = translator.getBusinessRange();\r\n        var currentBusinessRange = useMerge ? extend(true, {}, businessRange, range || {}) : range || businessRange;\r\n        var {\r\n            type: type,\r\n            logarithmBase: logarithmBase\r\n        } = this._options;\r\n        var center;\r\n        if (!isDefined(currentBusinessRange.minVisible) || !isDefined(currentBusinessRange.maxVisible)) {\r\n            return\r\n        }\r\n        if (type === constants.logarithmic) {\r\n            var {\r\n                allowNegatives: allowNegatives,\r\n                linearThreshold: linearThreshold,\r\n                minVisible: minVisible,\r\n                maxVisible: maxVisible\r\n            } = currentBusinessRange;\r\n            center = raiseTo(adjust(getLog(maxVisible, logarithmBase, allowNegatives, linearThreshold) + getLog(minVisible, logarithmBase, allowNegatives, linearThreshold)) / 2, logarithmBase, allowNegatives, linearThreshold)\r\n        } else if (type === constants.discrete) {\r\n            var categoriesInfo = getCategoriesInfo(currentBusinessRange.categories, currentBusinessRange.minVisible, currentBusinessRange.maxVisible);\r\n            var index = Math.ceil(categoriesInfo.categories.length / 2) - 1;\r\n            center = businessRange.categories.indexOf(categoriesInfo.categories[index])\r\n        } else {\r\n            center = translator.toValue((currentBusinessRange.maxVisible.valueOf() + currentBusinessRange.minVisible.valueOf()) / 2)\r\n        }\r\n        return center\r\n    },\r\n    setBusinessRange(range, axisReinitialized, oppositeVisualRangeUpdateMode, argCategories) {\r\n        var _that$_seriesData$min, _that$_seriesData$max;\r\n        var options = this._options;\r\n        var isDiscrete = options.type === constants.discrete;\r\n        this._handleBusinessRangeChanged(oppositeVisualRangeUpdateMode, axisReinitialized, range);\r\n        this._seriesData = new Range(range);\r\n        var dataIsEmpty = this._seriesData.isEmpty();\r\n        var rangeWithConstantLines = new Range(this._seriesData);\r\n        this._addConstantLinesToRange(rangeWithConstantLines, \"minVisible\", \"maxVisible\");\r\n        this._prevDataInfo = {\r\n            isEmpty: dataIsEmpty,\r\n            containsConstantLine: rangeWithConstantLines.containsConstantLine\r\n        };\r\n        this._seriesData.addRange({\r\n            categories: options.categories,\r\n            dataType: options.dataType,\r\n            axisType: options.type,\r\n            base: options.logarithmBase,\r\n            invert: options.inverted\r\n        });\r\n        this._resolveLogarithmicOptionsForRange(this._seriesData);\r\n        if (!isDiscrete) {\r\n            if (!isDefined(this._seriesData.min) && !isDefined(this._seriesData.max)) {\r\n                var visualRange = this.getViewport();\r\n                visualRange && this._seriesData.addRange({\r\n                    min: visualRange.startValue,\r\n                    max: visualRange.endValue\r\n                })\r\n            }\r\n            var synchronizedValue = options.synchronizedValue;\r\n            if (isDefined(synchronizedValue)) {\r\n                this._seriesData.addRange({\r\n                    min: synchronizedValue,\r\n                    max: synchronizedValue\r\n                })\r\n            }\r\n        }\r\n        this._seriesData.minVisible = null !== (_that$_seriesData$min = this._seriesData.minVisible) && void 0 !== _that$_seriesData$min ? _that$_seriesData$min : this._seriesData.min;\r\n        this._seriesData.maxVisible = null !== (_that$_seriesData$max = this._seriesData.maxVisible) && void 0 !== _that$_seriesData$max ? _that$_seriesData$max : this._seriesData.max;\r\n        if (!this.isArgumentAxis && options.showZero) {\r\n            this._seriesData.correctValueZeroLevel()\r\n        }\r\n        this._seriesData.sortCategories(this.getCategoriesSorter(argCategories));\r\n        this._seriesData.userBreaks = this._seriesData.isEmpty() ? [] : this._getScaleBreaks(options, this._seriesData, this._series, this.isArgumentAxis);\r\n        this._translator.updateBusinessRange(this._getViewportRange())\r\n    },\r\n    _addConstantLinesToRange(dataRange, minValueField, maxValueField) {\r\n        this._outsideConstantLines.concat(this._insideConstantLines || []).forEach(cl => {\r\n            if (cl.options.extendAxis) {\r\n                var value = cl.getParsedValue();\r\n                dataRange.addRange({\r\n                    containsConstantLine: true,\r\n                    [minValueField]: value,\r\n                    [maxValueField]: value\r\n                })\r\n            }\r\n        })\r\n    },\r\n    setGroupSeries: function(series) {\r\n        this._series = series\r\n    },\r\n    getLabelsPosition: function() {\r\n        var options = this._options;\r\n        var position = options.position;\r\n        var labelShift = options.label.indentFromAxis + (this._axisShift || 0) + this._constantLabelOffset;\r\n        var axisPosition = this._axisPosition;\r\n        return position === TOP || position === LEFT ? axisPosition - labelShift : axisPosition + labelShift\r\n    },\r\n    getFormattedValue: function(value, options, point) {\r\n        var labelOptions = this._options.label;\r\n        return isDefined(value) ? this.formatLabel(value, extend(true, {}, labelOptions, options), void 0, point) : null\r\n    },\r\n    _getBoundaryTicks: function(majors, viewPort) {\r\n        var length = majors.length;\r\n        var options = this._options;\r\n        var customBounds = options.customBoundTicks;\r\n        var min = viewPort.minVisible;\r\n        var max = viewPort.maxVisible;\r\n        var addMinMax = options.showCustomBoundaryTicks ? this._boundaryTicksVisibility : {};\r\n        var boundaryTicks = [];\r\n        if (options.type === constants.discrete) {\r\n            if (this._tickOffset && 0 !== majors.length) {\r\n                boundaryTicks = [majors[0], majors[majors.length - 1]]\r\n            }\r\n        } else if (customBounds) {\r\n            if (addMinMax.min && isDefined(customBounds[0])) {\r\n                boundaryTicks.push(customBounds[0])\r\n            }\r\n            if (addMinMax.max && isDefined(customBounds[1])) {\r\n                boundaryTicks.push(customBounds[1])\r\n            }\r\n        } else {\r\n            if (addMinMax.min && (0 === length || majors[0] > min)) {\r\n                boundaryTicks.push(min)\r\n            }\r\n            if (addMinMax.max && (0 === length || majors[length - 1] < max)) {\r\n                boundaryTicks.push(max)\r\n            }\r\n        }\r\n        return boundaryTicks\r\n    },\r\n    setPercentLabelFormat: function() {\r\n        if (!this._hasLabelFormat) {\r\n            this._options.label.format = \"percent\"\r\n        }\r\n    },\r\n    resetAutoLabelFormat: function() {\r\n        if (!this._hasLabelFormat) {\r\n            delete this._options.label.format\r\n        }\r\n    },\r\n    getMultipleAxesSpacing: function() {\r\n        return this._options.multipleAxesSpacing || 0\r\n    },\r\n    getTicksValues: function() {\r\n        return {\r\n            majorTicksValues: convertTicksToValues(this._majorTicks),\r\n            minorTicksValues: convertTicksToValues(this._minorTicks)\r\n        }\r\n    },\r\n    estimateTickInterval: function(canvas) {\r\n        this.updateCanvas(canvas);\r\n        return this._tickInterval !== this._getTicks(this._getViewportRange(), _noop, true).tickInterval\r\n    },\r\n    setTicks: function(ticks) {\r\n        var majors = ticks.majorTicks || [];\r\n        this._majorTicks = majors.map(createMajorTick(this, this._renderer, this._getSkippedCategory(majors)));\r\n        this._minorTicks = (ticks.minorTicks || []).map(createMinorTick(this, this._renderer));\r\n        this._isSynchronized = true\r\n    },\r\n    _adjustDivisionFactor: function(val) {\r\n        return val\r\n    },\r\n    _getTicks: function(viewPort, incidentOccurred, skipTickGeneration) {\r\n        var options = this._options;\r\n        var customTicks = options.customTicks;\r\n        var customMinorTicks = options.customMinorTicks;\r\n        return getTickGenerator(options, incidentOccurred || this._incidentOccurred, skipTickGeneration, this._translator.getBusinessRange().isEmpty(), this._adjustDivisionFactor.bind(this), viewPort)({\r\n            min: viewPort.minVisible,\r\n            max: viewPort.maxVisible,\r\n            categories: viewPort.categories,\r\n            isSpacedMargin: viewPort.isSpacedMargin\r\n        }, this._getScreenDelta(), options.tickInterval, \"ignore\" === options.label.overlappingBehavior || options.forceUserTickInterval, {\r\n            majors: customTicks,\r\n            minors: customMinorTicks\r\n        }, options.minorTickInterval, options.minorTickCount, this._initialBreaks)\r\n    },\r\n    _createTicksAndLabelFormat: function(range, incidentOccurred) {\r\n        var options = this._options;\r\n        var ticks = this._getTicks(range, incidentOccurred, false);\r\n        if (!range.isEmpty() && options.type === constants.discrete && \"datetime\" === options.dataType && !this._hasLabelFormat && ticks.ticks.length) {\r\n            options.label.format = formatHelper.getDateFormatByTicks(ticks.ticks)\r\n        }\r\n        return ticks\r\n    },\r\n    getAggregationInfo(useAllAggregatedPoints, range) {\r\n        var _visualRange$startVal, _visualRange$endValue, _that$_seriesData;\r\n        var options = this._options;\r\n        var marginOptions = this._marginOptions;\r\n        var businessRange = new Range(this.getTranslator().getBusinessRange()).addRange(range);\r\n        var visualRange = this.getViewport();\r\n        var minVisible = null !== (_visualRange$startVal = null === visualRange || void 0 === visualRange ? void 0 : visualRange.startValue) && void 0 !== _visualRange$startVal ? _visualRange$startVal : businessRange.minVisible;\r\n        var maxVisible = null !== (_visualRange$endValue = null === visualRange || void 0 === visualRange ? void 0 : visualRange.endValue) && void 0 !== _visualRange$endValue ? _visualRange$endValue : businessRange.maxVisible;\r\n        var ticks = [];\r\n        if (options.type === constants.discrete && options.aggregateByCategory) {\r\n            return {\r\n                aggregateByCategory: true\r\n            }\r\n        }\r\n        var aggregationInterval = options.aggregationInterval;\r\n        var aggregationGroupWidth = options.aggregationGroupWidth;\r\n        if (!aggregationGroupWidth && marginOptions) {\r\n            if (marginOptions.checkInterval) {\r\n                aggregationGroupWidth = options.axisDivisionFactor\r\n            }\r\n            if (marginOptions.sizePointNormalState) {\r\n                aggregationGroupWidth = Math.min(marginOptions.sizePointNormalState, options.axisDivisionFactor)\r\n            }\r\n        }\r\n        var minInterval = !options.aggregationGroupWidth && !aggregationInterval && range.interval;\r\n        var generateTicks = configureGenerator(options, aggregationGroupWidth, businessRange, this._getScreenDelta(), minInterval);\r\n        var tickInterval = generateTicks(aggregationInterval, true, minVisible, maxVisible, null === (_that$_seriesData = this._seriesData) || void 0 === _that$_seriesData ? void 0 : _that$_seriesData.breaks).tickInterval;\r\n        if (options.type !== constants.discrete) {\r\n            var min = useAllAggregatedPoints ? businessRange.min : minVisible;\r\n            var max = useAllAggregatedPoints ? businessRange.max : maxVisible;\r\n            if (isDefined(min) && isDefined(max)) {\r\n                var add = getAddFunction({\r\n                    base: options.logarithmBase,\r\n                    axisType: options.type,\r\n                    dataType: options.dataType\r\n                }, false);\r\n                var start = min;\r\n                var end = max;\r\n                if (!useAllAggregatedPoints) {\r\n                    var maxMinDistance = Math.max(this.calculateInterval(max, min), \"datetime\" === options.dataType ? dateUtils.dateToMilliseconds(tickInterval) : tickInterval);\r\n                    start = add(min, maxMinDistance, -1);\r\n                    end = add(max, maxMinDistance)\r\n                }\r\n                start = start < businessRange.min ? businessRange.min : start;\r\n                end = end > businessRange.max ? businessRange.max : end;\r\n                var breaks = this._getScaleBreaks(options, {\r\n                    minVisible: start,\r\n                    maxVisible: end\r\n                }, this._series, this.isArgumentAxis);\r\n                var filteredBreaks = this._filterBreaks(breaks, {\r\n                    minVisible: start,\r\n                    maxVisible: end\r\n                }, options.breakStyle);\r\n                ticks = generateTicks(tickInterval, false, start, end, filteredBreaks).ticks\r\n            }\r\n        }\r\n        this._aggregationInterval = tickInterval;\r\n        return {\r\n            interval: tickInterval,\r\n            ticks: ticks\r\n        }\r\n    },\r\n    getTickInterval() {\r\n        return this._tickInterval\r\n    },\r\n    getAggregationInterval() {\r\n        return this._aggregationInterval\r\n    },\r\n    createTicks: function(canvas) {\r\n        var that = this;\r\n        var renderer = that._renderer;\r\n        var options = that._options;\r\n        if (!canvas) {\r\n            return\r\n        }\r\n        that._isSynchronized = false;\r\n        that.updateCanvas(canvas);\r\n        var range = that._getViewportRange();\r\n        that._initialBreaks = range.breaks = this._seriesData.breaks = that._filterBreaks(this._seriesData.userBreaks, range, options.breakStyle);\r\n        that._estimatedTickInterval = that._getTicks(that.adjustViewport(this._seriesData), _noop, true).tickInterval;\r\n        var margins = this._calculateValueMargins();\r\n        range.addRange({\r\n            minVisible: margins.minValue,\r\n            maxVisible: margins.maxValue,\r\n            isSpacedMargin: margins.isSpacedMargin\r\n        });\r\n        var ticks = that._createTicksAndLabelFormat(range);\r\n        var boundaryTicks = that._getBoundaryTicks(ticks.ticks, that._getViewportRange());\r\n        if (options.showCustomBoundaryTicks && boundaryTicks.length) {\r\n            that._boundaryTicks = [boundaryTicks[0]].map(createBoundaryTick(that, renderer, true));\r\n            if (boundaryTicks.length > 1) {\r\n                that._boundaryTicks = that._boundaryTicks.concat([boundaryTicks[1]].map(createBoundaryTick(that, renderer, false)))\r\n            }\r\n        } else {\r\n            that._boundaryTicks = []\r\n        }\r\n        var minors = (ticks.minorTicks || []).filter((function(minor) {\r\n            return !boundaryTicks.some((function(boundary) {\r\n                return valueOf(boundary) === valueOf(minor)\r\n            }))\r\n        }));\r\n        that._tickInterval = ticks.tickInterval;\r\n        that._minorTickInterval = ticks.minorTickInterval;\r\n        var oldMajorTicks = that._majorTicks || [];\r\n        var majorTicksByValues = oldMajorTicks.reduce((r, t) => {\r\n            r[t.value.valueOf()] = t;\r\n            return r\r\n        }, {});\r\n        var sameType = type(ticks.ticks[0]) === type(oldMajorTicks[0] && oldMajorTicks[0].value);\r\n        var skippedCategory = that._getSkippedCategory(ticks.ticks);\r\n        var majorTicks = ticks.ticks.map(v => {\r\n            var tick = majorTicksByValues[v.valueOf()];\r\n            if (tick && sameType) {\r\n                delete majorTicksByValues[v.valueOf()];\r\n                tick.setSkippedCategory(skippedCategory);\r\n                return tick\r\n            } else {\r\n                return createMajorTick(that, renderer, skippedCategory)(v)\r\n            }\r\n        });\r\n        that._majorTicks = majorTicks;\r\n        var oldMinorTicks = that._minorTicks || [];\r\n        that._minorTicks = minors.map((v, i) => {\r\n            var minorTick = oldMinorTicks[i];\r\n            if (minorTick) {\r\n                minorTick.updateValue(v);\r\n                return minorTick\r\n            }\r\n            return createMinorTick(that, renderer)(v)\r\n        });\r\n        that._ticksToRemove = Object.keys(majorTicksByValues).map(k => majorTicksByValues[k]).concat(oldMinorTicks.slice(that._minorTicks.length, oldMinorTicks.length));\r\n        that._ticksToRemove.forEach(t => {\r\n            var _t$label;\r\n            return null === (_t$label = t.label) || void 0 === _t$label ? void 0 : _t$label.removeTitle()\r\n        });\r\n        if (ticks.breaks) {\r\n            that._seriesData.breaks = ticks.breaks\r\n        }\r\n        that._reinitTranslator(that._getViewportRange())\r\n    },\r\n    _reinitTranslator: function(range) {\r\n        var translator = this._translator;\r\n        if (this._isSynchronized) {\r\n            return\r\n        }\r\n        translator.updateBusinessRange(range)\r\n    },\r\n    _getViewportRange() {\r\n        return this.adjustViewport(this._seriesData)\r\n    },\r\n    setMarginOptions: function(options) {\r\n        this._marginOptions = options\r\n    },\r\n    getMarginOptions() {\r\n        var _this$_marginOptions;\r\n        return null !== (_this$_marginOptions = this._marginOptions) && void 0 !== _this$_marginOptions ? _this$_marginOptions : {}\r\n    },\r\n    _calculateRangeInterval: function(interval) {\r\n        var isDateTime = \"datetime\" === this._options.dataType;\r\n        var minArgs = [];\r\n        var addToArgs = function(value) {\r\n            isDefined(value) && minArgs.push(isDateTime ? dateUtils.dateToMilliseconds(value) : value)\r\n        };\r\n        addToArgs(this._tickInterval);\r\n        addToArgs(this._estimatedTickInterval);\r\n        isDefined(interval) && minArgs.push(interval);\r\n        addToArgs(this._aggregationInterval);\r\n        return this._calculateWorkWeekInterval(_min.apply(this, minArgs))\r\n    },\r\n    _calculateWorkWeekInterval(businessInterval) {\r\n        var options = this._options;\r\n        if (\"datetime\" === options.dataType && options.workdaysOnly && businessInterval) {\r\n            var workWeek = options.workWeek.length * dateIntervals.day;\r\n            var weekend = dateIntervals.week - workWeek;\r\n            if (workWeek !== businessInterval && weekend < businessInterval) {\r\n                var weekendsCount = Math.ceil(businessInterval / dateIntervals.week);\r\n                businessInterval -= weekend * weekendsCount\r\n            } else if (weekend >= businessInterval && businessInterval > dateIntervals.day) {\r\n                businessInterval = dateIntervals.day\r\n            }\r\n        }\r\n        return businessInterval\r\n    },\r\n    _getConvertIntervalCoefficient(intervalInPx, screenDelta) {\r\n        var ratioOfCanvasRange = this._translator.ratioOfCanvasRange();\r\n        return ratioOfCanvasRange / (ratioOfCanvasRange * screenDelta / (intervalInPx + screenDelta))\r\n    },\r\n    _calculateValueMargins(ticks) {\r\n        this._resetMargins();\r\n        var margins = this.getMarginOptions();\r\n        var marginSize = (margins.size || 0) / 2;\r\n        var options = this._options;\r\n        var dataRange = this._getViewportRange();\r\n        var viewPort = this.getViewport();\r\n        var screenDelta = this._getScreenDelta();\r\n        var isDiscrete = -1 !== (options.type || \"\").indexOf(constants.discrete);\r\n        var valueMarginsEnabled = options.valueMarginsEnabled && !isDiscrete && !this.customPositionIsBoundaryOrthogonalAxis();\r\n        var translator = this._translator;\r\n        var minValueMargin = options.minValueMargin;\r\n        var maxValueMargin = options.maxValueMargin;\r\n        var minPadding = 0;\r\n        var maxPadding = 0;\r\n        var interval = 0;\r\n        var rangeInterval;\r\n        if (dataRange.stubData || !screenDelta) {\r\n            return {\r\n                startPadding: 0,\r\n                endPadding: 0\r\n            }\r\n        }\r\n        if (this.isArgumentAxis && margins.checkInterval) {\r\n            rangeInterval = this._calculateRangeInterval(dataRange.interval);\r\n            var pxInterval = translator.getInterval(rangeInterval);\r\n            if (isFinite(pxInterval)) {\r\n                interval = Math.ceil(pxInterval / (2 * this._getConvertIntervalCoefficient(pxInterval, screenDelta)))\r\n            } else {\r\n                rangeInterval = 0\r\n            }\r\n        }\r\n        var minPercentPadding;\r\n        var maxPercentPadding;\r\n        var maxPaddingValue = screenDelta * MAX_MARGIN_VALUE / 2;\r\n        if (valueMarginsEnabled) {\r\n            if (isDefined(minValueMargin)) {\r\n                minPercentPadding = isFinite(minValueMargin) ? minValueMargin : 0\r\n            } else if (!this.isArgumentAxis && margins.checkInterval && valueOf(dataRange.minVisible) > 0 && valueOf(dataRange.minVisible) === valueOf(dataRange.min)) {\r\n                minPadding = MIN_BAR_MARGIN\r\n            } else {\r\n                minPadding = Math.max(marginSize, interval);\r\n                minPadding = Math.min(maxPaddingValue, minPadding)\r\n            }\r\n            if (isDefined(maxValueMargin)) {\r\n                maxPercentPadding = isFinite(maxValueMargin) ? maxValueMargin : 0\r\n            } else if (!this.isArgumentAxis && margins.checkInterval && valueOf(dataRange.maxVisible) < 0 && valueOf(dataRange.maxVisible) === valueOf(dataRange.max)) {\r\n                maxPadding = MIN_BAR_MARGIN\r\n            } else {\r\n                maxPadding = Math.max(marginSize, interval);\r\n                maxPadding = Math.min(maxPaddingValue, maxPadding)\r\n            }\r\n        }\r\n        var percentStick = margins.percentStick && !this.isArgumentAxis;\r\n        if (percentStick) {\r\n            if (1 === _abs(dataRange.max)) {\r\n                maxPadding = 0\r\n            }\r\n            if (1 === _abs(dataRange.min)) {\r\n                minPadding = 0\r\n            }\r\n        }\r\n        var canvasStartEnd = this._getCanvasStartEnd();\r\n        var commonMargin = 1 + (minPercentPadding || 0) + (maxPercentPadding || 0);\r\n        var screenDeltaWithMargins = (screenDelta - minPadding - maxPadding) / commonMargin || screenDelta;\r\n        if (void 0 !== minPercentPadding || void 0 !== maxPercentPadding) {\r\n            if (void 0 !== minPercentPadding) {\r\n                minPadding = screenDeltaWithMargins * minPercentPadding\r\n            }\r\n            if (void 0 !== maxPercentPadding) {\r\n                maxPadding = screenDeltaWithMargins * maxPercentPadding\r\n            }\r\n        }\r\n        var minValue;\r\n        var maxValue;\r\n        if (options.type !== constants.discrete && ticks && ticks.length > 1 && !options.skipViewportExtending && !viewPort.action && false !== options.endOnTick) {\r\n            var length = ticks.length;\r\n            var firstTickPosition = translator.translate(ticks[0].value);\r\n            var lastTickPosition = translator.translate(ticks[length - 1].value);\r\n            var invertMultiplier = firstTickPosition > lastTickPosition ? -1 : 1;\r\n            var minTickPadding = _max(invertMultiplier * (canvasStartEnd.start - firstTickPosition), 0);\r\n            var maxTickPadding = _max(invertMultiplier * (lastTickPosition - canvasStartEnd.end), 0);\r\n            if (minTickPadding > minPadding || maxTickPadding > maxPadding) {\r\n                var commonPadding = maxTickPadding + minTickPadding;\r\n                var coeff = this._getConvertIntervalCoefficient(commonPadding, screenDelta);\r\n                if (minTickPadding >= minPadding) {\r\n                    minValue = ticks[0].value\r\n                }\r\n                if (maxTickPadding >= maxPadding) {\r\n                    maxValue = ticks[length - 1].value\r\n                }\r\n                minPadding = _max(minTickPadding, minPadding) / coeff;\r\n                maxPadding = _max(maxTickPadding, maxPadding) / coeff\r\n            }\r\n        }\r\n        minPercentPadding = void 0 === minPercentPadding ? minPadding / screenDeltaWithMargins : minPercentPadding;\r\n        maxPercentPadding = void 0 === maxPercentPadding ? maxPadding / screenDeltaWithMargins : maxPercentPadding;\r\n        if (!isDiscrete) {\r\n            if (this._translator.isInverted()) {\r\n                var _minValue, _maxValue;\r\n                minValue = null !== (_minValue = minValue) && void 0 !== _minValue ? _minValue : translator.from(canvasStartEnd.start + screenDelta * minPercentPadding, -1);\r\n                maxValue = null !== (_maxValue = maxValue) && void 0 !== _maxValue ? _maxValue : translator.from(canvasStartEnd.end - screenDelta * maxPercentPadding, 1)\r\n            } else {\r\n                var _minValue2, _maxValue2;\r\n                minValue = null !== (_minValue2 = minValue) && void 0 !== _minValue2 ? _minValue2 : translator.from(canvasStartEnd.start - screenDelta * minPercentPadding, -1);\r\n                maxValue = null !== (_maxValue2 = maxValue) && void 0 !== _maxValue2 ? _maxValue2 : translator.from(canvasStartEnd.end + screenDelta * maxPercentPadding, 1)\r\n            }\r\n        }\r\n        var {\r\n            correctedMin: correctedMin,\r\n            correctedMax: correctedMax,\r\n            start: start,\r\n            end: end\r\n        } = this.getCorrectedValuesToZero(minValue, maxValue);\r\n        minPadding = null !== start && void 0 !== start ? start : minPadding;\r\n        maxPadding = null !== end && void 0 !== end ? end : maxPadding;\r\n        return {\r\n            startPadding: translator.isInverted() ? maxPadding : minPadding,\r\n            endPadding: translator.isInverted() ? minPadding : maxPadding,\r\n            minValue: null !== correctedMin && void 0 !== correctedMin ? correctedMin : minValue,\r\n            maxValue: null !== correctedMax && void 0 !== correctedMax ? correctedMax : maxValue,\r\n            interval: rangeInterval,\r\n            isSpacedMargin: minPadding === maxPadding && 0 !== minPadding\r\n        }\r\n    },\r\n    getCorrectedValuesToZero(minValue, maxValue) {\r\n        var that = this;\r\n        var translator = that._translator;\r\n        var canvasStartEnd = that._getCanvasStartEnd();\r\n        var dataRange = that._getViewportRange();\r\n        var screenDelta = that._getScreenDelta();\r\n        var options = that._options;\r\n        var start;\r\n        var end;\r\n        var correctedMin;\r\n        var correctedMax;\r\n        var correctZeroLevel = (minPoint, maxPoint) => {\r\n            var minExpectedPadding = _abs(canvasStartEnd.start - minPoint);\r\n            var maxExpectedPadding = _abs(canvasStartEnd.end - maxPoint);\r\n            var coeff = that._getConvertIntervalCoefficient(minExpectedPadding + maxExpectedPadding, screenDelta);\r\n            start = minExpectedPadding / coeff;\r\n            end = maxExpectedPadding / coeff\r\n        };\r\n        if (!that.isArgumentAxis && \"datetime\" !== options.dataType) {\r\n            if (minValue * dataRange.min <= 0 && minValue * dataRange.minVisible <= 0) {\r\n                correctZeroLevel(translator.translate(0), translator.translate(maxValue));\r\n                correctedMin = 0\r\n            }\r\n            if (maxValue * dataRange.max <= 0 && maxValue * dataRange.maxVisible <= 0) {\r\n                correctZeroLevel(translator.translate(minValue), translator.translate(0));\r\n                correctedMax = 0\r\n            }\r\n        }\r\n        return {\r\n            start: isFinite(start) ? start : null,\r\n            end: isFinite(end) ? end : null,\r\n            correctedMin: correctedMin,\r\n            correctedMax: correctedMax\r\n        }\r\n    },\r\n    applyMargins() {\r\n        if (this._isSynchronized) {\r\n            return\r\n        }\r\n        var margins = this._calculateValueMargins(this._majorTicks);\r\n        var canvas = extend({}, this._canvas, {\r\n            startPadding: margins.startPadding,\r\n            endPadding: margins.endPadding\r\n        });\r\n        this._translator.updateCanvas(this._processCanvas(canvas));\r\n        if (isFinite(margins.interval)) {\r\n            var br = this._translator.getBusinessRange();\r\n            br.addRange({\r\n                interval: margins.interval\r\n            });\r\n            this._translator.updateBusinessRange(br)\r\n        }\r\n    },\r\n    _resetMargins: function() {\r\n        this._reinitTranslator(this._getViewportRange());\r\n        if (this._canvas) {\r\n            this._translator.updateCanvas(this._processCanvas(this._canvas))\r\n        }\r\n    },\r\n    _createConstantLines() {\r\n        var constantLines = (this._options.constantLines || []).map(o => createConstantLine(this, o));\r\n        this._outsideConstantLines = constantLines.filter(l => \"outside\" === l.labelPosition);\r\n        this._insideConstantLines = constantLines.filter(l => \"inside\" === l.labelPosition)\r\n    },\r\n    draw: function(canvas, borderOptions) {\r\n        var that = this;\r\n        var options = this._options;\r\n        that.borderOptions = borderOptions || {\r\n            visible: false\r\n        };\r\n        that._resetMargins();\r\n        that.createTicks(canvas);\r\n        that.applyMargins();\r\n        that._clearAxisGroups();\r\n        initTickCoords(that._majorTicks);\r\n        initTickCoords(that._minorTicks);\r\n        initTickCoords(that._boundaryTicks);\r\n        that._axisGroup.append(that._axesContainerGroup);\r\n        that._drawAxis();\r\n        that._drawTitle();\r\n        drawTickMarks(that._majorTicks, options.tick);\r\n        drawTickMarks(that._minorTicks, options.minorTick);\r\n        drawTickMarks(that._boundaryTicks, options.tick);\r\n        var drawGridLine = that._getGridLineDrawer();\r\n        drawGrids(that._majorTicks, drawGridLine);\r\n        drawGrids(that._minorTicks, drawGridLine);\r\n        callAction(that._majorTicks, \"drawLabel\", that._getViewportRange(), that._getTemplate(options.label.template));\r\n        that._templatesRendered && that._templatesRendered.reject();\r\n        that._templatesRendered = new Deferred;\r\n        that._majorTicks.forEach((function(tick) {\r\n            tick.labelRotationAngle = 0;\r\n            tick.labelAlignment = void 0;\r\n            tick.labelOffset = 0\r\n        }));\r\n        callAction(that._outsideConstantLines.concat(that._insideConstantLines), \"draw\");\r\n        callAction(that._strips, \"draw\");\r\n        that._dateMarkers = that._drawDateMarkers() || [];\r\n        that._stripLabelAxesGroup && that._axisStripLabelGroup.append(that._stripLabelAxesGroup);\r\n        that._gridContainerGroup && that._axisGridGroup.append(that._gridContainerGroup);\r\n        that._stripsGroup && that._axisStripGroup.append(that._stripsGroup);\r\n        that._labelsAxesGroup && that._axisElementsGroup.append(that._labelsAxesGroup);\r\n        if (that._constantLinesGroup) {\r\n            that._axisConstantLineGroups.above.inside.append(that._constantLinesGroup.above);\r\n            that._axisConstantLineGroups.above.outside1.append(that._constantLinesGroup.above);\r\n            that._axisConstantLineGroups.above.outside2.append(that._constantLinesGroup.above);\r\n            that._axisConstantLineGroups.under.inside.append(that._constantLinesGroup.under);\r\n            that._axisConstantLineGroups.under.outside1.append(that._constantLinesGroup.under);\r\n            that._axisConstantLineGroups.under.outside2.append(that._constantLinesGroup.under)\r\n        }\r\n        that._measureTitle();\r\n        measureLabels(that._majorTicks);\r\n        !options.label.template && that._applyWordWrap();\r\n        measureLabels(that._outsideConstantLines);\r\n        measureLabels(that._insideConstantLines);\r\n        measureLabels(that._strips);\r\n        measureLabels(that._dateMarkers);\r\n        that._adjustConstantLineLabels(that._insideConstantLines);\r\n        that._adjustStripLabels();\r\n        var offset = that._constantLabelOffset = that._adjustConstantLineLabels(that._outsideConstantLines);\r\n        if (!that._translator.getBusinessRange().isEmpty()) {\r\n            that._setLabelsPlacement();\r\n            offset = that._adjustLabels(offset)\r\n        }\r\n        when.apply(this, that._majorTicks.map(tick => tick.getTemplateDeferred())).done(() => {\r\n            that._templatesRendered.resolve()\r\n        });\r\n        offset = that._adjustDateMarkers(offset);\r\n        that._adjustTitle(offset)\r\n    },\r\n    getTemplatesDef() {\r\n        return this._templatesRendered\r\n    },\r\n    setRenderedState(state) {\r\n        this._drawn = state\r\n    },\r\n    isRendered() {\r\n        return this._drawn\r\n    },\r\n    _applyWordWrap() {\r\n        var convertedTickInterval;\r\n        var textWidth;\r\n        var textHeight;\r\n        var options = this._options;\r\n        var tickInterval = this._tickInterval;\r\n        if (isDefined(tickInterval)) {\r\n            convertedTickInterval = this.getTranslator().getInterval(\"datetime\" === options.dataType ? dateUtils.dateToMilliseconds(tickInterval) : tickInterval)\r\n        }\r\n        var displayMode = this._validateDisplayMode(options.label.displayMode);\r\n        var overlappingMode = this._validateOverlappingMode(options.label.overlappingBehavior, displayMode);\r\n        var wordWrapMode = options.label.wordWrap || \"none\";\r\n        var overflowMode = options.label.textOverflow || \"none\";\r\n        if ((\"none\" !== wordWrapMode || \"none\" !== overflowMode) && displayMode !== ROTATE && overlappingMode !== ROTATE && \"auto\" !== overlappingMode) {\r\n            var usefulSpace = isDefined(options.placeholderSize) ? options.placeholderSize - options.label.indentFromAxis : void 0;\r\n            if (this._isHorizontal) {\r\n                textWidth = convertedTickInterval;\r\n                textHeight = usefulSpace\r\n            } else {\r\n                textWidth = usefulSpace;\r\n                textHeight = convertedTickInterval\r\n            }\r\n            var correctByWidth = false;\r\n            var correctByHeight = false;\r\n            if (textWidth) {\r\n                if (this._majorTicks.some(tick => tick.labelBBox.width > textWidth)) {\r\n                    correctByWidth = true\r\n                }\r\n            }\r\n            if (textHeight) {\r\n                if (this._majorTicks.some(tick => tick.labelBBox.height > textHeight)) {\r\n                    correctByHeight = true\r\n                }\r\n            }\r\n            if (correctByWidth || correctByHeight) {\r\n                this._majorTicks.forEach(tick => {\r\n                    tick.label && tick.label.setMaxSize(textWidth, textHeight, options.label)\r\n                });\r\n                measureLabels(this._majorTicks)\r\n            }\r\n        }\r\n    },\r\n    _measureTitle: _noop,\r\n    animate() {\r\n        callAction(this._majorTicks, \"animateLabels\")\r\n    },\r\n    updateSize(canvas, animate) {\r\n        var updateTitle = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : true;\r\n        this.updateCanvas(canvas);\r\n        if (updateTitle) {\r\n            this._checkTitleOverflow();\r\n            this._measureTitle();\r\n            this._updateTitleCoords()\r\n        }\r\n        this._reinitTranslator(this._getViewportRange());\r\n        this.applyMargins();\r\n        var animationEnabled = !this._firstDrawing && animate;\r\n        var options = this._options;\r\n        initTickCoords(this._majorTicks);\r\n        initTickCoords(this._minorTicks);\r\n        initTickCoords(this._boundaryTicks);\r\n        if (this._resetApplyingAnimation && !this._firstDrawing) {\r\n            this._resetStartCoordinates()\r\n        }\r\n        cleanUpInvalidTicks(this._majorTicks);\r\n        cleanUpInvalidTicks(this._minorTicks);\r\n        cleanUpInvalidTicks(this._boundaryTicks);\r\n        if (this._axisElement) {\r\n            this._updateAxisElementPosition()\r\n        }\r\n        updateTicksPosition(this._majorTicks, options.tick, animationEnabled);\r\n        updateTicksPosition(this._minorTicks, options.minorTick, animationEnabled);\r\n        updateTicksPosition(this._boundaryTicks, options.tick);\r\n        callAction(this._majorTicks, \"updateLabelPosition\", animationEnabled);\r\n        this._outsideConstantLines.concat(this._insideConstantLines || []).forEach(l => l.updatePosition(animationEnabled));\r\n        callAction(this._strips, \"updatePosition\", animationEnabled);\r\n        updateGridsPosition(this._majorTicks, animationEnabled);\r\n        updateGridsPosition(this._minorTicks, animationEnabled);\r\n        if (animationEnabled) {\r\n            callAction(this._ticksToRemove || [], \"fadeOutElements\")\r\n        }\r\n        this.prepareAnimation();\r\n        this._ticksToRemove = null;\r\n        if (!this._translator.getBusinessRange().isEmpty()) {\r\n            this._firstDrawing = false\r\n        }\r\n        this._resetApplyingAnimation = false;\r\n        this._updateLabelsPosition()\r\n    },\r\n    _updateLabelsPosition: _noop,\r\n    prepareAnimation() {\r\n        var action = \"saveCoords\";\r\n        callAction(this._majorTicks, action);\r\n        callAction(this._minorTicks, action);\r\n        callAction(this._insideConstantLines, action);\r\n        callAction(this._outsideConstantLines, action);\r\n        callAction(this._strips, action)\r\n    },\r\n    _resetStartCoordinates() {\r\n        var action = \"resetCoordinates\";\r\n        callAction(this._majorTicks, action);\r\n        callAction(this._minorTicks, action);\r\n        callAction(this._insideConstantLines, action);\r\n        callAction(this._outsideConstantLines, action);\r\n        callAction(this._strips, action)\r\n    },\r\n    applyClipRects: function(elementsClipID, canvasClipID) {\r\n        this._axisGroup.attr({\r\n            \"clip-path\": canvasClipID\r\n        });\r\n        this._axisStripGroup.attr({\r\n            \"clip-path\": elementsClipID\r\n        });\r\n        this._axisElementsGroup.attr({\r\n            \"clip-path\": canvasClipID\r\n        })\r\n    },\r\n    _validateVisualRange(optionValue) {\r\n        var range = getVizRangeObject(optionValue);\r\n        if (void 0 !== range.startValue) {\r\n            range.startValue = this.validateUnit(range.startValue)\r\n        }\r\n        if (void 0 !== range.endValue) {\r\n            range.endValue = this.validateUnit(range.endValue)\r\n        }\r\n        return convertVisualRangeObject(range, !_isArray(optionValue))\r\n    },\r\n    _validateOptions(options) {\r\n        options.wholeRange = this._validateVisualRange(options.wholeRange);\r\n        options.visualRange = options._customVisualRange = this._validateVisualRange(options._customVisualRange);\r\n        this._setVisualRange(options._customVisualRange)\r\n    },\r\n    validate() {\r\n        var options = this._options;\r\n        var dataType = this.isArgumentAxis ? options.argumentType : options.valueType;\r\n        var parser = dataType ? getParser(dataType) : function(unit) {\r\n            return unit\r\n        };\r\n        this.parser = parser;\r\n        options.dataType = dataType;\r\n        this._validateOptions(options)\r\n    },\r\n    resetVisualRange(isSilent) {\r\n        this._seriesData.minVisible = this._seriesData.min;\r\n        this._seriesData.maxVisible = this._seriesData.max;\r\n        this.handleZooming([null, null], {\r\n            start: !!isSilent,\r\n            end: !!isSilent\r\n        })\r\n    },\r\n    _setVisualRange(visualRange, allowPartialUpdate) {\r\n        var range = this.adjustRange(getVizRangeObject(visualRange));\r\n        if (allowPartialUpdate) {\r\n            isDefined(range.startValue) && (this._viewport.startValue = range.startValue);\r\n            isDefined(range.endValue) && (this._viewport.endValue = range.endValue)\r\n        } else {\r\n            this._viewport = range\r\n        }\r\n    },\r\n    _applyZooming(visualRange, allowPartialUpdate) {\r\n        this._resetVisualRangeOption();\r\n        this._setVisualRange(visualRange, allowPartialUpdate);\r\n        var viewPort = this.getViewport();\r\n        this._seriesData.userBreaks = this._getScaleBreaks(this._options, {\r\n            minVisible: viewPort.startValue,\r\n            maxVisible: viewPort.endValue\r\n        }, this._series, this.isArgumentAxis);\r\n        this._translator.updateBusinessRange(this._getViewportRange())\r\n    },\r\n    getZoomStartEventArg(event, actionType) {\r\n        return {\r\n            axis: this,\r\n            range: this.visualRange(),\r\n            cancel: false,\r\n            event: event,\r\n            actionType: actionType\r\n        }\r\n    },\r\n    _getZoomEndEventArg(previousRange, event, actionType, zoomFactor, shift) {\r\n        var newRange = this.visualRange();\r\n        return {\r\n            axis: this,\r\n            previousRange: previousRange,\r\n            range: newRange,\r\n            cancel: false,\r\n            event: event,\r\n            actionType: actionType,\r\n            zoomFactor: zoomFactor,\r\n            shift: shift,\r\n            rangeStart: newRange.startValue,\r\n            rangeEnd: newRange.endValue\r\n        }\r\n    },\r\n    getZoomBounds() {\r\n        var wholeRange = getVizRangeObject(this._options.wholeRange);\r\n        var range = this.getTranslator().getBusinessRange();\r\n        var secondPriorityRange = {\r\n            startValue: getZoomBoundValue(this._initRange.startValue, range.min),\r\n            endValue: getZoomBoundValue(this._initRange.endValue, range.max)\r\n        };\r\n        return {\r\n            startValue: getZoomBoundValue(wholeRange.startValue, secondPriorityRange.startValue),\r\n            endValue: getZoomBoundValue(wholeRange.endValue, secondPriorityRange.endValue)\r\n        }\r\n    },\r\n    setInitRange() {\r\n        this._initRange = {};\r\n        if (0 === Object.keys(this._options.wholeRange || {}).length) {\r\n            this._initRange = this.getZoomBounds()\r\n        }\r\n    },\r\n    _resetVisualRangeOption() {\r\n        this._options._customVisualRange = {}\r\n    },\r\n    getTemplatesGroups() {\r\n        var ticks = this._majorTicks;\r\n        if (ticks) {\r\n            return this._majorTicks.map(tick => tick.templateContainer).filter(item => isDefined(item))\r\n        } else {\r\n            return []\r\n        }\r\n    },\r\n    setCustomVisualRange(range) {\r\n        this._options._customVisualRange = range\r\n    },\r\n    visualRange() {\r\n        var args = arguments;\r\n        var visualRange;\r\n        if (0 === args.length) {\r\n            var adjustedRange = this._getAdjustedBusinessRange();\r\n            var startValue = adjustedRange.minVisible;\r\n            var endValue = adjustedRange.maxVisible;\r\n            if (this._options.type === constants.discrete) {\r\n                var _startValue, _endValue;\r\n                startValue = null !== (_startValue = startValue) && void 0 !== _startValue ? _startValue : adjustedRange.categories[0];\r\n                endValue = null !== (_endValue = endValue) && void 0 !== _endValue ? _endValue : adjustedRange.categories[adjustedRange.categories.length - 1];\r\n                return {\r\n                    startValue: startValue,\r\n                    endValue: endValue,\r\n                    categories: getCategoriesInfo(adjustedRange.categories, startValue, endValue).categories\r\n                }\r\n            }\r\n            return {\r\n                startValue: startValue,\r\n                endValue: endValue\r\n            }\r\n        } else if (_isArray(args[0])) {\r\n            visualRange = args[0]\r\n        } else if (isPlainObject(args[0])) {\r\n            visualRange = extend({}, args[0])\r\n        } else {\r\n            visualRange = [args[0], args[1]]\r\n        }\r\n        var zoomResults = this.handleZooming(visualRange, args[1]);\r\n        if (!zoomResults.isPrevented) {\r\n            this._visualRange(this, zoomResults)\r\n        }\r\n    },\r\n    handleZooming(visualRange, preventEvents, domEvent, action) {\r\n        preventEvents = preventEvents || {};\r\n        if (isDefined(visualRange)) {\r\n            visualRange = this._validateVisualRange(visualRange);\r\n            visualRange.action = action\r\n        }\r\n        var zoomStartEvent = this.getZoomStartEventArg(domEvent, action);\r\n        var previousRange = zoomStartEvent.range;\r\n        !preventEvents.start && this._eventTrigger(\"zoomStart\", zoomStartEvent);\r\n        var zoomResults = {\r\n            isPrevented: zoomStartEvent.cancel,\r\n            skipEventRising: preventEvents.skipEventRising,\r\n            range: visualRange || zoomStartEvent.range\r\n        };\r\n        if (!zoomStartEvent.cancel) {\r\n            isDefined(visualRange) && this._applyZooming(visualRange, preventEvents.allowPartialUpdate);\r\n            if (!isDefined(this._storedZoomEndParams)) {\r\n                this._storedZoomEndParams = {\r\n                    startRange: previousRange,\r\n                    type: this.getOptions().type\r\n                }\r\n            }\r\n            this._storedZoomEndParams.event = domEvent;\r\n            this._storedZoomEndParams.action = action;\r\n            this._storedZoomEndParams.prevent = !!preventEvents.end\r\n        }\r\n        return zoomResults\r\n    },\r\n    handleZoomEnd() {\r\n        if (isDefined(this._storedZoomEndParams) && !this._storedZoomEndParams.prevent) {\r\n            var previousRange = this._storedZoomEndParams.startRange;\r\n            var domEvent = this._storedZoomEndParams.event;\r\n            var action = this._storedZoomEndParams.action;\r\n            var previousBusinessRange = {\r\n                minVisible: previousRange.startValue,\r\n                maxVisible: previousRange.endValue,\r\n                categories: previousRange.categories\r\n            };\r\n            var typeIsNotChanged = this.getOptions().type === this._storedZoomEndParams.type;\r\n            var shift = typeIsNotChanged ? adjust(this.getVisualRangeCenter() - this.getVisualRangeCenter(previousBusinessRange, false)) : NaN;\r\n            var zoomFactor = typeIsNotChanged ? +(Math.round(this.getVisualRangeLength(previousBusinessRange) / (this.getVisualRangeLength() || 1) + \"e+2\") + \"e-2\") : NaN;\r\n            var zoomEndEvent = this._getZoomEndEventArg(previousRange, domEvent, action, zoomFactor, shift);\r\n            zoomEndEvent.cancel = this.checkZoomingLowerLimitOvercome(1 === zoomFactor ? \"pan\" : \"zoom\", zoomFactor).stopInteraction;\r\n            this._eventTrigger(\"zoomEnd\", zoomEndEvent);\r\n            if (zoomEndEvent.cancel) {\r\n                this._restorePreviousVisualRange(previousRange)\r\n            }\r\n            this._storedZoomEndParams = null\r\n        }\r\n    },\r\n    _restorePreviousVisualRange(previousRange) {\r\n        this._storedZoomEndParams = null;\r\n        this._applyZooming(previousRange);\r\n        this._visualRange(this, previousRange)\r\n    },\r\n    checkZoomingLowerLimitOvercome(actionType, zoomFactor, range) {\r\n        var options = this._options;\r\n        var translator = this._translator;\r\n        var minZoom = options.minVisualRangeLength;\r\n        var correctedRange = range;\r\n        var visualRange;\r\n        var isOvercoming = \"zoom\" === actionType && zoomFactor >= 1;\r\n        var businessRange = translator.getBusinessRange();\r\n        if (range) {\r\n            visualRange = this.adjustRange(getVizRangeObject(range));\r\n            visualRange = {\r\n                minVisible: visualRange.startValue,\r\n                maxVisible: visualRange.endValue,\r\n                categories: businessRange.categories\r\n            }\r\n        }\r\n        var beforeVisualRangeLength = this.getVisualRangeLength(businessRange);\r\n        var afterVisualRangeLength = this.getVisualRangeLength(visualRange);\r\n        if (isDefined(minZoom) || \"discrete\" === options.type) {\r\n            minZoom = translator.convert(minZoom);\r\n            if (visualRange && minZoom < beforeVisualRangeLength && minZoom >= afterVisualRangeLength) {\r\n                correctedRange = getVizRangeObject(translator.getRangeByMinZoomValue(minZoom, visualRange));\r\n                isOvercoming = false\r\n            } else {\r\n                isOvercoming &= minZoom > afterVisualRangeLength\r\n            }\r\n        } else {\r\n            var canvasLength = this._translator.canvasLength;\r\n            var fullRange = {\r\n                minVisible: businessRange.min,\r\n                maxVisible: businessRange.max,\r\n                categories: businessRange.categories\r\n            };\r\n            isOvercoming &= this.getVisualRangeLength(fullRange) / canvasLength >= afterVisualRangeLength\r\n        }\r\n        return {\r\n            stopInteraction: !!isOvercoming,\r\n            correctedRange: correctedRange\r\n        }\r\n    },\r\n    isExtremePosition(isMax) {\r\n        var extremeDataValue;\r\n        var seriesData;\r\n        if (\"discrete\" === this._options.type) {\r\n            seriesData = this._translator.getBusinessRange();\r\n            extremeDataValue = isMax ? seriesData.categories[seriesData.categories.length - 1] : seriesData.categories[0]\r\n        } else {\r\n            seriesData = this.getZoomBounds();\r\n            extremeDataValue = isMax ? seriesData.endValue : seriesData.startValue\r\n        }\r\n        var translator = this.getTranslator();\r\n        var extremePoint = translator.translate(extremeDataValue);\r\n        var visualRange = this.visualRange();\r\n        var visualRangePoint = isMax ? translator.translate(visualRange.endValue) : translator.translate(visualRange.startValue);\r\n        return _abs(visualRangePoint - extremePoint) < SCROLL_THRESHOLD\r\n    },\r\n    getViewport() {\r\n        return this._viewport\r\n    },\r\n    getFullTicks: function() {\r\n        var majors = this._majorTicks || [];\r\n        if (this._options.type === constants.discrete) {\r\n            return convertTicksToValues(majors)\r\n        } else {\r\n            return convertTicksToValues(majors.concat(this._minorTicks, this._boundaryTicks)).sort((function(a, b) {\r\n                return valueOf(a) - valueOf(b)\r\n            }))\r\n        }\r\n    },\r\n    measureLabels: function(canvas, withIndents) {\r\n        var that = this;\r\n        var options = that._options;\r\n        var widthAxis = options.visible ? options.width : 0;\r\n        var ticks;\r\n        var indent = withIndents ? options.label.indentFromAxis + .5 * options.tick.length : 0;\r\n        var tickInterval;\r\n        var viewportRange = that._getViewportRange();\r\n        if (viewportRange.isEmpty() || !options.label.visible || !that._axisElementsGroup) {\r\n            return {\r\n                height: widthAxis,\r\n                width: widthAxis,\r\n                x: 0,\r\n                y: 0\r\n            }\r\n        }\r\n        if (that._majorTicks) {\r\n            ticks = convertTicksToValues(that._majorTicks)\r\n        } else {\r\n            that.updateCanvas(canvas);\r\n            ticks = that._createTicksAndLabelFormat(viewportRange, _noop);\r\n            tickInterval = ticks.tickInterval;\r\n            ticks = ticks.ticks\r\n        }\r\n        var maxText = ticks.reduce((function(prevLabel, tick, index) {\r\n            var label = that.formatLabel(tick, options.label, viewportRange, void 0, tickInterval, ticks);\r\n            if (prevLabel.length < label.length) {\r\n                return label\r\n            } else {\r\n                return prevLabel\r\n            }\r\n        }), that.formatLabel(ticks[0], options.label, viewportRange, void 0, tickInterval, ticks));\r\n        var text = that._renderer.text(maxText, 0, 0).css(that._textFontStyles).attr(that._textOptions).append(that._renderer.root);\r\n        var box = text.getBBox();\r\n        text.remove();\r\n        return {\r\n            x: box.x,\r\n            y: box.y,\r\n            width: box.width + indent,\r\n            height: box.height + indent\r\n        }\r\n    },\r\n    _setLabelsPlacement: function() {\r\n        if (!this._options.label.visible) {\r\n            return\r\n        }\r\n        var labelOpt = this._options.label;\r\n        var displayMode = this._validateDisplayMode(labelOpt.displayMode);\r\n        var overlappingMode = this._validateOverlappingMode(labelOpt.overlappingBehavior, displayMode);\r\n        var ignoreOverlapping = \"none\" === overlappingMode || \"ignore\" === overlappingMode;\r\n        var behavior = {\r\n            rotationAngle: labelOpt.rotationAngle,\r\n            staggeringSpacing: labelOpt.staggeringSpacing\r\n        };\r\n        var notRecastStep;\r\n        var boxes = this._majorTicks.map((function(tick) {\r\n            return tick.labelBBox\r\n        }));\r\n        var step = this._getStep(boxes);\r\n        switch (displayMode) {\r\n            case ROTATE:\r\n                if (ignoreOverlapping) {\r\n                    notRecastStep = true;\r\n                    step = 1\r\n                }\r\n                this._applyLabelMode(displayMode, step, boxes, labelOpt, notRecastStep);\r\n                break;\r\n            case \"stagger\":\r\n                if (ignoreOverlapping) {\r\n                    step = 2\r\n                }\r\n                this._applyLabelMode(displayMode, _max(step, 2), boxes, labelOpt);\r\n                break;\r\n            default:\r\n                this._applyLabelOverlapping(boxes, overlappingMode, step, behavior)\r\n        }\r\n    },\r\n    _applyLabelOverlapping: function(boxes, mode, step, behavior) {\r\n        var labelOpt = this._options.label;\r\n        var majorTicks = this._majorTicks;\r\n        if (\"none\" === mode || \"ignore\" === mode) {\r\n            return\r\n        }\r\n        if (step > 1 && boxes.some((function(box, index, array) {\r\n                if (0 === index) {\r\n                    return false\r\n                }\r\n                return constants.areLabelsOverlap(box, array[index - 1], labelOpt.minSpacing, labelOpt.alignment)\r\n            }))) {\r\n            this._applyLabelMode(mode, step, boxes, behavior)\r\n        }\r\n        this._checkBoundedLabelsOverlapping(majorTicks, boxes, mode);\r\n        this._checkShiftedLabels(majorTicks, boxes, labelOpt.minSpacing, labelOpt.alignment)\r\n    },\r\n    _applyLabelMode: function(mode, step, boxes, behavior, notRecastStep) {\r\n        var majorTicks = this._majorTicks;\r\n        var labelOpt = this._options.label;\r\n        var angle = behavior.rotationAngle;\r\n        var labelHeight;\r\n        var alignment;\r\n        var func;\r\n        switch (mode) {\r\n            case ROTATE:\r\n                if (!labelOpt.userAlignment) {\r\n                    alignment = angle < 0 ? RIGHT : LEFT;\r\n                    if (angle % 90 === 0) {\r\n                        alignment = CENTER\r\n                    }\r\n                }\r\n                step = notRecastStep ? step : this._getStep(boxes, angle);\r\n                func = function(tick) {\r\n                    var contentContainer = tick.getContentContainer();\r\n                    if (!contentContainer) {\r\n                        return\r\n                    }\r\n                    contentContainer.rotate(angle);\r\n                    tick.labelRotationAngle = angle;\r\n                    alignment && (tick.labelAlignment = alignment)\r\n                };\r\n                updateLabels(majorTicks, step, func);\r\n                break;\r\n            case \"stagger\":\r\n                labelHeight = this._getMaxLabelHeight(boxes, behavior.staggeringSpacing);\r\n                func = function(tick, index) {\r\n                    if (index / (step - 1) % 2 !== 0) {\r\n                        tick.labelOffset = labelHeight\r\n                    }\r\n                };\r\n                updateLabels(majorTicks, step - 1, func);\r\n                break;\r\n            case \"auto\":\r\n            case \"_auto\":\r\n                if (2 === step) {\r\n                    this._applyLabelMode(\"stagger\", step, boxes, behavior)\r\n                } else {\r\n                    this._applyLabelMode(ROTATE, step, boxes, {\r\n                        rotationAngle: getOptimalAngle(boxes, labelOpt)\r\n                    })\r\n                }\r\n                break;\r\n            default:\r\n                updateLabels(majorTicks, step)\r\n        }\r\n    },\r\n    getMarkerTrackers: _noop,\r\n    _drawDateMarkers: _noop,\r\n    _adjustDateMarkers: _noop,\r\n    coordsIn: _noop,\r\n    areCoordsOutsideAxis: _noop,\r\n    _getSkippedCategory: _noop,\r\n    _initAxisPositions: _noop,\r\n    _drawTitle: _noop,\r\n    _updateTitleCoords: _noop,\r\n    _adjustConstantLineLabels: _noop,\r\n    _createTranslator: function() {\r\n        return new Translator2D({}, {}, {})\r\n    },\r\n    _updateTranslator: function() {\r\n        var translator = this._translator;\r\n        translator.update(translator.getBusinessRange(), this._canvas || {}, this._getTranslatorOptions())\r\n    },\r\n    _getTranslatorOptions: function() {\r\n        var _options$workWeek2, _options$breakStyle$w, _options$breakStyle;\r\n        var options = this._options;\r\n        return {\r\n            isHorizontal: this._isHorizontal,\r\n            shiftZeroValue: !this.isArgumentAxis,\r\n            interval: options.semiDiscreteInterval,\r\n            firstDayOfWeek: null === (_options$workWeek2 = options.workWeek) || void 0 === _options$workWeek2 ? void 0 : _options$workWeek2[0],\r\n            stick: this._getStick(),\r\n            breaksSize: null !== (_options$breakStyle$w = null === (_options$breakStyle = options.breakStyle) || void 0 === _options$breakStyle ? void 0 : _options$breakStyle.width) && void 0 !== _options$breakStyle$w ? _options$breakStyle$w : 0\r\n        }\r\n    },\r\n    getVisibleArea() {\r\n        var canvas = this._getCanvasStartEnd();\r\n        return [canvas.start, canvas.end].sort((a, b) => a - b)\r\n    },\r\n    _getCanvasStartEnd: function() {\r\n        var isHorizontal = this._isHorizontal;\r\n        var canvas = this._canvas || {};\r\n        var invert = this._translator.getBusinessRange().invert;\r\n        var coords = isHorizontal ? [canvas.left, canvas.width - canvas.right] : [canvas.height - canvas.bottom, canvas.top];\r\n        invert && coords.reverse();\r\n        return {\r\n            start: coords[0],\r\n            end: coords[1]\r\n        }\r\n    },\r\n    _getScreenDelta: function() {\r\n        var canvas = this._getCanvasStartEnd();\r\n        var breaks = this._seriesData ? this._seriesData.breaks || [] : [];\r\n        var breaksLength = breaks.length;\r\n        var screenDelta = _abs(canvas.start - canvas.end);\r\n        return screenDelta - (breaksLength ? breaks[breaksLength - 1].cumulativeWidth : 0)\r\n    },\r\n    _getScaleBreaks: function() {\r\n        return []\r\n    },\r\n    _filterBreaks: function() {\r\n        return []\r\n    },\r\n    _adjustTitle: _noop,\r\n    _checkTitleOverflow: _noop,\r\n    getSpiderTicks: _noop,\r\n    setSpiderTicks: _noop,\r\n    _checkBoundedLabelsOverlapping: _noop,\r\n    _checkShiftedLabels: _noop,\r\n    drawScaleBreaks: _noop,\r\n    _visualRange: _noop,\r\n    _rotateConstantLine: _noop,\r\n    applyVisualRangeSetter(visualRangeSetter) {\r\n        this._visualRange = visualRangeSetter\r\n    },\r\n    getCategoriesSorter(argCategories) {\r\n        var sort;\r\n        if (this.isArgumentAxis) {\r\n            sort = argCategories\r\n        } else {\r\n            var categoriesSortingMethod = this._options.categoriesSortingMethod;\r\n            sort = null !== categoriesSortingMethod && void 0 !== categoriesSortingMethod ? categoriesSortingMethod : this._options.categories\r\n        }\r\n        return sort\r\n    },\r\n    _getAdjustedBusinessRange() {\r\n        return this.adjustViewport(this._translator.getBusinessRange())\r\n    }\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}