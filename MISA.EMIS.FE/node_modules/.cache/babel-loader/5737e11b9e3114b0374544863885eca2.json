{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/series/line_series.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { chart as chartScatterSeries, polar as polarScatterSeries } from \"./scatter_series\";\nimport { clone } from \"../../core/utils/object\";\nimport { extend } from \"../../core/utils/extend\";\nimport { each } from \"../../core/utils/iterator\";\nimport { map, normalizeAngle, getCosAndSin } from \"../core/utils\";\nimport { solveCubicEquation, trunc } from \"../../core/utils/math\";\nvar DISCRETE = \"discrete\";\nvar {\n  round: round,\n  sqrt: sqrt,\n  pow: pow,\n  min: min,\n  max: max,\n  abs: abs\n} = Math;\nvar chart = {};\nvar polar = {};\n\nfunction clonePoint(point, newX, newY, newAngle) {\n  var p = clone(point);\n  p.x = newX;\n  p.y = newY;\n  p.angle = newAngle;\n  return p;\n}\n\nfunction getTangentPoint(point, prevPoint, centerPoint, tan, nextStepAngle) {\n  var correctAngle = point.angle + nextStepAngle;\n  var cosSin = getCosAndSin(correctAngle);\n  var x = centerPoint.x + (point.radius + tan * nextStepAngle) * cosSin.cos;\n  var y = centerPoint.y - (point.radius + tan * nextStepAngle) * cosSin.sin;\n  return clonePoint(prevPoint, x, y, correctAngle);\n}\n\nfunction obtainCubicBezierTCoef(p, p0, p1, p2, p3) {\n  var d = p0 - p;\n  var c = 3 * p1 - 3 * p0;\n  var b = 3 * p2 - 6 * p1 + 3 * p0;\n  var a = p3 - 3 * p2 + 3 * p1 - p0;\n  return solveCubicEquation(a, b, c, d);\n}\n\nvar lineMethods = {\n  autoHidePointMarkersEnabled: () => true,\n  _applyGroupSettings: function (style, settings, group) {\n    settings = extend(settings, style);\n\n    this._applyElementsClipRect(settings);\n\n    group.attr(settings);\n  },\n  _setGroupsSettings: function (animationEnabled) {\n    var style = this._styles.normal;\n\n    this._applyGroupSettings(style.elements, {\n      class: \"dxc-elements\"\n    }, this._elementsGroup);\n\n    this._bordersGroup && this._applyGroupSettings(style.border, {\n      class: \"dxc-borders\"\n    }, this._bordersGroup);\n\n    chartScatterSeries._setGroupsSettings.call(this, animationEnabled);\n\n    animationEnabled && this._markersGroup && this._markersGroup.attr({\n      opacity: .001\n    });\n  },\n  _createGroups: function () {\n    this._createGroup(\"_elementsGroup\", this, this._group);\n\n    this._areBordersVisible() && this._createGroup(\"_bordersGroup\", this, this._group);\n\n    chartScatterSeries._createGroups.call(this);\n  },\n  _areBordersVisible: function () {\n    return false;\n  },\n  _getDefaultSegment: function (segment) {\n    return {\n      line: map(segment.line || [], function (pt) {\n        return pt.getDefaultCoords();\n      })\n    };\n  },\n  _prepareSegment: function (points) {\n    return {\n      line: points\n    };\n  },\n  _parseLineOptions: function (options, defaultColor) {\n    return {\n      stroke: options.color || defaultColor,\n      \"stroke-width\": options.width,\n      dashStyle: options.dashStyle || \"solid\"\n    };\n  },\n  _parseStyle: function (options, defaultColor) {\n    return {\n      elements: this._parseLineOptions(options, defaultColor)\n    };\n  },\n  _applyStyle: function (style) {\n    this._elementsGroup && this._elementsGroup.attr(style.elements);\n    each(this._graphics || [], function (_, graphic) {\n      graphic.line && graphic.line.attr({\n        \"stroke-width\": style.elements[\"stroke-width\"]\n      }).sharp();\n    });\n  },\n  _drawElement: function (segment, group) {\n    return {\n      line: this._createMainElement(segment.line, {\n        \"stroke-width\": this._styles.normal.elements[\"stroke-width\"]\n      }).append(group)\n    };\n  },\n  _removeElement: function (element) {\n    element.line.remove();\n  },\n  _updateElement: function (element, segment, animate, animationComplete) {\n    var params = {\n      points: segment.line\n    };\n    var lineElement = element.line;\n    animate ? lineElement.animate(params, {}, animationComplete) : lineElement.attr(params);\n  },\n  _animateComplete: function () {\n    chartScatterSeries._animateComplete.call(this);\n\n    this._markersGroup && this._markersGroup.animate({\n      opacity: 1\n    }, {\n      duration: this._defaultDuration\n    });\n  },\n  _animate: function () {\n    var that = this;\n    var lastIndex = that._graphics.length - 1;\n    each(that._graphics || [], function (i, elem) {\n      var complete;\n\n      if (i === lastIndex) {\n        complete = function () {\n          that._animateComplete();\n        };\n      }\n\n      that._updateElement(elem, that._segments[i], true, complete);\n    });\n  },\n  _drawPoint: function (options) {\n    chartScatterSeries._drawPoint.call(this, {\n      point: options.point,\n      groups: options.groups\n    });\n  },\n  _createMainElement: function (points, settings) {\n    return this._renderer.path(points, \"line\").attr(settings);\n  },\n  _sortPoints: function (points, rotated) {\n    return rotated ? points.sort(function (p1, p2) {\n      return p2.y - p1.y;\n    }) : points.sort(function (p1, p2) {\n      return p1.x - p2.x;\n    });\n  },\n  _drawSegment: function (points, animationEnabled, segmentCount, lastSegment) {\n    var rotated = this._options.rotated;\n\n    var segment = this._prepareSegment(points, rotated, lastSegment);\n\n    this._segments.push(segment);\n\n    if (!this._graphics[segmentCount]) {\n      this._graphics[segmentCount] = this._drawElement(animationEnabled ? this._getDefaultSegment(segment) : segment, this._elementsGroup);\n    } else if (!animationEnabled) {\n      this._updateElement(this._graphics[segmentCount], segment);\n    }\n  },\n  _getTrackerSettings: function () {\n    var defaultTrackerWidth = this._defaultTrackerWidth;\n    var strokeWidthFromElements = this._styles.normal.elements[\"stroke-width\"];\n    return {\n      \"stroke-width\": strokeWidthFromElements > defaultTrackerWidth ? strokeWidthFromElements : defaultTrackerWidth,\n      fill: \"none\"\n    };\n  },\n  _getMainPointsFromSegment: function (segment) {\n    return segment.line;\n  },\n  _drawTrackerElement: function (segment) {\n    return this._createMainElement(this._getMainPointsFromSegment(segment), this._getTrackerSettings(segment));\n  },\n  _updateTrackerElement: function (segment, element) {\n    var settings = this._getTrackerSettings(segment);\n\n    settings.points = this._getMainPointsFromSegment(segment);\n    element.attr(settings);\n  },\n\n  checkSeriesViewportCoord(axis, coord) {\n    if (!chartScatterSeries.checkSeriesViewportCoord.call(this)) {\n      return false;\n    }\n\n    var range = axis.isArgumentAxis ? this.getArgumentRange() : this.getViewport();\n    var min = axis.getTranslator().translate(range.categories ? range.categories[0] : range.min);\n    var max = axis.getTranslator().translate(range.categories ? range.categories[range.categories.length - 1] : range.max);\n    var rotated = this.getOptions().rotated;\n    var inverted = axis.getOptions().inverted;\n    return axis.isArgumentAxis && (!rotated && !inverted || rotated && inverted) || !axis.isArgumentAxis && (rotated && !inverted || !rotated && inverted) ? coord >= min && coord <= max : coord >= max && coord <= min;\n  }\n\n};\nvar lineSeries = chart.line = extend({}, chartScatterSeries, lineMethods, {\n  getPointCenterByArg(arg) {\n    var value = this.getArgumentAxis().getTranslator().translate(arg);\n    return {\n      x: value,\n      y: value\n    };\n  },\n\n  getSeriesPairCoord(coord, isArgument) {\n    var oppositeCoord = null;\n\n    var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);\n\n    var needValueCoord = isArgument && !this._options.rotated || !isArgument && this._options.rotated;\n\n    for (var i = 0; i < nearestPoints.length; i++) {\n      var p = nearestPoints[i];\n      var k = (p[1].vy - p[0].vy) / (p[1].vx - p[0].vx);\n      var b = p[0].vy - p[0].vx * k;\n      var tmpCoord = void 0;\n\n      if (p[1].vx - p[0].vx === 0) {\n        tmpCoord = needValueCoord ? p[0].vy : p[0].vx;\n      } else {\n        tmpCoord = needValueCoord ? k * coord + b : (coord - b) / k;\n      }\n\n      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\n        oppositeCoord = tmpCoord;\n        break;\n      }\n    }\n\n    return oppositeCoord;\n  }\n\n});\nchart.stepline = extend({}, lineSeries, {\n  _calculateStepLinePoints(points) {\n    var segment = [];\n    var coordName = this._options.rotated ? \"x\" : \"y\";\n    each(points, function (i, pt) {\n      var point;\n\n      if (!i) {\n        segment.push(pt);\n        return;\n      }\n\n      var step = segment[segment.length - 1][coordName];\n\n      if (step !== pt[coordName]) {\n        point = clone(pt);\n        point[coordName] = step;\n        segment.push(point);\n      }\n\n      segment.push(pt);\n    });\n    return segment;\n  },\n\n  _prepareSegment: function (points) {\n    return lineSeries._prepareSegment(this._calculateStepLinePoints(points));\n  },\n\n  getSeriesPairCoord(coord, isArgument) {\n    var oppositeCoord;\n    var rotated = this._options.rotated;\n    var isOpposite = !isArgument && !rotated || isArgument && rotated;\n    var coordName = !isOpposite ? \"vx\" : \"vy\";\n    var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\n\n    var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);\n\n    for (var i = 0; i < nearestPoints.length; i++) {\n      var p = nearestPoints[i];\n      var tmpCoord = void 0;\n\n      if (isArgument) {\n        tmpCoord = coord !== p[1][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName];\n      } else {\n        tmpCoord = coord === p[0][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName];\n      }\n\n      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\n        oppositeCoord = tmpCoord;\n        break;\n      }\n    }\n\n    return oppositeCoord;\n  }\n\n});\nchart.spline = extend({}, lineSeries, {\n  _calculateBezierPoints: function (src, rotated) {\n    var bezierPoints = [];\n    var pointsCopy = src;\n\n    var checkExtremum = function (otherPointCoord, pointCoord, controlCoord) {\n      return otherPointCoord > pointCoord && controlCoord > otherPointCoord || otherPointCoord < pointCoord && controlCoord < otherPointCoord ? otherPointCoord : controlCoord;\n    };\n\n    if (1 !== pointsCopy.length) {\n      pointsCopy.forEach(function (curPoint, i) {\n        var leftControlX;\n        var leftControlY;\n        var rightControlX;\n        var rightControlY;\n        var prevPoint = pointsCopy[i - 1];\n        var nextPoint = pointsCopy[i + 1];\n        var x1;\n        var x2;\n        var y1;\n        var y2;\n        var a;\n        var b;\n        var c;\n        var xc;\n        var yc;\n        var shift;\n\n        if (!i || i === pointsCopy.length - 1) {\n          bezierPoints.push(curPoint, curPoint);\n          return;\n        }\n\n        var xCur = curPoint.x;\n        var yCur = curPoint.y;\n        x1 = prevPoint.x;\n        x2 = nextPoint.x;\n        y1 = prevPoint.y;\n        y2 = nextPoint.y;\n        var curIsExtremum = !!(!rotated && (yCur <= prevPoint.y && yCur <= nextPoint.y || yCur >= prevPoint.y && yCur >= nextPoint.y) || rotated && (xCur <= prevPoint.x && xCur <= nextPoint.x || xCur >= prevPoint.x && xCur >= nextPoint.x));\n\n        if (curIsExtremum) {\n          if (!rotated) {\n            rightControlY = leftControlY = yCur;\n            rightControlX = (xCur + nextPoint.x) / 2;\n            leftControlX = (xCur + prevPoint.x) / 2;\n          } else {\n            rightControlX = leftControlX = xCur;\n            rightControlY = (yCur + nextPoint.y) / 2;\n            leftControlY = (yCur + prevPoint.y) / 2;\n          }\n        } else {\n          a = y2 - y1;\n          b = x1 - x2;\n          c = y1 * x2 - x1 * y2;\n\n          if (!rotated) {\n            if (!b) {\n              bezierPoints.push(curPoint, curPoint, curPoint);\n              return;\n            }\n\n            xc = xCur;\n            yc = -1 * (a * xc + c) / b;\n            shift = yc - yCur;\n            y1 -= shift;\n            y2 -= shift;\n          } else {\n            if (!a) {\n              bezierPoints.push(curPoint, curPoint, curPoint);\n              return;\n            }\n\n            yc = yCur;\n            xc = -1 * (b * yc + c) / a;\n            shift = xc - xCur;\n            x1 -= shift;\n            x2 -= shift;\n          }\n\n          rightControlX = (xCur + .5 * x2) / 1.5;\n          rightControlY = (yCur + .5 * y2) / 1.5;\n          leftControlX = (xCur + .5 * x1) / 1.5;\n          leftControlY = (yCur + .5 * y1) / 1.5;\n        }\n\n        if (!rotated) {\n          leftControlY = checkExtremum(prevPoint.y, yCur, leftControlY);\n          rightControlY = checkExtremum(nextPoint.y, yCur, rightControlY);\n        } else {\n          leftControlX = checkExtremum(prevPoint.x, xCur, leftControlX);\n          rightControlX = checkExtremum(nextPoint.x, xCur, rightControlX);\n        }\n\n        var leftPoint = clonePoint(curPoint, leftControlX, leftControlY);\n        var rightPoint = clonePoint(curPoint, rightControlX, rightControlY);\n        bezierPoints.push(leftPoint, curPoint, rightPoint);\n      });\n    } else {\n      bezierPoints.push(pointsCopy[0]);\n    }\n\n    return bezierPoints;\n  },\n  _prepareSegment: function (points, rotated) {\n    return lineSeries._prepareSegment(this._calculateBezierPoints(points, rotated));\n  },\n  _createMainElement: function (points, settings) {\n    return this._renderer.path(points, \"bezier\").attr(settings);\n  },\n\n  getSeriesPairCoord(coord, isArgument) {\n    var oppositeCoord = null;\n    var isOpposite = !isArgument && !this._options.rotated || isArgument && this._options.rotated;\n    var coordName = !isOpposite ? \"vx\" : \"vy\";\n    var bezierCoordName = !isOpposite ? \"x\" : \"y\";\n    var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\n    var bezierOppositeCoordName = !isOpposite ? \"y\" : \"x\";\n    var axis = !isArgument ? this.getArgumentAxis() : this.getValueAxis();\n    var visibleArea = axis.getVisibleArea();\n\n    var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);\n\n    var _loop = function (i) {\n      var p = nearestPoints[i];\n\n      if (1 === p.length) {\n        visibleArea[0] <= p[0][oppositeCoordName] && visibleArea[1] >= p[0][oppositeCoordName] && (oppositeCoord = p[0][oppositeCoordName]);\n      } else {\n        var ts = obtainCubicBezierTCoef(coord, p[0][coordName], p[1][bezierCoordName], p[2][bezierCoordName], p[3][coordName]);\n        ts.forEach(t => {\n          if (t >= 0 && t <= 1) {\n            var tmpCoord = Math.pow(1 - t, 3) * p[0][oppositeCoordName] + 3 * Math.pow(1 - t, 2) * t * p[1][bezierOppositeCoordName] + 3 * (1 - t) * t * t * p[2][bezierOppositeCoordName] + t * t * t * p[3][oppositeCoordName];\n\n            if (visibleArea[0] <= tmpCoord && visibleArea[1] >= tmpCoord) {\n              oppositeCoord = tmpCoord;\n            }\n          }\n        });\n      }\n\n      if (null !== oppositeCoord) {\n        return \"break\";\n      }\n    };\n\n    for (var i = 0; i < nearestPoints.length; i++) {\n      var _ret = _loop(i);\n\n      if (\"break\" === _ret) {\n        break;\n      }\n    }\n\n    return oppositeCoord;\n  },\n\n  _getNearestPoints(point, nextPoint, bezierPoints) {\n    var index = bezierPoints.indexOf(point);\n    return [point, bezierPoints[index + 1], bezierPoints[index + 2], nextPoint];\n  },\n\n  _getBezierPoints() {\n    return this._segments.length > 0 ? this._segments.reduce((a, seg) => a.concat(seg.line), []) : [];\n  }\n\n});\npolar.line = extend({}, polarScatterSeries, lineMethods, {\n  _sortPoints: function (points) {\n    return points;\n  },\n  _prepareSegment: function (points, rotated, lastSegment) {\n    var preparedPoints = [];\n    var centerPoint = this.getValueAxis().getCenter();\n    var i;\n    lastSegment && this._closeSegment(points);\n\n    if (this.argumentAxisType !== DISCRETE && this.valueAxisType !== DISCRETE) {\n      for (i = 1; i < points.length; i++) {\n        preparedPoints = preparedPoints.concat(this._getTangentPoints(points[i], points[i - 1], centerPoint));\n      }\n\n      if (!preparedPoints.length) {\n        preparedPoints = points;\n      }\n    } else {\n      return lineSeries._prepareSegment.call(this, points);\n    }\n\n    return {\n      line: preparedPoints\n    };\n  },\n  _getRemainingAngle: function (angle) {\n    var normAngle = normalizeAngle(angle);\n    return angle >= 0 ? 360 - normAngle : -normAngle;\n  },\n\n  _closeSegment(points) {\n    var point;\n\n    if (this._segments.length) {\n      point = this._segments[0].line[0];\n    } else {\n      point = clonePoint(points[0], points[0].x, points[0].y, points[0].angle);\n    }\n\n    point = this._modifyReflectedPoint(point, points[points.length - 1]);\n\n    if (point) {\n      points.push(point);\n    }\n  },\n\n  _modifyReflectedPoint(point, lastPoint) {\n    if (lastPoint.angle === point.angle) {\n      return;\n    }\n\n    if (normalizeAngle(round(lastPoint.angle)) === normalizeAngle(round(point.angle))) {\n      point.angle = lastPoint.angle;\n    } else {\n      var differenceAngle = lastPoint.angle - point.angle;\n      point.angle = lastPoint.angle + this._getRemainingAngle(differenceAngle);\n    }\n\n    return point;\n  },\n\n  _getTangentPoints: function (point, prevPoint, centerPoint) {\n    var tangentPoints = [];\n    var betweenAngle = Math.round(prevPoint.angle - point.angle);\n    var tan = (prevPoint.radius - point.radius) / betweenAngle;\n    var i;\n\n    if (0 === betweenAngle) {\n      tangentPoints = [prevPoint, point];\n    } else if (betweenAngle > 0) {\n      for (i = betweenAngle; i >= 0; i--) {\n        tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, i));\n      }\n    } else {\n      for (i = 0; i >= betweenAngle; i--) {\n        tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, betweenAngle - i));\n      }\n    }\n\n    return tangentPoints;\n  },\n\n  getSeriesPairCoord(params, isArgument) {\n    var argAxis = this.getArgumentAxis();\n    var paramName = isArgument ? \"angle\" : \"radius\";\n    var coordParam = params[paramName];\n    var centerPoint = argAxis.getCenter();\n\n    var isInsideInterval = (prevPoint, point, _ref) => {\n      var {\n        x: x,\n        y: y\n      } = _ref;\n      return (p1 = {\n        x: x,\n        y: y\n      }, p2 = centerPoint, sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2))) <= argAxis.getRadius() && min(prevPoint.x, point.x) <= x && max(prevPoint.x, point.x) >= x && min(prevPoint.y, point.y) <= y && max(prevPoint.y, point.y) >= y;\n      var p1, p2;\n    };\n\n    var coords;\n    var neighborPoints = this.getNeighborPoints(coordParam, paramName);\n\n    if (1 === neighborPoints.length) {\n      coords = neighborPoints[0];\n    } else if (neighborPoints.length > 1) {\n      var prevPoint = neighborPoints[0];\n      var point = neighborPoints[1];\n\n      if (this.argumentAxisType !== DISCRETE && this.valueAxisType !== DISCRETE) {\n        var tan;\n        var stepAngle;\n\n        if (isArgument) {\n          tan = (prevPoint.radius - point.radius) / (prevPoint.angle - point.angle);\n          stepAngle = coordParam - point.angle;\n        } else {\n          tan = (prevPoint.radius - point.radius) / (prevPoint.angle - point.angle);\n          stepAngle = (coordParam - point.radius) / tan;\n        }\n\n        coords = getTangentPoint(point, prevPoint, centerPoint, tan, stepAngle);\n      } else if (isArgument) {\n        var cosSin = getCosAndSin(-coordParam);\n        var k1 = (point.y - prevPoint.y) / (point.x - prevPoint.x);\n        var b1 = prevPoint.y - prevPoint.x * k1;\n        var k2 = cosSin.sin / cosSin.cos;\n        var b2 = centerPoint.y - k2 * centerPoint.x;\n        var x = (b2 - b1) / (k1 - k2);\n        var y = k1 * x + b1;\n\n        if (isInsideInterval(prevPoint, point, {\n          x: x,\n          y: y\n        })) {\n          var quarter = abs(trunc((360 + coordParam) / 90) % 4);\n\n          if (0 === quarter && x >= centerPoint.x && y <= centerPoint.y || 1 === quarter && x <= centerPoint.x && y <= centerPoint.y || 2 === quarter && x <= centerPoint.x && y >= centerPoint.y || 3 === quarter && x >= centerPoint.x && y >= centerPoint.y) {\n            coords = {\n              x: x,\n              y: y\n            };\n          }\n        }\n      } else {\n        var k = (point.y - prevPoint.y) / (point.x - prevPoint.x);\n        var y0 = prevPoint.y - prevPoint.x * k;\n        var a = 1 + k * k;\n        var b = -2 * centerPoint.x + 2 * k * y0 - 2 * k * centerPoint.y;\n        var c = -pow(coordParam, 2) + pow(y0 - centerPoint.y, 2) + pow(centerPoint.x, 2);\n        var d = b * b - 4 * a * c;\n\n        if (d >= 0) {\n          var x1 = (-b - sqrt(d)) / (2 * a);\n          var x2 = (-b + sqrt(d)) / (2 * a);\n          var y1 = k * x1 + y0;\n          var y2 = k * x2 + y0;\n          coords = isInsideInterval(prevPoint, point, {\n            x: x1,\n            y: y1\n          }) ? {\n            x: x1,\n            y: y1\n          } : isInsideInterval(prevPoint, point, {\n            x: x2,\n            y: y2\n          }) ? {\n            x: x2,\n            y: y2\n          } : void 0;\n        }\n      }\n    }\n\n    return coords;\n  },\n\n  getNeighborPoints(param, paramName) {\n    var points = this.getPoints();\n    var neighborPoints = [];\n\n    if (this.getOptions().closed) {\n      points = extend(true, [], points);\n      var lastPoint = points[points.length - 1];\n      var firstPointCopy = clonePoint(points[0], points[0].x, points[0].y, points[0].angle);\n      var lastPointCopy = clonePoint(lastPoint, lastPoint.x, lastPoint.y, lastPoint.angle);\n\n      var rearwardRefPoint = this._modifyReflectedPoint(firstPointCopy, lastPoint);\n\n      var forwardRefPoint = this._modifyReflectedPoint(lastPointCopy, points[0]);\n\n      if (forwardRefPoint) {\n        points.unshift(forwardRefPoint);\n      }\n\n      if (rearwardRefPoint) {\n        points.push(rearwardRefPoint);\n      }\n    }\n\n    for (var i = 1; i < points.length; i++) {\n      if (points[i - 1][paramName] === param) {\n        neighborPoints.push(points[i - 1]);\n      } else if (points[i][paramName] === param) {\n        neighborPoints.push(points[i]);\n      } else if (points[i][paramName] > param && points[i - 1][paramName] < param || points[i - 1][paramName] > param && points[i][paramName] < param) {\n        neighborPoints.push(points[i - 1]);\n        neighborPoints.push(points[i]);\n      }\n\n      if (neighborPoints.length > 0) {\n        break;\n      }\n    }\n\n    return neighborPoints;\n  }\n\n});\nexport { chart, polar };","map":{"version":3,"names":["chart","chartScatterSeries","polar","polarScatterSeries","clone","extend","each","map","normalizeAngle","getCosAndSin","solveCubicEquation","trunc","DISCRETE","round","sqrt","pow","min","max","abs","Math","clonePoint","point","newX","newY","newAngle","p","x","y","angle","getTangentPoint","prevPoint","centerPoint","tan","nextStepAngle","correctAngle","cosSin","radius","cos","sin","obtainCubicBezierTCoef","p0","p1","p2","p3","d","c","b","a","lineMethods","autoHidePointMarkersEnabled","_applyGroupSettings","style","settings","group","_applyElementsClipRect","attr","_setGroupsSettings","animationEnabled","_styles","normal","elements","class","_elementsGroup","_bordersGroup","border","call","_markersGroup","opacity","_createGroups","_createGroup","_group","_areBordersVisible","_getDefaultSegment","segment","line","pt","getDefaultCoords","_prepareSegment","points","_parseLineOptions","options","defaultColor","stroke","color","width","dashStyle","_parseStyle","_applyStyle","_graphics","_","graphic","sharp","_drawElement","_createMainElement","append","_removeElement","element","remove","_updateElement","animate","animationComplete","params","lineElement","_animateComplete","duration","_defaultDuration","_animate","that","lastIndex","length","i","elem","complete","_segments","_drawPoint","groups","_renderer","path","_sortPoints","rotated","sort","_drawSegment","segmentCount","lastSegment","_options","push","_getTrackerSettings","defaultTrackerWidth","_defaultTrackerWidth","strokeWidthFromElements","fill","_getMainPointsFromSegment","_drawTrackerElement","_updateTrackerElement","checkSeriesViewportCoord","axis","coord","range","isArgumentAxis","getArgumentRange","getViewport","getTranslator","translate","categories","getOptions","inverted","lineSeries","getPointCenterByArg","arg","value","getArgumentAxis","getSeriesPairCoord","isArgument","oppositeCoord","nearestPoints","_getNearestPointsByCoord","needValueCoord","k","vy","vx","tmpCoord","_checkAxisVisibleAreaCoord","stepline","_calculateStepLinePoints","coordName","step","isOpposite","oppositeCoordName","spline","_calculateBezierPoints","src","bezierPoints","pointsCopy","checkExtremum","otherPointCoord","pointCoord","controlCoord","forEach","curPoint","leftControlX","leftControlY","rightControlX","rightControlY","nextPoint","x1","x2","y1","y2","xc","yc","shift","xCur","yCur","curIsExtremum","leftPoint","rightPoint","bezierCoordName","bezierOppositeCoordName","getValueAxis","visibleArea","getVisibleArea","_loop","ts","t","_ret","_getNearestPoints","index","indexOf","_getBezierPoints","reduce","seg","concat","preparedPoints","getCenter","_closeSegment","argumentAxisType","valueAxisType","_getTangentPoints","_getRemainingAngle","normAngle","_modifyReflectedPoint","lastPoint","differenceAngle","tangentPoints","betweenAngle","argAxis","paramName","coordParam","isInsideInterval","_ref","getRadius","coords","neighborPoints","getNeighborPoints","stepAngle","k1","b1","k2","b2","quarter","y0","param","getPoints","closed","firstPointCopy","lastPointCopy","rearwardRefPoint","forwardRefPoint","unshift"],"sources":["E:/MisaProject/W2022_06/misa_emis/node_modules/devextreme/esm/viz/series/line_series.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/viz/series/line_series.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    chart as chartScatterSeries,\r\n    polar as polarScatterSeries\r\n} from \"./scatter_series\";\r\nimport {\r\n    clone\r\n} from \"../../core/utils/object\";\r\nimport {\r\n    extend\r\n} from \"../../core/utils/extend\";\r\nimport {\r\n    each\r\n} from \"../../core/utils/iterator\";\r\nimport {\r\n    map,\r\n    normalizeAngle,\r\n    getCosAndSin\r\n} from \"../core/utils\";\r\nimport {\r\n    solveCubicEquation,\r\n    trunc\r\n} from \"../../core/utils/math\";\r\nvar DISCRETE = \"discrete\";\r\nvar {\r\n    round: round,\r\n    sqrt: sqrt,\r\n    pow: pow,\r\n    min: min,\r\n    max: max,\r\n    abs: abs\r\n} = Math;\r\nvar chart = {};\r\nvar polar = {};\r\n\r\nfunction clonePoint(point, newX, newY, newAngle) {\r\n    var p = clone(point);\r\n    p.x = newX;\r\n    p.y = newY;\r\n    p.angle = newAngle;\r\n    return p\r\n}\r\n\r\nfunction getTangentPoint(point, prevPoint, centerPoint, tan, nextStepAngle) {\r\n    var correctAngle = point.angle + nextStepAngle;\r\n    var cosSin = getCosAndSin(correctAngle);\r\n    var x = centerPoint.x + (point.radius + tan * nextStepAngle) * cosSin.cos;\r\n    var y = centerPoint.y - (point.radius + tan * nextStepAngle) * cosSin.sin;\r\n    return clonePoint(prevPoint, x, y, correctAngle)\r\n}\r\n\r\nfunction obtainCubicBezierTCoef(p, p0, p1, p2, p3) {\r\n    var d = p0 - p;\r\n    var c = 3 * p1 - 3 * p0;\r\n    var b = 3 * p2 - 6 * p1 + 3 * p0;\r\n    var a = p3 - 3 * p2 + 3 * p1 - p0;\r\n    return solveCubicEquation(a, b, c, d)\r\n}\r\nvar lineMethods = {\r\n    autoHidePointMarkersEnabled: () => true,\r\n    _applyGroupSettings: function(style, settings, group) {\r\n        settings = extend(settings, style);\r\n        this._applyElementsClipRect(settings);\r\n        group.attr(settings)\r\n    },\r\n    _setGroupsSettings: function(animationEnabled) {\r\n        var style = this._styles.normal;\r\n        this._applyGroupSettings(style.elements, {\r\n            class: \"dxc-elements\"\r\n        }, this._elementsGroup);\r\n        this._bordersGroup && this._applyGroupSettings(style.border, {\r\n            class: \"dxc-borders\"\r\n        }, this._bordersGroup);\r\n        chartScatterSeries._setGroupsSettings.call(this, animationEnabled);\r\n        animationEnabled && this._markersGroup && this._markersGroup.attr({\r\n            opacity: .001\r\n        })\r\n    },\r\n    _createGroups: function() {\r\n        this._createGroup(\"_elementsGroup\", this, this._group);\r\n        this._areBordersVisible() && this._createGroup(\"_bordersGroup\", this, this._group);\r\n        chartScatterSeries._createGroups.call(this)\r\n    },\r\n    _areBordersVisible: function() {\r\n        return false\r\n    },\r\n    _getDefaultSegment: function(segment) {\r\n        return {\r\n            line: map(segment.line || [], (function(pt) {\r\n                return pt.getDefaultCoords()\r\n            }))\r\n        }\r\n    },\r\n    _prepareSegment: function(points) {\r\n        return {\r\n            line: points\r\n        }\r\n    },\r\n    _parseLineOptions: function(options, defaultColor) {\r\n        return {\r\n            stroke: options.color || defaultColor,\r\n            \"stroke-width\": options.width,\r\n            dashStyle: options.dashStyle || \"solid\"\r\n        }\r\n    },\r\n    _parseStyle: function(options, defaultColor) {\r\n        return {\r\n            elements: this._parseLineOptions(options, defaultColor)\r\n        }\r\n    },\r\n    _applyStyle: function(style) {\r\n        this._elementsGroup && this._elementsGroup.attr(style.elements);\r\n        each(this._graphics || [], (function(_, graphic) {\r\n            graphic.line && graphic.line.attr({\r\n                \"stroke-width\": style.elements[\"stroke-width\"]\r\n            }).sharp()\r\n        }))\r\n    },\r\n    _drawElement: function(segment, group) {\r\n        return {\r\n            line: this._createMainElement(segment.line, {\r\n                \"stroke-width\": this._styles.normal.elements[\"stroke-width\"]\r\n            }).append(group)\r\n        }\r\n    },\r\n    _removeElement: function(element) {\r\n        element.line.remove()\r\n    },\r\n    _updateElement: function(element, segment, animate, animationComplete) {\r\n        var params = {\r\n            points: segment.line\r\n        };\r\n        var lineElement = element.line;\r\n        animate ? lineElement.animate(params, {}, animationComplete) : lineElement.attr(params)\r\n    },\r\n    _animateComplete: function() {\r\n        chartScatterSeries._animateComplete.call(this);\r\n        this._markersGroup && this._markersGroup.animate({\r\n            opacity: 1\r\n        }, {\r\n            duration: this._defaultDuration\r\n        })\r\n    },\r\n    _animate: function() {\r\n        var that = this;\r\n        var lastIndex = that._graphics.length - 1;\r\n        each(that._graphics || [], (function(i, elem) {\r\n            var complete;\r\n            if (i === lastIndex) {\r\n                complete = function() {\r\n                    that._animateComplete()\r\n                }\r\n            }\r\n            that._updateElement(elem, that._segments[i], true, complete)\r\n        }))\r\n    },\r\n    _drawPoint: function(options) {\r\n        chartScatterSeries._drawPoint.call(this, {\r\n            point: options.point,\r\n            groups: options.groups\r\n        })\r\n    },\r\n    _createMainElement: function(points, settings) {\r\n        return this._renderer.path(points, \"line\").attr(settings)\r\n    },\r\n    _sortPoints: function(points, rotated) {\r\n        return rotated ? points.sort((function(p1, p2) {\r\n            return p2.y - p1.y\r\n        })) : points.sort((function(p1, p2) {\r\n            return p1.x - p2.x\r\n        }))\r\n    },\r\n    _drawSegment: function(points, animationEnabled, segmentCount, lastSegment) {\r\n        var rotated = this._options.rotated;\r\n        var segment = this._prepareSegment(points, rotated, lastSegment);\r\n        this._segments.push(segment);\r\n        if (!this._graphics[segmentCount]) {\r\n            this._graphics[segmentCount] = this._drawElement(animationEnabled ? this._getDefaultSegment(segment) : segment, this._elementsGroup)\r\n        } else if (!animationEnabled) {\r\n            this._updateElement(this._graphics[segmentCount], segment)\r\n        }\r\n    },\r\n    _getTrackerSettings: function() {\r\n        var defaultTrackerWidth = this._defaultTrackerWidth;\r\n        var strokeWidthFromElements = this._styles.normal.elements[\"stroke-width\"];\r\n        return {\r\n            \"stroke-width\": strokeWidthFromElements > defaultTrackerWidth ? strokeWidthFromElements : defaultTrackerWidth,\r\n            fill: \"none\"\r\n        }\r\n    },\r\n    _getMainPointsFromSegment: function(segment) {\r\n        return segment.line\r\n    },\r\n    _drawTrackerElement: function(segment) {\r\n        return this._createMainElement(this._getMainPointsFromSegment(segment), this._getTrackerSettings(segment))\r\n    },\r\n    _updateTrackerElement: function(segment, element) {\r\n        var settings = this._getTrackerSettings(segment);\r\n        settings.points = this._getMainPointsFromSegment(segment);\r\n        element.attr(settings)\r\n    },\r\n    checkSeriesViewportCoord(axis, coord) {\r\n        if (!chartScatterSeries.checkSeriesViewportCoord.call(this)) {\r\n            return false\r\n        }\r\n        var range = axis.isArgumentAxis ? this.getArgumentRange() : this.getViewport();\r\n        var min = axis.getTranslator().translate(range.categories ? range.categories[0] : range.min);\r\n        var max = axis.getTranslator().translate(range.categories ? range.categories[range.categories.length - 1] : range.max);\r\n        var rotated = this.getOptions().rotated;\r\n        var inverted = axis.getOptions().inverted;\r\n        return axis.isArgumentAxis && (!rotated && !inverted || rotated && inverted) || !axis.isArgumentAxis && (rotated && !inverted || !rotated && inverted) ? coord >= min && coord <= max : coord >= max && coord <= min\r\n    }\r\n};\r\nvar lineSeries = chart.line = extend({}, chartScatterSeries, lineMethods, {\r\n    getPointCenterByArg(arg) {\r\n        var value = this.getArgumentAxis().getTranslator().translate(arg);\r\n        return {\r\n            x: value,\r\n            y: value\r\n        }\r\n    },\r\n    getSeriesPairCoord(coord, isArgument) {\r\n        var oppositeCoord = null;\r\n        var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);\r\n        var needValueCoord = isArgument && !this._options.rotated || !isArgument && this._options.rotated;\r\n        for (var i = 0; i < nearestPoints.length; i++) {\r\n            var p = nearestPoints[i];\r\n            var k = (p[1].vy - p[0].vy) / (p[1].vx - p[0].vx);\r\n            var b = p[0].vy - p[0].vx * k;\r\n            var tmpCoord = void 0;\r\n            if (p[1].vx - p[0].vx === 0) {\r\n                tmpCoord = needValueCoord ? p[0].vy : p[0].vx\r\n            } else {\r\n                tmpCoord = needValueCoord ? k * coord + b : (coord - b) / k\r\n            }\r\n            if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\r\n                oppositeCoord = tmpCoord;\r\n                break\r\n            }\r\n        }\r\n        return oppositeCoord\r\n    }\r\n});\r\nchart.stepline = extend({}, lineSeries, {\r\n    _calculateStepLinePoints(points) {\r\n        var segment = [];\r\n        var coordName = this._options.rotated ? \"x\" : \"y\";\r\n        each(points, (function(i, pt) {\r\n            var point;\r\n            if (!i) {\r\n                segment.push(pt);\r\n                return\r\n            }\r\n            var step = segment[segment.length - 1][coordName];\r\n            if (step !== pt[coordName]) {\r\n                point = clone(pt);\r\n                point[coordName] = step;\r\n                segment.push(point)\r\n            }\r\n            segment.push(pt)\r\n        }));\r\n        return segment\r\n    },\r\n    _prepareSegment: function(points) {\r\n        return lineSeries._prepareSegment(this._calculateStepLinePoints(points))\r\n    },\r\n    getSeriesPairCoord(coord, isArgument) {\r\n        var oppositeCoord;\r\n        var rotated = this._options.rotated;\r\n        var isOpposite = !isArgument && !rotated || isArgument && rotated;\r\n        var coordName = !isOpposite ? \"vx\" : \"vy\";\r\n        var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\r\n        var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);\r\n        for (var i = 0; i < nearestPoints.length; i++) {\r\n            var p = nearestPoints[i];\r\n            var tmpCoord = void 0;\r\n            if (isArgument) {\r\n                tmpCoord = coord !== p[1][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName]\r\n            } else {\r\n                tmpCoord = coord === p[0][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName]\r\n            }\r\n            if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\r\n                oppositeCoord = tmpCoord;\r\n                break\r\n            }\r\n        }\r\n        return oppositeCoord\r\n    }\r\n});\r\nchart.spline = extend({}, lineSeries, {\r\n    _calculateBezierPoints: function(src, rotated) {\r\n        var bezierPoints = [];\r\n        var pointsCopy = src;\r\n        var checkExtremum = function(otherPointCoord, pointCoord, controlCoord) {\r\n            return otherPointCoord > pointCoord && controlCoord > otherPointCoord || otherPointCoord < pointCoord && controlCoord < otherPointCoord ? otherPointCoord : controlCoord\r\n        };\r\n        if (1 !== pointsCopy.length) {\r\n            pointsCopy.forEach((function(curPoint, i) {\r\n                var leftControlX;\r\n                var leftControlY;\r\n                var rightControlX;\r\n                var rightControlY;\r\n                var prevPoint = pointsCopy[i - 1];\r\n                var nextPoint = pointsCopy[i + 1];\r\n                var x1;\r\n                var x2;\r\n                var y1;\r\n                var y2;\r\n                var a;\r\n                var b;\r\n                var c;\r\n                var xc;\r\n                var yc;\r\n                var shift;\r\n                if (!i || i === pointsCopy.length - 1) {\r\n                    bezierPoints.push(curPoint, curPoint);\r\n                    return\r\n                }\r\n                var xCur = curPoint.x;\r\n                var yCur = curPoint.y;\r\n                x1 = prevPoint.x;\r\n                x2 = nextPoint.x;\r\n                y1 = prevPoint.y;\r\n                y2 = nextPoint.y;\r\n                var curIsExtremum = !!(!rotated && (yCur <= prevPoint.y && yCur <= nextPoint.y || yCur >= prevPoint.y && yCur >= nextPoint.y) || rotated && (xCur <= prevPoint.x && xCur <= nextPoint.x || xCur >= prevPoint.x && xCur >= nextPoint.x));\r\n                if (curIsExtremum) {\r\n                    if (!rotated) {\r\n                        rightControlY = leftControlY = yCur;\r\n                        rightControlX = (xCur + nextPoint.x) / 2;\r\n                        leftControlX = (xCur + prevPoint.x) / 2\r\n                    } else {\r\n                        rightControlX = leftControlX = xCur;\r\n                        rightControlY = (yCur + nextPoint.y) / 2;\r\n                        leftControlY = (yCur + prevPoint.y) / 2\r\n                    }\r\n                } else {\r\n                    a = y2 - y1;\r\n                    b = x1 - x2;\r\n                    c = y1 * x2 - x1 * y2;\r\n                    if (!rotated) {\r\n                        if (!b) {\r\n                            bezierPoints.push(curPoint, curPoint, curPoint);\r\n                            return\r\n                        }\r\n                        xc = xCur;\r\n                        yc = -1 * (a * xc + c) / b;\r\n                        shift = yc - yCur;\r\n                        y1 -= shift;\r\n                        y2 -= shift\r\n                    } else {\r\n                        if (!a) {\r\n                            bezierPoints.push(curPoint, curPoint, curPoint);\r\n                            return\r\n                        }\r\n                        yc = yCur;\r\n                        xc = -1 * (b * yc + c) / a;\r\n                        shift = xc - xCur;\r\n                        x1 -= shift;\r\n                        x2 -= shift\r\n                    }\r\n                    rightControlX = (xCur + .5 * x2) / 1.5;\r\n                    rightControlY = (yCur + .5 * y2) / 1.5;\r\n                    leftControlX = (xCur + .5 * x1) / 1.5;\r\n                    leftControlY = (yCur + .5 * y1) / 1.5\r\n                }\r\n                if (!rotated) {\r\n                    leftControlY = checkExtremum(prevPoint.y, yCur, leftControlY);\r\n                    rightControlY = checkExtremum(nextPoint.y, yCur, rightControlY)\r\n                } else {\r\n                    leftControlX = checkExtremum(prevPoint.x, xCur, leftControlX);\r\n                    rightControlX = checkExtremum(nextPoint.x, xCur, rightControlX)\r\n                }\r\n                var leftPoint = clonePoint(curPoint, leftControlX, leftControlY);\r\n                var rightPoint = clonePoint(curPoint, rightControlX, rightControlY);\r\n                bezierPoints.push(leftPoint, curPoint, rightPoint)\r\n            }))\r\n        } else {\r\n            bezierPoints.push(pointsCopy[0])\r\n        }\r\n        return bezierPoints\r\n    },\r\n    _prepareSegment: function(points, rotated) {\r\n        return lineSeries._prepareSegment(this._calculateBezierPoints(points, rotated))\r\n    },\r\n    _createMainElement: function(points, settings) {\r\n        return this._renderer.path(points, \"bezier\").attr(settings)\r\n    },\r\n    getSeriesPairCoord(coord, isArgument) {\r\n        var oppositeCoord = null;\r\n        var isOpposite = !isArgument && !this._options.rotated || isArgument && this._options.rotated;\r\n        var coordName = !isOpposite ? \"vx\" : \"vy\";\r\n        var bezierCoordName = !isOpposite ? \"x\" : \"y\";\r\n        var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\r\n        var bezierOppositeCoordName = !isOpposite ? \"y\" : \"x\";\r\n        var axis = !isArgument ? this.getArgumentAxis() : this.getValueAxis();\r\n        var visibleArea = axis.getVisibleArea();\r\n        var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);\r\n        var _loop = function(i) {\r\n            var p = nearestPoints[i];\r\n            if (1 === p.length) {\r\n                visibleArea[0] <= p[0][oppositeCoordName] && visibleArea[1] >= p[0][oppositeCoordName] && (oppositeCoord = p[0][oppositeCoordName])\r\n            } else {\r\n                var ts = obtainCubicBezierTCoef(coord, p[0][coordName], p[1][bezierCoordName], p[2][bezierCoordName], p[3][coordName]);\r\n                ts.forEach(t => {\r\n                    if (t >= 0 && t <= 1) {\r\n                        var tmpCoord = Math.pow(1 - t, 3) * p[0][oppositeCoordName] + 3 * Math.pow(1 - t, 2) * t * p[1][bezierOppositeCoordName] + 3 * (1 - t) * t * t * p[2][bezierOppositeCoordName] + t * t * t * p[3][oppositeCoordName];\r\n                        if (visibleArea[0] <= tmpCoord && visibleArea[1] >= tmpCoord) {\r\n                            oppositeCoord = tmpCoord\r\n                        }\r\n                    }\r\n                })\r\n            }\r\n            if (null !== oppositeCoord) {\r\n                return \"break\"\r\n            }\r\n        };\r\n        for (var i = 0; i < nearestPoints.length; i++) {\r\n            var _ret = _loop(i);\r\n            if (\"break\" === _ret) {\r\n                break\r\n            }\r\n        }\r\n        return oppositeCoord\r\n    },\r\n    _getNearestPoints(point, nextPoint, bezierPoints) {\r\n        var index = bezierPoints.indexOf(point);\r\n        return [point, bezierPoints[index + 1], bezierPoints[index + 2], nextPoint]\r\n    },\r\n    _getBezierPoints() {\r\n        return this._segments.length > 0 ? this._segments.reduce((a, seg) => a.concat(seg.line), []) : []\r\n    }\r\n});\r\npolar.line = extend({}, polarScatterSeries, lineMethods, {\r\n    _sortPoints: function(points) {\r\n        return points\r\n    },\r\n    _prepareSegment: function(points, rotated, lastSegment) {\r\n        var preparedPoints = [];\r\n        var centerPoint = this.getValueAxis().getCenter();\r\n        var i;\r\n        lastSegment && this._closeSegment(points);\r\n        if (this.argumentAxisType !== DISCRETE && this.valueAxisType !== DISCRETE) {\r\n            for (i = 1; i < points.length; i++) {\r\n                preparedPoints = preparedPoints.concat(this._getTangentPoints(points[i], points[i - 1], centerPoint))\r\n            }\r\n            if (!preparedPoints.length) {\r\n                preparedPoints = points\r\n            }\r\n        } else {\r\n            return lineSeries._prepareSegment.call(this, points)\r\n        }\r\n        return {\r\n            line: preparedPoints\r\n        }\r\n    },\r\n    _getRemainingAngle: function(angle) {\r\n        var normAngle = normalizeAngle(angle);\r\n        return angle >= 0 ? 360 - normAngle : -normAngle\r\n    },\r\n    _closeSegment(points) {\r\n        var point;\r\n        if (this._segments.length) {\r\n            point = this._segments[0].line[0]\r\n        } else {\r\n            point = clonePoint(points[0], points[0].x, points[0].y, points[0].angle)\r\n        }\r\n        point = this._modifyReflectedPoint(point, points[points.length - 1]);\r\n        if (point) {\r\n            points.push(point)\r\n        }\r\n    },\r\n    _modifyReflectedPoint(point, lastPoint) {\r\n        if (lastPoint.angle === point.angle) {\r\n            return\r\n        }\r\n        if (normalizeAngle(round(lastPoint.angle)) === normalizeAngle(round(point.angle))) {\r\n            point.angle = lastPoint.angle\r\n        } else {\r\n            var differenceAngle = lastPoint.angle - point.angle;\r\n            point.angle = lastPoint.angle + this._getRemainingAngle(differenceAngle)\r\n        }\r\n        return point\r\n    },\r\n    _getTangentPoints: function(point, prevPoint, centerPoint) {\r\n        var tangentPoints = [];\r\n        var betweenAngle = Math.round(prevPoint.angle - point.angle);\r\n        var tan = (prevPoint.radius - point.radius) / betweenAngle;\r\n        var i;\r\n        if (0 === betweenAngle) {\r\n            tangentPoints = [prevPoint, point]\r\n        } else if (betweenAngle > 0) {\r\n            for (i = betweenAngle; i >= 0; i--) {\r\n                tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, i))\r\n            }\r\n        } else {\r\n            for (i = 0; i >= betweenAngle; i--) {\r\n                tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, betweenAngle - i))\r\n            }\r\n        }\r\n        return tangentPoints\r\n    },\r\n    getSeriesPairCoord(params, isArgument) {\r\n        var argAxis = this.getArgumentAxis();\r\n        var paramName = isArgument ? \"angle\" : \"radius\";\r\n        var coordParam = params[paramName];\r\n        var centerPoint = argAxis.getCenter();\r\n        var isInsideInterval = (prevPoint, point, _ref) => {\r\n            var {\r\n                x: x,\r\n                y: y\r\n            } = _ref;\r\n            return (p1 = {\r\n                x: x,\r\n                y: y\r\n            }, p2 = centerPoint, sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2))) <= argAxis.getRadius() && min(prevPoint.x, point.x) <= x && max(prevPoint.x, point.x) >= x && min(prevPoint.y, point.y) <= y && max(prevPoint.y, point.y) >= y;\r\n            var p1, p2\r\n        };\r\n        var coords;\r\n        var neighborPoints = this.getNeighborPoints(coordParam, paramName);\r\n        if (1 === neighborPoints.length) {\r\n            coords = neighborPoints[0]\r\n        } else if (neighborPoints.length > 1) {\r\n            var prevPoint = neighborPoints[0];\r\n            var point = neighborPoints[1];\r\n            if (this.argumentAxisType !== DISCRETE && this.valueAxisType !== DISCRETE) {\r\n                var tan;\r\n                var stepAngle;\r\n                if (isArgument) {\r\n                    tan = (prevPoint.radius - point.radius) / (prevPoint.angle - point.angle);\r\n                    stepAngle = coordParam - point.angle\r\n                } else {\r\n                    tan = (prevPoint.radius - point.radius) / (prevPoint.angle - point.angle);\r\n                    stepAngle = (coordParam - point.radius) / tan\r\n                }\r\n                coords = getTangentPoint(point, prevPoint, centerPoint, tan, stepAngle)\r\n            } else if (isArgument) {\r\n                var cosSin = getCosAndSin(-coordParam);\r\n                var k1 = (point.y - prevPoint.y) / (point.x - prevPoint.x);\r\n                var b1 = prevPoint.y - prevPoint.x * k1;\r\n                var k2 = cosSin.sin / cosSin.cos;\r\n                var b2 = centerPoint.y - k2 * centerPoint.x;\r\n                var x = (b2 - b1) / (k1 - k2);\r\n                var y = k1 * x + b1;\r\n                if (isInsideInterval(prevPoint, point, {\r\n                        x: x,\r\n                        y: y\r\n                    })) {\r\n                    var quarter = abs(trunc((360 + coordParam) / 90) % 4);\r\n                    if (0 === quarter && x >= centerPoint.x && y <= centerPoint.y || 1 === quarter && x <= centerPoint.x && y <= centerPoint.y || 2 === quarter && x <= centerPoint.x && y >= centerPoint.y || 3 === quarter && x >= centerPoint.x && y >= centerPoint.y) {\r\n                        coords = {\r\n                            x: x,\r\n                            y: y\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                var k = (point.y - prevPoint.y) / (point.x - prevPoint.x);\r\n                var y0 = prevPoint.y - prevPoint.x * k;\r\n                var a = 1 + k * k;\r\n                var b = -2 * centerPoint.x + 2 * k * y0 - 2 * k * centerPoint.y;\r\n                var c = -pow(coordParam, 2) + pow(y0 - centerPoint.y, 2) + pow(centerPoint.x, 2);\r\n                var d = b * b - 4 * a * c;\r\n                if (d >= 0) {\r\n                    var x1 = (-b - sqrt(d)) / (2 * a);\r\n                    var x2 = (-b + sqrt(d)) / (2 * a);\r\n                    var y1 = k * x1 + y0;\r\n                    var y2 = k * x2 + y0;\r\n                    coords = isInsideInterval(prevPoint, point, {\r\n                        x: x1,\r\n                        y: y1\r\n                    }) ? {\r\n                        x: x1,\r\n                        y: y1\r\n                    } : isInsideInterval(prevPoint, point, {\r\n                        x: x2,\r\n                        y: y2\r\n                    }) ? {\r\n                        x: x2,\r\n                        y: y2\r\n                    } : void 0\r\n                }\r\n            }\r\n        }\r\n        return coords\r\n    },\r\n    getNeighborPoints(param, paramName) {\r\n        var points = this.getPoints();\r\n        var neighborPoints = [];\r\n        if (this.getOptions().closed) {\r\n            points = extend(true, [], points);\r\n            var lastPoint = points[points.length - 1];\r\n            var firstPointCopy = clonePoint(points[0], points[0].x, points[0].y, points[0].angle);\r\n            var lastPointCopy = clonePoint(lastPoint, lastPoint.x, lastPoint.y, lastPoint.angle);\r\n            var rearwardRefPoint = this._modifyReflectedPoint(firstPointCopy, lastPoint);\r\n            var forwardRefPoint = this._modifyReflectedPoint(lastPointCopy, points[0]);\r\n            if (forwardRefPoint) {\r\n                points.unshift(forwardRefPoint)\r\n            }\r\n            if (rearwardRefPoint) {\r\n                points.push(rearwardRefPoint)\r\n            }\r\n        }\r\n        for (var i = 1; i < points.length; i++) {\r\n            if (points[i - 1][paramName] === param) {\r\n                neighborPoints.push(points[i - 1])\r\n            } else if (points[i][paramName] === param) {\r\n                neighborPoints.push(points[i])\r\n            } else if (points[i][paramName] > param && points[i - 1][paramName] < param || points[i - 1][paramName] > param && points[i][paramName] < param) {\r\n                neighborPoints.push(points[i - 1]);\r\n                neighborPoints.push(points[i])\r\n            }\r\n            if (neighborPoints.length > 0) {\r\n                break\r\n            }\r\n        }\r\n        return neighborPoints\r\n    }\r\n});\r\nexport {\r\n    chart,\r\n    polar\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}