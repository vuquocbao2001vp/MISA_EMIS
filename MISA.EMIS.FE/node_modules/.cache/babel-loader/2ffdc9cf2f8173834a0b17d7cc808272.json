{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/sankey/layout.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nvar _SPLINE_TENSION = .3;\nvar _ALIGNMENT_CENTER = \"center\";\nvar _ALIGNMENT_BOTTOM = \"bottom\";\nvar _ALIGNMENT_DEFAULT = _ALIGNMENT_CENTER;\nimport graphModule from \"./graph\";\nimport validatorModule from \"./data_validator\";\nexport var layout = {\n  _weightPerPixel: null,\n  _getCascadeIdx: function (nodeTitle, cascadesConfig) {\n    var nodeInfo = cascadesConfig.filter(c => c.name === nodeTitle)[0];\n\n    if (nodeInfo.outgoing.length > 0) {\n      return nodeInfo.lp;\n    } else {\n      return graphModule.routines.maxOfArray(cascadesConfig.map(c => c.lp));\n    }\n  },\n  _getInWeightForNode: function (nodeTitle, links) {\n    var w = 0;\n    links.forEach(link => {\n      if (link[1] === nodeTitle) {\n        w += link[2];\n      }\n    });\n    return w;\n  },\n  _getOutWeightForNode: function (nodeTitle, links) {\n    var w = 0;\n    links.forEach(link => {\n      if (link[0] === nodeTitle) {\n        w += link[2];\n      }\n    });\n    return w;\n  },\n  _computeCascades: function (links) {\n    var cascadesConfig = graphModule.struct.computeLongestPaths(links);\n    var maxCascade = graphModule.routines.maxOfArray(cascadesConfig.map(c => c.lp));\n    var cascades = [];\n\n    for (var i = 0; i < maxCascade + 1; i++) {\n      cascades.push({});\n    }\n\n    links.forEach(link => {\n      var cascade = cascades[this._getCascadeIdx(link[0], cascadesConfig)];\n\n      if (!cascade[link[0]]) {\n        cascade[link[0]] = {\n          nodeTitle: link[0]\n        };\n      }\n\n      cascade = cascades[this._getCascadeIdx(link[1], cascadesConfig)];\n\n      if (!cascade[link[1]]) {\n        cascade[link[1]] = {\n          nodeTitle: link[1]\n        };\n      }\n    });\n    cascades.forEach(cascade => {\n      Object.keys(cascade).forEach(nodeTitle => {\n        var node = cascade[nodeTitle];\n        node.inWeight = this._getInWeightForNode(node.nodeTitle, links);\n        node.outWeight = this._getOutWeightForNode(node.nodeTitle, links);\n        node.maxWeight = Math.max(node.inWeight, node.outWeight);\n      });\n    });\n    return cascades;\n  },\n  _getWeightForCascade: function (cascades, cascadeIdx) {\n    var wMax = 0;\n    var cascade = cascades[cascadeIdx];\n    Object.keys(cascade).forEach(nodeTitle => {\n      wMax += Math.max(cascade[nodeTitle].inWeight, cascade[nodeTitle].outWeight);\n    });\n    return wMax;\n  },\n  _getMaxWeightThroughCascades: function (cascades) {\n    var max = [];\n    cascades.forEach(cascade => {\n      var mW = 0;\n      Object.keys(cascade).forEach(nodeTitle => {\n        var node = cascade[nodeTitle];\n        mW += Math.max(node.inWeight, node.outWeight);\n      });\n      max.push(mW);\n    });\n    return graphModule.routines.maxOfArray(max);\n  },\n  _computeNodes: function (cascades, options) {\n    var rects = [];\n\n    var maxWeight = this._getMaxWeightThroughCascades(cascades);\n\n    var maxNodeNum = graphModule.routines.maxOfArray(cascades.map(nodesInCascade => Object.keys(nodesInCascade).length));\n    var nodePadding = options.nodePadding;\n    var heightAvailable = options.height - nodePadding * (maxNodeNum - 1);\n\n    if (heightAvailable < 0) {\n      nodePadding = 0;\n      heightAvailable = options.height - nodePadding * (maxNodeNum - 1);\n    }\n\n    this._weightPerPixel = maxWeight / heightAvailable;\n    var cascadeIdx = 0;\n    cascades.forEach(cascade => {\n      var cascadeRects = [];\n      var y = 0;\n      var nodesInCascade = Object.keys(cascade).length;\n      var cascadeHeight = this._getWeightForCascade(cascades, cascadeIdx) / this._weightPerPixel + nodePadding * (nodesInCascade - 1);\n      var cascadeAlign;\n\n      if (Array.isArray(options.nodeAlign)) {\n        cascadeAlign = cascadeIdx < options.nodeAlign.length ? options.nodeAlign[cascadeIdx] : _ALIGNMENT_DEFAULT;\n      } else {\n        cascadeAlign = options.nodeAlign;\n      }\n\n      if (cascadeAlign === _ALIGNMENT_BOTTOM) {\n        y = options.height - cascadeHeight;\n      } else if (cascadeAlign === _ALIGNMENT_CENTER) {\n        y = .5 * (options.height - cascadeHeight);\n      }\n\n      y = Math.round(y);\n      Object.keys(cascade).forEach(nodeTitle => {\n        cascade[nodeTitle].sort = this._sort && Object.prototype.hasOwnProperty.call(this._sort, nodeTitle) ? this._sort[nodeTitle] : 1;\n      });\n      Object.keys(cascade).sort((a, b) => cascade[a].sort - cascade[b].sort).forEach(nodeTitle => {\n        var node = cascade[nodeTitle];\n        var height = Math.floor(heightAvailable * node.maxWeight / maxWeight);\n        var x = Math.round(cascadeIdx * options.width / (cascades.length - 1)) - (0 === cascadeIdx ? 0 : options.nodeWidth);\n        var rect = {};\n        rect._name = nodeTitle;\n        rect.width = options.nodeWidth;\n        rect.height = height;\n        rect.x = x + options.x;\n        rect.y = y + options.y;\n        y += height + nodePadding;\n        cascadeRects.push(rect);\n      });\n      cascadeIdx++;\n      rects.push(cascadeRects);\n    });\n    return rects;\n  },\n  _findRectByName: function (rects, name) {\n    for (var c = 0; c < rects.length; c++) {\n      for (var r = 0; r < rects[c].length; r++) {\n        if (name === rects[c][r]._name) {\n          return rects[c][r];\n        }\n      }\n    }\n\n    return null;\n  },\n  _findIndexByName: function (rects, nodeTitle) {\n    var index = 0;\n\n    for (var c = 0; c < rects.length; c++) {\n      for (var r = 0; r < rects[c].length; r++) {\n        if (nodeTitle === rects[c][r]._name) {\n          return index;\n        }\n\n        index++;\n      }\n    }\n\n    return null;\n  },\n  _computeLinks: function (links, rects, cascades) {\n    var yOffsets = {};\n    var paths = [];\n    var result = [];\n    cascades.forEach(cascade => {\n      Object.keys(cascade).forEach(nodeTitle => {\n        yOffsets[nodeTitle] = {\n          in: 0,\n          out: 0\n        };\n      });\n    });\n    rects.forEach(rectsOfCascade => {\n      rectsOfCascade.forEach(nodeRect => {\n        var nodeTitle = nodeRect._name;\n\n        var rectFrom = this._findRectByName(rects, nodeTitle);\n\n        var linksFromNode = links.filter(link => link[0] === nodeTitle);\n        linksFromNode.forEach(link => {\n          link.sort = this._findIndexByName(rects, link[1]);\n        });\n        linksFromNode.sort((a, b) => a.sort - b.sort).forEach(link => {\n          var rectTo = this._findRectByName(rects, link[1]);\n\n          var height = Math.round(link[2] / this._weightPerPixel);\n          var yOffsetFrom = yOffsets[link[0]].out;\n          var yOffsetTo = yOffsets[link[1]].in;\n          var heightFrom = yOffsets[link[0]].out + height > rectFrom.height ? rectFrom.height - yOffsets[link[0]].out : height;\n          var heightTo = yOffsets[link[1]].in + height > rectTo.height ? rectTo.height - yOffsets[link[1]].in : height;\n          paths.push({\n            from: {\n              x: rectFrom.x,\n              y: rectFrom.y + yOffsetFrom,\n              width: rectFrom.width,\n              height: heightFrom,\n              node: rectFrom,\n              weight: link[2]\n            },\n            to: {\n              x: rectTo.x,\n              y: rectTo.y + yOffsetTo,\n              width: rectTo.width,\n              height: heightTo,\n              node: rectTo\n            }\n          });\n          yOffsets[link[0]].out += height;\n          yOffsets[link[1]].in += height;\n        });\n      });\n    });\n    paths.forEach(link => {\n      var path = {\n        d: this._spline(link.from, link.to),\n        _boundingRect: {\n          x: link.from.x + link.from.width,\n          y: Math.min(link.from.y, link.to.y),\n          width: link.to.x - (link.from.x + link.from.width),\n          height: Math.max(link.from.x + link.from.height, link.to.y + link.to.height) - Math.min(link.from.y, link.to.y)\n        },\n        _weight: link.from.weight,\n        _from: link.from.node,\n        _to: link.to.node\n      };\n      result.push(path);\n    });\n\n    this._fitAllNodesHeight(rects, paths);\n\n    return result;\n  },\n  _fitNodeHeight: function (nodeName, nodeRects, paths) {\n    var targetRect = this._findRectByName(nodeRects, nodeName);\n\n    var heightOfLinksSummaryIn = 0;\n    var heightOfLinksSummaryOut = 0;\n    paths.forEach(function (path) {\n      if (path.from.node._name === nodeName) {\n        heightOfLinksSummaryOut += path.from.height;\n      }\n\n      if (path.to.node._name === nodeName) {\n        heightOfLinksSummaryIn += path.to.height;\n      }\n    });\n    targetRect.height = Math.max(heightOfLinksSummaryIn, heightOfLinksSummaryOut);\n  },\n  _fitAllNodesHeight: function (nodeRects, paths) {\n    for (var c = 0; c < nodeRects.length; c++) {\n      for (var r = 0; r < nodeRects[c].length; r++) {\n        this._fitNodeHeight(nodeRects[c][r]._name, nodeRects, paths);\n      }\n    }\n  },\n  _spline: function (rectLeft, rectRight) {\n    var p_UpLeft = {\n      x: rectLeft.x + rectLeft.width,\n      y: rectLeft.y\n    };\n    var p_DownLeft = {\n      x: rectLeft.x + rectLeft.width,\n      y: rectLeft.y + rectLeft.height\n    };\n    var p_UpRight = {\n      x: rectRight.x,\n      y: rectRight.y\n    };\n    var p_DownRight = {\n      x: rectRight.x,\n      y: rectRight.y + rectRight.height\n    };\n    var curve_width = _SPLINE_TENSION * (p_UpRight.x - p_UpLeft.x);\n    var result = \"M \".concat(p_UpLeft.x, \" \").concat(p_UpLeft.y, \" C \").concat(p_UpLeft.x + curve_width, \" \").concat(p_UpLeft.y, \" \").concat(p_UpRight.x - curve_width, \" \").concat(p_UpRight.y, \" \").concat(p_UpRight.x, \" \").concat(p_UpRight.y, \" L \").concat(p_DownRight.x, \" \").concat(p_DownRight.y, \" C \").concat(p_DownRight.x - curve_width, \" \").concat(p_DownRight.y, \" \").concat(p_DownLeft.x + curve_width, \" \").concat(p_DownLeft.y, \" \").concat(p_DownLeft.x, \" \").concat(p_DownLeft.y, \" Z\");\n    return result;\n  },\n  computeLayout: function (linksData, sortData, options, incidentOccurred) {\n    this._sort = sortData;\n    var result = {};\n    var validateResult = validatorModule.validate(linksData, incidentOccurred);\n\n    if (!validateResult) {\n      result.cascades = this._computeCascades(linksData);\n      result.nodes = this._computeNodes(result.cascades, {\n        width: options.availableRect.width,\n        height: options.availableRect.height,\n        x: options.availableRect.x,\n        y: options.availableRect.y,\n        nodePadding: options.nodePadding,\n        nodeWidth: options.nodeWidth,\n        nodeAlign: options.nodeAlign\n      });\n      result.links = this._computeLinks(linksData, result.nodes, result.cascades);\n    } else {\n      result.error = validateResult;\n    }\n\n    return result;\n  },\n  overlap: function (box1, box2) {\n    return !(box2.x > box1.x + box1.width || box2.x + box2.width < box1.x || box2.y >= box1.y + box1.height || box2.y + box2.height <= box1.y);\n  }\n};","map":{"version":3,"names":["_SPLINE_TENSION","_ALIGNMENT_CENTER","_ALIGNMENT_BOTTOM","_ALIGNMENT_DEFAULT","graphModule","validatorModule","layout","_weightPerPixel","_getCascadeIdx","nodeTitle","cascadesConfig","nodeInfo","filter","c","name","outgoing","length","lp","routines","maxOfArray","map","_getInWeightForNode","links","w","forEach","link","_getOutWeightForNode","_computeCascades","struct","computeLongestPaths","maxCascade","cascades","i","push","cascade","Object","keys","node","inWeight","outWeight","maxWeight","Math","max","_getWeightForCascade","cascadeIdx","wMax","_getMaxWeightThroughCascades","mW","_computeNodes","options","rects","maxNodeNum","nodesInCascade","nodePadding","heightAvailable","height","cascadeRects","y","cascadeHeight","cascadeAlign","Array","isArray","nodeAlign","round","sort","_sort","prototype","hasOwnProperty","call","a","b","floor","x","width","nodeWidth","rect","_name","_findRectByName","r","_findIndexByName","index","_computeLinks","yOffsets","paths","result","in","out","rectsOfCascade","nodeRect","rectFrom","linksFromNode","rectTo","yOffsetFrom","yOffsetTo","heightFrom","heightTo","from","weight","to","path","d","_spline","_boundingRect","min","_weight","_from","_to","_fitAllNodesHeight","_fitNodeHeight","nodeName","nodeRects","targetRect","heightOfLinksSummaryIn","heightOfLinksSummaryOut","rectLeft","rectRight","p_UpLeft","p_DownLeft","p_UpRight","p_DownRight","curve_width","concat","computeLayout","linksData","sortData","incidentOccurred","validateResult","validate","nodes","availableRect","error","overlap","box1","box2"],"sources":["E:/MisaProject/W2022_06/misa_emis/node_modules/devextreme/esm/viz/sankey/layout.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/viz/sankey/layout.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nvar _SPLINE_TENSION = .3;\r\nvar _ALIGNMENT_CENTER = \"center\";\r\nvar _ALIGNMENT_BOTTOM = \"bottom\";\r\nvar _ALIGNMENT_DEFAULT = _ALIGNMENT_CENTER;\r\nimport graphModule from \"./graph\";\r\nimport validatorModule from \"./data_validator\";\r\nexport var layout = {\r\n    _weightPerPixel: null,\r\n    _getCascadeIdx: function(nodeTitle, cascadesConfig) {\r\n        var nodeInfo = cascadesConfig.filter(c => c.name === nodeTitle)[0];\r\n        if (nodeInfo.outgoing.length > 0) {\r\n            return nodeInfo.lp\r\n        } else {\r\n            return graphModule.routines.maxOfArray(cascadesConfig.map(c => c.lp))\r\n        }\r\n    },\r\n    _getInWeightForNode: function(nodeTitle, links) {\r\n        var w = 0;\r\n        links.forEach(link => {\r\n            if (link[1] === nodeTitle) {\r\n                w += link[2]\r\n            }\r\n        });\r\n        return w\r\n    },\r\n    _getOutWeightForNode: function(nodeTitle, links) {\r\n        var w = 0;\r\n        links.forEach(link => {\r\n            if (link[0] === nodeTitle) {\r\n                w += link[2]\r\n            }\r\n        });\r\n        return w\r\n    },\r\n    _computeCascades: function(links) {\r\n        var cascadesConfig = graphModule.struct.computeLongestPaths(links);\r\n        var maxCascade = graphModule.routines.maxOfArray(cascadesConfig.map(c => c.lp));\r\n        var cascades = [];\r\n        for (var i = 0; i < maxCascade + 1; i++) {\r\n            cascades.push({})\r\n        }\r\n        links.forEach(link => {\r\n            var cascade = cascades[this._getCascadeIdx(link[0], cascadesConfig)];\r\n            if (!cascade[link[0]]) {\r\n                cascade[link[0]] = {\r\n                    nodeTitle: link[0]\r\n                }\r\n            }\r\n            cascade = cascades[this._getCascadeIdx(link[1], cascadesConfig)];\r\n            if (!cascade[link[1]]) {\r\n                cascade[link[1]] = {\r\n                    nodeTitle: link[1]\r\n                }\r\n            }\r\n        });\r\n        cascades.forEach(cascade => {\r\n            Object.keys(cascade).forEach(nodeTitle => {\r\n                var node = cascade[nodeTitle];\r\n                node.inWeight = this._getInWeightForNode(node.nodeTitle, links);\r\n                node.outWeight = this._getOutWeightForNode(node.nodeTitle, links);\r\n                node.maxWeight = Math.max(node.inWeight, node.outWeight)\r\n            })\r\n        });\r\n        return cascades\r\n    },\r\n    _getWeightForCascade: function(cascades, cascadeIdx) {\r\n        var wMax = 0;\r\n        var cascade = cascades[cascadeIdx];\r\n        Object.keys(cascade).forEach(nodeTitle => {\r\n            wMax += Math.max(cascade[nodeTitle].inWeight, cascade[nodeTitle].outWeight)\r\n        });\r\n        return wMax\r\n    },\r\n    _getMaxWeightThroughCascades: function(cascades) {\r\n        var max = [];\r\n        cascades.forEach(cascade => {\r\n            var mW = 0;\r\n            Object.keys(cascade).forEach(nodeTitle => {\r\n                var node = cascade[nodeTitle];\r\n                mW += Math.max(node.inWeight, node.outWeight)\r\n            });\r\n            max.push(mW)\r\n        });\r\n        return graphModule.routines.maxOfArray(max)\r\n    },\r\n    _computeNodes: function(cascades, options) {\r\n        var rects = [];\r\n        var maxWeight = this._getMaxWeightThroughCascades(cascades);\r\n        var maxNodeNum = graphModule.routines.maxOfArray(cascades.map(nodesInCascade => Object.keys(nodesInCascade).length));\r\n        var nodePadding = options.nodePadding;\r\n        var heightAvailable = options.height - nodePadding * (maxNodeNum - 1);\r\n        if (heightAvailable < 0) {\r\n            nodePadding = 0;\r\n            heightAvailable = options.height - nodePadding * (maxNodeNum - 1)\r\n        }\r\n        this._weightPerPixel = maxWeight / heightAvailable;\r\n        var cascadeIdx = 0;\r\n        cascades.forEach(cascade => {\r\n            var cascadeRects = [];\r\n            var y = 0;\r\n            var nodesInCascade = Object.keys(cascade).length;\r\n            var cascadeHeight = this._getWeightForCascade(cascades, cascadeIdx) / this._weightPerPixel + nodePadding * (nodesInCascade - 1);\r\n            var cascadeAlign;\r\n            if (Array.isArray(options.nodeAlign)) {\r\n                cascadeAlign = cascadeIdx < options.nodeAlign.length ? options.nodeAlign[cascadeIdx] : _ALIGNMENT_DEFAULT\r\n            } else {\r\n                cascadeAlign = options.nodeAlign\r\n            }\r\n            if (cascadeAlign === _ALIGNMENT_BOTTOM) {\r\n                y = options.height - cascadeHeight\r\n            } else if (cascadeAlign === _ALIGNMENT_CENTER) {\r\n                y = .5 * (options.height - cascadeHeight)\r\n            }\r\n            y = Math.round(y);\r\n            Object.keys(cascade).forEach(nodeTitle => {\r\n                cascade[nodeTitle].sort = this._sort && Object.prototype.hasOwnProperty.call(this._sort, nodeTitle) ? this._sort[nodeTitle] : 1\r\n            });\r\n            Object.keys(cascade).sort((a, b) => cascade[a].sort - cascade[b].sort).forEach(nodeTitle => {\r\n                var node = cascade[nodeTitle];\r\n                var height = Math.floor(heightAvailable * node.maxWeight / maxWeight);\r\n                var x = Math.round(cascadeIdx * options.width / (cascades.length - 1)) - (0 === cascadeIdx ? 0 : options.nodeWidth);\r\n                var rect = {};\r\n                rect._name = nodeTitle;\r\n                rect.width = options.nodeWidth;\r\n                rect.height = height;\r\n                rect.x = x + options.x;\r\n                rect.y = y + options.y;\r\n                y += height + nodePadding;\r\n                cascadeRects.push(rect)\r\n            });\r\n            cascadeIdx++;\r\n            rects.push(cascadeRects)\r\n        });\r\n        return rects\r\n    },\r\n    _findRectByName: function(rects, name) {\r\n        for (var c = 0; c < rects.length; c++) {\r\n            for (var r = 0; r < rects[c].length; r++) {\r\n                if (name === rects[c][r]._name) {\r\n                    return rects[c][r]\r\n                }\r\n            }\r\n        }\r\n        return null\r\n    },\r\n    _findIndexByName: function(rects, nodeTitle) {\r\n        var index = 0;\r\n        for (var c = 0; c < rects.length; c++) {\r\n            for (var r = 0; r < rects[c].length; r++) {\r\n                if (nodeTitle === rects[c][r]._name) {\r\n                    return index\r\n                }\r\n                index++\r\n            }\r\n        }\r\n        return null\r\n    },\r\n    _computeLinks: function(links, rects, cascades) {\r\n        var yOffsets = {};\r\n        var paths = [];\r\n        var result = [];\r\n        cascades.forEach(cascade => {\r\n            Object.keys(cascade).forEach(nodeTitle => {\r\n                yOffsets[nodeTitle] = {\r\n                    in: 0,\r\n                    out: 0\r\n                }\r\n            })\r\n        });\r\n        rects.forEach(rectsOfCascade => {\r\n            rectsOfCascade.forEach(nodeRect => {\r\n                var nodeTitle = nodeRect._name;\r\n                var rectFrom = this._findRectByName(rects, nodeTitle);\r\n                var linksFromNode = links.filter(link => link[0] === nodeTitle);\r\n                linksFromNode.forEach(link => {\r\n                    link.sort = this._findIndexByName(rects, link[1])\r\n                });\r\n                linksFromNode.sort((a, b) => a.sort - b.sort).forEach(link => {\r\n                    var rectTo = this._findRectByName(rects, link[1]);\r\n                    var height = Math.round(link[2] / this._weightPerPixel);\r\n                    var yOffsetFrom = yOffsets[link[0]].out;\r\n                    var yOffsetTo = yOffsets[link[1]].in;\r\n                    var heightFrom = yOffsets[link[0]].out + height > rectFrom.height ? rectFrom.height - yOffsets[link[0]].out : height;\r\n                    var heightTo = yOffsets[link[1]].in + height > rectTo.height ? rectTo.height - yOffsets[link[1]].in : height;\r\n                    paths.push({\r\n                        from: {\r\n                            x: rectFrom.x,\r\n                            y: rectFrom.y + yOffsetFrom,\r\n                            width: rectFrom.width,\r\n                            height: heightFrom,\r\n                            node: rectFrom,\r\n                            weight: link[2]\r\n                        },\r\n                        to: {\r\n                            x: rectTo.x,\r\n                            y: rectTo.y + yOffsetTo,\r\n                            width: rectTo.width,\r\n                            height: heightTo,\r\n                            node: rectTo\r\n                        }\r\n                    });\r\n                    yOffsets[link[0]].out += height;\r\n                    yOffsets[link[1]].in += height\r\n                })\r\n            })\r\n        });\r\n        paths.forEach(link => {\r\n            var path = {\r\n                d: this._spline(link.from, link.to),\r\n                _boundingRect: {\r\n                    x: link.from.x + link.from.width,\r\n                    y: Math.min(link.from.y, link.to.y),\r\n                    width: link.to.x - (link.from.x + link.from.width),\r\n                    height: Math.max(link.from.x + link.from.height, link.to.y + link.to.height) - Math.min(link.from.y, link.to.y)\r\n                },\r\n                _weight: link.from.weight,\r\n                _from: link.from.node,\r\n                _to: link.to.node\r\n            };\r\n            result.push(path)\r\n        });\r\n        this._fitAllNodesHeight(rects, paths);\r\n        return result\r\n    },\r\n    _fitNodeHeight: function(nodeName, nodeRects, paths) {\r\n        var targetRect = this._findRectByName(nodeRects, nodeName);\r\n        var heightOfLinksSummaryIn = 0;\r\n        var heightOfLinksSummaryOut = 0;\r\n        paths.forEach((function(path) {\r\n            if (path.from.node._name === nodeName) {\r\n                heightOfLinksSummaryOut += path.from.height\r\n            }\r\n            if (path.to.node._name === nodeName) {\r\n                heightOfLinksSummaryIn += path.to.height\r\n            }\r\n        }));\r\n        targetRect.height = Math.max(heightOfLinksSummaryIn, heightOfLinksSummaryOut)\r\n    },\r\n    _fitAllNodesHeight: function(nodeRects, paths) {\r\n        for (var c = 0; c < nodeRects.length; c++) {\r\n            for (var r = 0; r < nodeRects[c].length; r++) {\r\n                this._fitNodeHeight(nodeRects[c][r]._name, nodeRects, paths)\r\n            }\r\n        }\r\n    },\r\n    _spline: function(rectLeft, rectRight) {\r\n        var p_UpLeft = {\r\n            x: rectLeft.x + rectLeft.width,\r\n            y: rectLeft.y\r\n        };\r\n        var p_DownLeft = {\r\n            x: rectLeft.x + rectLeft.width,\r\n            y: rectLeft.y + rectLeft.height\r\n        };\r\n        var p_UpRight = {\r\n            x: rectRight.x,\r\n            y: rectRight.y\r\n        };\r\n        var p_DownRight = {\r\n            x: rectRight.x,\r\n            y: rectRight.y + rectRight.height\r\n        };\r\n        var curve_width = _SPLINE_TENSION * (p_UpRight.x - p_UpLeft.x);\r\n        var result = \"M \".concat(p_UpLeft.x, \" \").concat(p_UpLeft.y, \" C \").concat(p_UpLeft.x + curve_width, \" \").concat(p_UpLeft.y, \" \").concat(p_UpRight.x - curve_width, \" \").concat(p_UpRight.y, \" \").concat(p_UpRight.x, \" \").concat(p_UpRight.y, \" L \").concat(p_DownRight.x, \" \").concat(p_DownRight.y, \" C \").concat(p_DownRight.x - curve_width, \" \").concat(p_DownRight.y, \" \").concat(p_DownLeft.x + curve_width, \" \").concat(p_DownLeft.y, \" \").concat(p_DownLeft.x, \" \").concat(p_DownLeft.y, \" Z\");\r\n        return result\r\n    },\r\n    computeLayout: function(linksData, sortData, options, incidentOccurred) {\r\n        this._sort = sortData;\r\n        var result = {};\r\n        var validateResult = validatorModule.validate(linksData, incidentOccurred);\r\n        if (!validateResult) {\r\n            result.cascades = this._computeCascades(linksData);\r\n            result.nodes = this._computeNodes(result.cascades, {\r\n                width: options.availableRect.width,\r\n                height: options.availableRect.height,\r\n                x: options.availableRect.x,\r\n                y: options.availableRect.y,\r\n                nodePadding: options.nodePadding,\r\n                nodeWidth: options.nodeWidth,\r\n                nodeAlign: options.nodeAlign\r\n            });\r\n            result.links = this._computeLinks(linksData, result.nodes, result.cascades)\r\n        } else {\r\n            result.error = validateResult\r\n        }\r\n        return result\r\n    },\r\n    overlap: function(box1, box2) {\r\n        return !(box2.x > box1.x + box1.width || box2.x + box2.width < box1.x || box2.y >= box1.y + box1.height || box2.y + box2.height <= box1.y)\r\n    }\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}