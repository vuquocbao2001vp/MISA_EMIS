{"ast":null,"code":"import \"core-js/modules/es.regexp.flags.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/esnext.typed-array.find-last.js\";\nimport \"core-js/modules/esnext.typed-array.find-last-index.js\";\nvar isArray = Array.isArray;\n\nfunction isStringOrNumber(o) {\n  var type = typeof o;\n  return type === 'string' || type === 'number';\n}\n\nfunction isNullOrUndef(o) {\n  return o === void 0 || o === null;\n}\n\nfunction isInvalid(o) {\n  return o === null || o === false || o === true || o === void 0;\n}\n\nfunction isFunction(o) {\n  return typeof o === 'function';\n}\n\nfunction isString(o) {\n  return typeof o === 'string';\n}\n\nfunction isNumber(o) {\n  return typeof o === 'number';\n}\n\nfunction isNull(o) {\n  return o === null;\n}\n\nfunction isUndefined(o) {\n  return o === void 0;\n}\n\nfunction combineFrom(first, second) {\n  var out = {};\n\n  if (first) {\n    for (var key in first) {\n      out[key] = first[key];\n    }\n  }\n\n  if (second) {\n    for (var key$1 in second) {\n      out[key$1] = second[key$1];\n    }\n  }\n\n  return out;\n}\n/**\n * Links given data to event as first parameter\n * @param {*} data data to be linked, it will be available in function as first parameter\n * @param {Function} event Function to be called when event occurs\n * @returns {{data: *, event: Function}}\n */\n\n\nfunction linkEvent(data, event) {\n  if (isFunction(event)) {\n    return {\n      data: data,\n      event: event\n    };\n  }\n\n  return null; // Return null when event is invalid, to avoid creating unnecessary event handlers\n} // object.event should always be function, otherwise its badly created object.\n\n\nfunction isLinkEventObject(o) {\n  return !isNull(o) && typeof o === 'object';\n} // We need EMPTY_OBJ defined in one place.\n// Its used for comparison so we cant inline it into shared\n\n\nvar EMPTY_OBJ = {};\nvar Fragment = '$F';\n\nfunction normalizeEventName(name) {\n  return name.substr(2).toLowerCase();\n}\n\nfunction appendChild(parentDOM, dom) {\n  parentDOM.appendChild(dom);\n}\n\nfunction insertOrAppend(parentDOM, newNode, nextNode) {\n  if (isNull(nextNode)) {\n    appendChild(parentDOM, newNode);\n  } else {\n    parentDOM.insertBefore(newNode, nextNode);\n  }\n}\n\nfunction documentCreateElement(tag, isSVG) {\n  if (isSVG) {\n    return document.createElementNS('http://www.w3.org/2000/svg', tag);\n  }\n\n  return document.createElement(tag);\n}\n\nfunction replaceChild(parentDOM, newDom, lastDom) {\n  parentDOM.replaceChild(newDom, lastDom);\n}\n\nfunction removeChild(parentDOM, childNode) {\n  parentDOM.removeChild(childNode);\n}\n\nfunction callAll(arrayFn) {\n  for (var i = 0; i < arrayFn.length; i++) {\n    arrayFn[i]();\n  }\n}\n\nfunction findChildVNode(vNode, startEdge, flags) {\n  var children = vNode.children;\n\n  if (flags & 4\n  /* ComponentClass */\n  ) {\n    return children.$LI;\n  }\n\n  if (flags & 8192\n  /* Fragment */\n  ) {\n    return vNode.childFlags === 2\n    /* HasVNodeChildren */\n    ? children : children[startEdge ? 0 : children.length - 1];\n  }\n\n  return children;\n}\n\nfunction findDOMfromVNode(vNode, startEdge) {\n  var flags;\n\n  while (vNode) {\n    flags = vNode.flags;\n\n    if (flags & 2033\n    /* DOMRef */\n    ) {\n      return vNode.dom;\n    }\n\n    vNode = findChildVNode(vNode, startEdge, flags);\n  }\n\n  return null;\n}\n\nfunction removeVNodeDOM(vNode, parentDOM) {\n  do {\n    var flags = vNode.flags;\n\n    if (flags & 2033\n    /* DOMRef */\n    ) {\n      removeChild(parentDOM, vNode.dom);\n      return;\n    }\n\n    var children = vNode.children;\n\n    if (flags & 4\n    /* ComponentClass */\n    ) {\n      vNode = children.$LI;\n    }\n\n    if (flags & 8\n    /* ComponentFunction */\n    ) {\n      vNode = children;\n    }\n\n    if (flags & 8192\n    /* Fragment */\n    ) {\n      if (vNode.childFlags === 2\n      /* HasVNodeChildren */\n      ) {\n        vNode = children;\n      } else {\n        for (var i = 0, len = children.length; i < len; ++i) {\n          removeVNodeDOM(children[i], parentDOM);\n        }\n\n        return;\n      }\n    }\n  } while (vNode);\n}\n\nfunction moveVNodeDOM(vNode, parentDOM, nextNode) {\n  do {\n    var flags = vNode.flags;\n\n    if (flags & 2033\n    /* DOMRef */\n    ) {\n      insertOrAppend(parentDOM, vNode.dom, nextNode);\n      return;\n    }\n\n    var children = vNode.children;\n\n    if (flags & 4\n    /* ComponentClass */\n    ) {\n      vNode = children.$LI;\n    }\n\n    if (flags & 8\n    /* ComponentFunction */\n    ) {\n      vNode = children;\n    }\n\n    if (flags & 8192\n    /* Fragment */\n    ) {\n      if (vNode.childFlags === 2\n      /* HasVNodeChildren */\n      ) {\n        vNode = children;\n      } else {\n        for (var i = 0, len = children.length; i < len; ++i) {\n          moveVNodeDOM(children[i], parentDOM, nextNode);\n        }\n\n        return;\n      }\n    }\n  } while (vNode);\n}\n\nfunction createDerivedState(instance, nextProps, state) {\n  if (instance.constructor.getDerivedStateFromProps) {\n    return combineFrom(state, instance.constructor.getDerivedStateFromProps(nextProps, state));\n  }\n\n  return state;\n}\n\nvar renderCheck = {\n  v: false\n};\nvar options = {\n  componentComparator: null,\n  createVNode: null,\n  renderComplete: null\n};\n\nfunction setTextContent(dom, children) {\n  dom.textContent = children;\n} // Calling this function assumes, nextValue is linkEvent\n\n\nfunction isLastValueSameLinkEvent(lastValue, nextValue) {\n  return isLinkEventObject(lastValue) && lastValue.event === nextValue.event && lastValue.data === nextValue.data;\n}\n\nfunction mergeUnsetProperties(to, from) {\n  for (var propName in from) {\n    if (isUndefined(to[propName])) {\n      to[propName] = from[propName];\n    }\n  }\n\n  return to;\n}\n\nfunction safeCall1(method, arg1) {\n  return !!isFunction(method) && (method(arg1), true);\n}\n\nvar keyPrefix = '$';\n\nfunction V(childFlags, children, className, flags, key, props, ref, type) {\n  this.childFlags = childFlags;\n  this.children = children;\n  this.className = className;\n  this.dom = null;\n  this.flags = flags;\n  this.key = key === void 0 ? null : key;\n  this.props = props === void 0 ? null : props;\n  this.ref = ref === void 0 ? null : ref;\n  this.type = type;\n}\n\nfunction createVNode(flags, type, className, children, childFlags, props, key, ref) {\n  var childFlag = childFlags === void 0 ? 1\n  /* HasInvalidChildren */\n  : childFlags;\n  var vNode = new V(childFlag, children, className, flags, key, props, ref, type);\n\n  if (options.createVNode) {\n    options.createVNode(vNode);\n  }\n\n  if (childFlag === 0\n  /* UnknownChildren */\n  ) {\n    normalizeChildren(vNode, vNode.children);\n  }\n\n  return vNode;\n}\n\nfunction mergeDefaultHooks(flags, type, ref) {\n  if (flags & 4\n  /* ComponentClass */\n  ) {\n    return ref;\n  }\n\n  var defaultHooks = (flags & 32768\n  /* ForwardRef */\n  ? type.render : type).defaultHooks;\n\n  if (isNullOrUndef(defaultHooks)) {\n    return ref;\n  }\n\n  if (isNullOrUndef(ref)) {\n    return defaultHooks;\n  }\n\n  return mergeUnsetProperties(ref, defaultHooks);\n}\n\nfunction mergeDefaultProps(flags, type, props) {\n  // set default props\n  var defaultProps = (flags & 32768\n  /* ForwardRef */\n  ? type.render : type).defaultProps;\n\n  if (isNullOrUndef(defaultProps)) {\n    return props;\n  }\n\n  if (isNullOrUndef(props)) {\n    return combineFrom(defaultProps, null);\n  }\n\n  return mergeUnsetProperties(props, defaultProps);\n}\n\nfunction resolveComponentFlags(flags, type) {\n  if (flags & 12\n  /* ComponentKnown */\n  ) {\n    return flags;\n  }\n\n  if (type.prototype && type.prototype.render) {\n    return 4\n    /* ComponentClass */\n    ;\n  }\n\n  if (type.render) {\n    return 32776\n    /* ForwardRefComponent */\n    ;\n  }\n\n  return 8\n  /* ComponentFunction */\n  ;\n}\n\nfunction createComponentVNode(flags, type, props, key, ref) {\n  flags = resolveComponentFlags(flags, type);\n  var vNode = new V(1\n  /* HasInvalidChildren */\n  , null, null, flags, key, mergeDefaultProps(flags, type, props), mergeDefaultHooks(flags, type, ref), type);\n\n  if (options.createVNode) {\n    options.createVNode(vNode);\n  }\n\n  return vNode;\n}\n\nfunction createTextVNode(text, key) {\n  return new V(1\n  /* HasInvalidChildren */\n  , isNullOrUndef(text) || text === true || text === false ? '' : text, null, 16\n  /* Text */\n  , key, null, null, null);\n}\n\nfunction createFragment(children, childFlags, key) {\n  var fragment = createVNode(8192\n  /* Fragment */\n  , 8192\n  /* Fragment */\n  , null, children, childFlags, null, key, null);\n\n  switch (fragment.childFlags) {\n    case 1\n    /* HasInvalidChildren */\n    :\n      fragment.children = createVoidVNode();\n      fragment.childFlags = 2\n      /* HasVNodeChildren */\n      ;\n      break;\n\n    case 16\n    /* HasTextChildren */\n    :\n      fragment.children = [createTextVNode(children)];\n      fragment.childFlags = 4\n      /* HasNonKeyedChildren */\n      ;\n      break;\n  }\n\n  return fragment;\n}\n\nfunction normalizeProps(vNode) {\n  var props = vNode.props;\n\n  if (props) {\n    var flags = vNode.flags;\n\n    if (flags & 481\n    /* Element */\n    ) {\n      if (props.children !== void 0 && isNullOrUndef(vNode.children)) {\n        normalizeChildren(vNode, props.children);\n      }\n\n      if (props.className !== void 0) {\n        if (isNullOrUndef(vNode.className)) {\n          vNode.className = props.className || null;\n        }\n\n        props.className = undefined;\n      }\n    }\n\n    if (props.key !== void 0) {\n      vNode.key = props.key;\n      props.key = undefined;\n    }\n\n    if (props.ref !== void 0) {\n      if (flags & 8\n      /* ComponentFunction */\n      ) {\n        vNode.ref = combineFrom(vNode.ref, props.ref);\n      } else {\n        vNode.ref = props.ref;\n      }\n\n      props.ref = undefined;\n    }\n  }\n\n  return vNode;\n}\n/*\n * Fragment is different than normal vNode,\n * because when it needs to be cloned we need to clone its children too\n * But not normalize, because otherwise those possibly get KEY and re-mount\n */\n\n\nfunction cloneFragment(vNodeToClone) {\n  var oldChildren = vNodeToClone.children;\n  var childFlags = vNodeToClone.childFlags;\n  return createFragment(childFlags === 2\n  /* HasVNodeChildren */\n  ? directClone(oldChildren) : oldChildren.map(directClone), childFlags, vNodeToClone.key);\n}\n\nfunction directClone(vNodeToClone) {\n  var flags = vNodeToClone.flags & -16385\n  /* ClearInUse */\n  ;\n  var props = vNodeToClone.props;\n\n  if (flags & 14\n  /* Component */\n  ) {\n    if (!isNull(props)) {\n      var propsToClone = props;\n      props = {};\n\n      for (var key in propsToClone) {\n        props[key] = propsToClone[key];\n      }\n    }\n  }\n\n  if ((flags & 8192\n  /* Fragment */\n  ) === 0) {\n    return new V(vNodeToClone.childFlags, vNodeToClone.children, vNodeToClone.className, flags, vNodeToClone.key, props, vNodeToClone.ref, vNodeToClone.type);\n  }\n\n  return cloneFragment(vNodeToClone);\n}\n\nfunction createVoidVNode() {\n  return createTextVNode('', null);\n}\n\nfunction createPortal(children, container) {\n  var normalizedRoot = normalizeRoot(children);\n  return createVNode(1024\n  /* Portal */\n  , 1024\n  /* Portal */\n  , null, normalizedRoot, 0\n  /* UnknownChildren */\n  , null, normalizedRoot.key, container);\n}\n\nfunction _normalizeVNodes(nodes, result, index, currentKey) {\n  for (var len = nodes.length; index < len; index++) {\n    var n = nodes[index];\n\n    if (!isInvalid(n)) {\n      var newKey = currentKey + keyPrefix + index;\n\n      if (isArray(n)) {\n        _normalizeVNodes(n, result, 0, newKey);\n      } else {\n        if (isStringOrNumber(n)) {\n          n = createTextVNode(n, newKey);\n        } else {\n          var oldKey = n.key;\n          var isPrefixedKey = isString(oldKey) && oldKey[0] === keyPrefix;\n\n          if (n.flags & 81920\n          /* InUseOrNormalized */\n          || isPrefixedKey) {\n            n = directClone(n);\n          }\n\n          n.flags |= 65536\n          /* Normalized */\n          ;\n\n          if (!isPrefixedKey) {\n            if (isNull(oldKey)) {\n              n.key = newKey;\n            } else {\n              n.key = currentKey + oldKey;\n            }\n          } else if (oldKey.substring(0, currentKey.length) !== currentKey) {\n            n.key = currentKey + oldKey;\n          }\n        }\n\n        result.push(n);\n      }\n    }\n  }\n}\n\nfunction getFlagsForElementVnode(type) {\n  switch (type) {\n    case 'svg':\n      return 32\n      /* SvgElement */\n      ;\n\n    case 'input':\n      return 64\n      /* InputElement */\n      ;\n\n    case 'select':\n      return 256\n      /* SelectElement */\n      ;\n\n    case 'textarea':\n      return 128\n      /* TextareaElement */\n      ;\n\n    case Fragment:\n      return 8192\n      /* Fragment */\n      ;\n\n    default:\n      return 1\n      /* HtmlElement */\n      ;\n  }\n}\n\nfunction normalizeChildren(vNode, children) {\n  var newChildren;\n  var newChildFlags = 1\n  /* HasInvalidChildren */\n  ; // Don't change children to match strict equal (===) true in patching\n\n  if (isInvalid(children)) {\n    newChildren = children;\n  } else if (isStringOrNumber(children)) {\n    newChildFlags = 16\n    /* HasTextChildren */\n    ;\n    newChildren = children;\n  } else if (isArray(children)) {\n    var len = children.length;\n\n    for (var i = 0; i < len; ++i) {\n      var n = children[i];\n\n      if (isInvalid(n) || isArray(n)) {\n        newChildren = newChildren || children.slice(0, i);\n\n        _normalizeVNodes(children, newChildren, i, '');\n\n        break;\n      } else if (isStringOrNumber(n)) {\n        newChildren = newChildren || children.slice(0, i);\n        newChildren.push(createTextVNode(n, keyPrefix + i));\n      } else {\n        var key = n.key;\n        var needsCloning = (n.flags & 81920\n        /* InUseOrNormalized */\n        ) > 0;\n        var isNullKey = isNull(key);\n        var isPrefixed = isString(key) && key[0] === keyPrefix;\n\n        if (needsCloning || isNullKey || isPrefixed) {\n          newChildren = newChildren || children.slice(0, i);\n\n          if (needsCloning || isPrefixed) {\n            n = directClone(n);\n          }\n\n          if (isNullKey || isPrefixed) {\n            n.key = keyPrefix + i;\n          }\n\n          newChildren.push(n);\n        } else if (newChildren) {\n          newChildren.push(n);\n        }\n\n        n.flags |= 65536\n        /* Normalized */\n        ;\n      }\n    }\n\n    newChildren = newChildren || children;\n\n    if (newChildren.length === 0) {\n      newChildFlags = 1\n      /* HasInvalidChildren */\n      ;\n    } else {\n      newChildFlags = 8\n      /* HasKeyedChildren */\n      ;\n    }\n  } else {\n    newChildren = children;\n    newChildren.flags |= 65536\n    /* Normalized */\n    ;\n\n    if (children.flags & 81920\n    /* InUseOrNormalized */\n    ) {\n      newChildren = directClone(children);\n    }\n\n    newChildFlags = 2\n    /* HasVNodeChildren */\n    ;\n  }\n\n  vNode.children = newChildren;\n  vNode.childFlags = newChildFlags;\n  return vNode;\n}\n\nfunction normalizeRoot(input) {\n  if (isInvalid(input) || isStringOrNumber(input)) {\n    return createTextVNode(input, null);\n  }\n\n  if (isArray(input)) {\n    return createFragment(input, 0\n    /* UnknownChildren */\n    , null);\n  }\n\n  return input.flags & 16384\n  /* InUse */\n  ? directClone(input) : input;\n}\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\nvar xmlNS = 'http://www.w3.org/XML/1998/namespace';\nvar namespaces = {\n  'xlink:actuate': xlinkNS,\n  'xlink:arcrole': xlinkNS,\n  'xlink:href': xlinkNS,\n  'xlink:role': xlinkNS,\n  'xlink:show': xlinkNS,\n  'xlink:title': xlinkNS,\n  'xlink:type': xlinkNS,\n  'xml:base': xmlNS,\n  'xml:lang': xmlNS,\n  'xml:space': xmlNS\n};\n\nfunction getDelegatedEventObject(v) {\n  return {\n    onClick: v,\n    onDblClick: v,\n    onFocusIn: v,\n    onFocusOut: v,\n    onKeyDown: v,\n    onKeyPress: v,\n    onKeyUp: v,\n    onMouseDown: v,\n    onMouseMove: v,\n    onMouseUp: v,\n    onTouchEnd: v,\n    onTouchMove: v,\n    onTouchStart: v\n  };\n}\n\nvar attachedEventCounts = getDelegatedEventObject(0);\nvar attachedEvents = getDelegatedEventObject(null);\nvar syntheticEvents = getDelegatedEventObject(true);\n\nfunction updateOrAddSyntheticEvent(name, dom) {\n  var eventsObject = dom.$EV;\n\n  if (!eventsObject) {\n    eventsObject = dom.$EV = getDelegatedEventObject(null);\n  }\n\n  if (!eventsObject[name]) {\n    if (++attachedEventCounts[name] === 1) {\n      attachedEvents[name] = attachEventToDocument(name);\n    }\n  }\n\n  return eventsObject;\n}\n\nfunction unmountSyntheticEvent(name, dom) {\n  var eventsObject = dom.$EV;\n\n  if (eventsObject && eventsObject[name]) {\n    if (--attachedEventCounts[name] === 0) {\n      document.removeEventListener(normalizeEventName(name), attachedEvents[name]);\n      attachedEvents[name] = null;\n    }\n\n    eventsObject[name] = null;\n  }\n}\n\nfunction handleSyntheticEvent(name, lastEvent, nextEvent, dom) {\n  if (isFunction(nextEvent)) {\n    updateOrAddSyntheticEvent(name, dom)[name] = nextEvent;\n  } else if (isLinkEventObject(nextEvent)) {\n    if (isLastValueSameLinkEvent(lastEvent, nextEvent)) {\n      return;\n    }\n\n    updateOrAddSyntheticEvent(name, dom)[name] = nextEvent;\n  } else {\n    unmountSyntheticEvent(name, dom);\n  }\n} // When browsers fully support event.composedPath we could loop it through instead of using parentNode property\n\n\nfunction getTargetNode(event) {\n  return isFunction(event.composedPath) ? event.composedPath()[0] : event.target;\n}\n\nfunction dispatchEvents(event, isClick, name, eventData) {\n  var dom = getTargetNode(event);\n\n  do {\n    // Html Nodes can be nested fe: span inside button in that scenario browser does not handle disabled attribute on parent,\n    // because the event listener is on document.body\n    // Don't process clicks on disabled elements\n    if (isClick && dom.disabled) {\n      return;\n    }\n\n    var eventsObject = dom.$EV;\n\n    if (eventsObject) {\n      var currentEvent = eventsObject[name];\n\n      if (currentEvent) {\n        // linkEvent object\n        eventData.dom = dom;\n        currentEvent.event ? currentEvent.event(currentEvent.data, event) : currentEvent(event);\n\n        if (event.cancelBubble) {\n          return;\n        }\n      }\n    }\n\n    dom = dom.parentNode;\n  } while (!isNull(dom));\n}\n\nfunction stopPropagation() {\n  this.cancelBubble = true;\n\n  if (!this.immediatePropagationStopped) {\n    this.stopImmediatePropagation();\n  }\n}\n\nfunction isDefaultPrevented() {\n  return this.defaultPrevented;\n}\n\nfunction isPropagationStopped() {\n  return this.cancelBubble;\n}\n\nfunction extendEventProperties(event) {\n  // Event data needs to be object to save reference to currentTarget getter\n  var eventData = {\n    dom: document\n  };\n  event.isDefaultPrevented = isDefaultPrevented;\n  event.isPropagationStopped = isPropagationStopped;\n  event.stopPropagation = stopPropagation;\n  Object.defineProperty(event, 'currentTarget', {\n    configurable: true,\n    get: function get() {\n      return eventData.dom;\n    }\n  });\n  return eventData;\n}\n\nfunction rootClickEvent(name) {\n  return function (event) {\n    if (event.button !== 0) {\n      // Firefox incorrectly triggers click event for mid/right mouse buttons.\n      // This bug has been active for 17 years.\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=184051\n      event.stopPropagation();\n      return;\n    }\n\n    dispatchEvents(event, true, name, extendEventProperties(event));\n  };\n}\n\nfunction rootEvent(name) {\n  return function (event) {\n    dispatchEvents(event, false, name, extendEventProperties(event));\n  };\n}\n\nfunction attachEventToDocument(name) {\n  var attachedEvent = name === 'onClick' || name === 'onDblClick' ? rootClickEvent(name) : rootEvent(name);\n  document.addEventListener(normalizeEventName(name), attachedEvent);\n  return attachedEvent;\n}\n\nfunction isSameInnerHTML(dom, innerHTML) {\n  var tempdom = document.createElement('i');\n  tempdom.innerHTML = innerHTML;\n  return tempdom.innerHTML === dom.innerHTML;\n}\n\nfunction triggerEventListener(props, methodName, e) {\n  if (props[methodName]) {\n    var listener = props[methodName];\n\n    if (listener.event) {\n      listener.event(listener.data, e);\n    } else {\n      listener(e);\n    }\n  } else {\n    var nativeListenerName = methodName.toLowerCase();\n\n    if (props[nativeListenerName]) {\n      props[nativeListenerName](e);\n    }\n  }\n}\n\nfunction createWrappedFunction(methodName, applyValue) {\n  var fnMethod = function (e) {\n    var vNode = this.$V; // If vNode is gone by the time event fires, no-op\n\n    if (!vNode) {\n      return;\n    }\n\n    var props = vNode.props || EMPTY_OBJ;\n    var dom = vNode.dom;\n\n    if (isString(methodName)) {\n      triggerEventListener(props, methodName, e);\n    } else {\n      for (var i = 0; i < methodName.length; ++i) {\n        triggerEventListener(props, methodName[i], e);\n      }\n    }\n\n    if (isFunction(applyValue)) {\n      var newVNode = this.$V;\n      var newProps = newVNode.props || EMPTY_OBJ;\n      applyValue(newProps, dom, false, newVNode);\n    }\n  };\n\n  Object.defineProperty(fnMethod, 'wrapped', {\n    configurable: false,\n    enumerable: false,\n    value: true,\n    writable: false\n  });\n  return fnMethod;\n}\n\nfunction attachEvent(dom, eventName, handler) {\n  var previousKey = \"$\" + eventName;\n  var previousArgs = dom[previousKey];\n\n  if (previousArgs) {\n    if (previousArgs[1].wrapped) {\n      return;\n    }\n\n    dom.removeEventListener(previousArgs[0], previousArgs[1]);\n    dom[previousKey] = null;\n  }\n\n  if (isFunction(handler)) {\n    dom.addEventListener(eventName, handler);\n    dom[previousKey] = [eventName, handler];\n  }\n}\n\nfunction isCheckedType(type) {\n  return type === 'checkbox' || type === 'radio';\n}\n\nvar onTextInputChange = createWrappedFunction('onInput', applyValueInput);\nvar wrappedOnChange = createWrappedFunction(['onClick', 'onChange'], applyValueInput);\n/* tslint:disable-next-line:no-empty */\n\nfunction emptywrapper(event) {\n  event.stopPropagation();\n}\n\nemptywrapper.wrapped = true;\n\nfunction inputEvents(dom, nextPropsOrEmpty) {\n  if (isCheckedType(nextPropsOrEmpty.type)) {\n    attachEvent(dom, 'change', wrappedOnChange);\n    attachEvent(dom, 'click', emptywrapper);\n  } else {\n    attachEvent(dom, 'input', onTextInputChange);\n  }\n}\n\nfunction applyValueInput(nextPropsOrEmpty, dom) {\n  var type = nextPropsOrEmpty.type;\n  var value = nextPropsOrEmpty.value;\n  var checked = nextPropsOrEmpty.checked;\n  var multiple = nextPropsOrEmpty.multiple;\n  var defaultValue = nextPropsOrEmpty.defaultValue;\n  var hasValue = !isNullOrUndef(value);\n\n  if (type && type !== dom.type) {\n    dom.setAttribute('type', type);\n  }\n\n  if (!isNullOrUndef(multiple) && multiple !== dom.multiple) {\n    dom.multiple = multiple;\n  }\n\n  if (!isNullOrUndef(defaultValue) && !hasValue) {\n    dom.defaultValue = defaultValue + '';\n  }\n\n  if (isCheckedType(type)) {\n    if (hasValue) {\n      dom.value = value;\n    }\n\n    if (!isNullOrUndef(checked)) {\n      dom.checked = checked;\n    }\n  } else {\n    if (hasValue && dom.value !== value) {\n      dom.defaultValue = value;\n      dom.value = value;\n    } else if (!isNullOrUndef(checked)) {\n      dom.checked = checked;\n    }\n  }\n}\n\nfunction updateChildOptions(vNode, value) {\n  if (vNode.type === 'option') {\n    updateChildOption(vNode, value);\n  } else {\n    var children = vNode.children;\n    var flags = vNode.flags;\n\n    if (flags & 4\n    /* ComponentClass */\n    ) {\n      updateChildOptions(children.$LI, value);\n    } else if (flags & 8\n    /* ComponentFunction */\n    ) {\n      updateChildOptions(children, value);\n    } else if (vNode.childFlags === 2\n    /* HasVNodeChildren */\n    ) {\n      updateChildOptions(children, value);\n    } else if (vNode.childFlags & 12\n    /* MultipleChildren */\n    ) {\n      for (var i = 0, len = children.length; i < len; ++i) {\n        updateChildOptions(children[i], value);\n      }\n    }\n  }\n}\n\nfunction updateChildOption(vNode, value) {\n  var props = vNode.props || EMPTY_OBJ;\n  var dom = vNode.dom; // we do this as multiple may have changed\n\n  dom.value = props.value;\n\n  if (props.value === value || isArray(value) && value.indexOf(props.value) !== -1) {\n    dom.selected = true;\n  } else if (!isNullOrUndef(value) || !isNullOrUndef(props.selected)) {\n    dom.selected = props.selected || false;\n  }\n}\n\nvar onSelectChange = createWrappedFunction('onChange', applyValueSelect);\n\nfunction selectEvents(dom) {\n  attachEvent(dom, 'change', onSelectChange);\n}\n\nfunction applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode) {\n  var multiplePropInBoolean = Boolean(nextPropsOrEmpty.multiple);\n\n  if (!isNullOrUndef(nextPropsOrEmpty.multiple) && multiplePropInBoolean !== dom.multiple) {\n    dom.multiple = multiplePropInBoolean;\n  }\n\n  var index = nextPropsOrEmpty.selectedIndex;\n\n  if (index === -1) {\n    dom.selectedIndex = -1;\n  }\n\n  var childFlags = vNode.childFlags;\n\n  if (childFlags !== 1\n  /* HasInvalidChildren */\n  ) {\n    var value = nextPropsOrEmpty.value;\n\n    if (isNumber(index) && index > -1 && dom.options[index]) {\n      value = dom.options[index].value;\n    }\n\n    if (mounting && isNullOrUndef(value)) {\n      value = nextPropsOrEmpty.defaultValue;\n    }\n\n    updateChildOptions(vNode, value);\n  }\n}\n\nvar onTextareaInputChange = createWrappedFunction('onInput', applyValueTextArea);\nvar wrappedOnChange$1 = createWrappedFunction('onChange');\n\nfunction textAreaEvents(dom, nextPropsOrEmpty) {\n  attachEvent(dom, 'input', onTextareaInputChange);\n\n  if (nextPropsOrEmpty.onChange) {\n    attachEvent(dom, 'change', wrappedOnChange$1);\n  }\n}\n\nfunction applyValueTextArea(nextPropsOrEmpty, dom, mounting) {\n  var value = nextPropsOrEmpty.value;\n  var domValue = dom.value;\n\n  if (isNullOrUndef(value)) {\n    if (mounting) {\n      var defaultValue = nextPropsOrEmpty.defaultValue;\n\n      if (!isNullOrUndef(defaultValue) && defaultValue !== domValue) {\n        dom.defaultValue = defaultValue;\n        dom.value = defaultValue;\n      }\n    }\n  } else if (domValue !== value) {\n    /* There is value so keep it controlled */\n    dom.defaultValue = value;\n    dom.value = value;\n  }\n}\n\nfunction processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\n  if (flags & 64\n  /* InputElement */\n  ) {\n    applyValueInput(nextPropsOrEmpty, dom);\n  } else if (flags & 256\n  /* SelectElement */\n  ) {\n    applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode);\n  } else if (flags & 128\n  /* TextareaElement */\n  ) {\n    applyValueTextArea(nextPropsOrEmpty, dom, mounting);\n  }\n\n  if (isControlled) {\n    dom.$V = vNode;\n  }\n}\n\nfunction addFormElementEventHandlers(flags, dom, nextPropsOrEmpty) {\n  if (flags & 64\n  /* InputElement */\n  ) {\n    inputEvents(dom, nextPropsOrEmpty);\n  } else if (flags & 256\n  /* SelectElement */\n  ) {\n    selectEvents(dom);\n  } else if (flags & 128\n  /* TextareaElement */\n  ) {\n    textAreaEvents(dom, nextPropsOrEmpty);\n  }\n}\n\nfunction isControlledFormElement(nextPropsOrEmpty) {\n  return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type) ? !isNullOrUndef(nextPropsOrEmpty.checked) : !isNullOrUndef(nextPropsOrEmpty.value);\n}\n\nfunction createRef() {\n  return {\n    current: null\n  };\n}\n\nfunction forwardRef(render) {\n  // @ts-ignore\n  return {\n    render: render\n  };\n}\n\nfunction unmountRef(ref) {\n  if (ref) {\n    if (!safeCall1(ref, null) && ref.current) {\n      ref.current = null;\n    }\n  }\n}\n\nfunction mountRef(ref, value, lifecycle) {\n  if (ref && (isFunction(ref) || ref.current !== void 0)) {\n    lifecycle.push(function () {\n      if (!safeCall1(ref, value) && ref.current !== void 0) {\n        ref.current = value;\n      }\n    });\n  }\n}\n\nfunction remove(vNode, parentDOM) {\n  unmount(vNode);\n  removeVNodeDOM(vNode, parentDOM);\n}\n\nfunction unmount(vNode) {\n  var flags = vNode.flags;\n  var children = vNode.children;\n  var ref;\n\n  if (flags & 481\n  /* Element */\n  ) {\n    ref = vNode.ref;\n    var props = vNode.props;\n    unmountRef(ref);\n    var childFlags = vNode.childFlags;\n\n    if (!isNull(props)) {\n      var keys = Object.keys(props);\n\n      for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i];\n\n        if (syntheticEvents[key]) {\n          unmountSyntheticEvent(key, vNode.dom);\n        }\n      }\n    }\n\n    if (childFlags & 12\n    /* MultipleChildren */\n    ) {\n      unmountAllChildren(children);\n    } else if (childFlags === 2\n    /* HasVNodeChildren */\n    ) {\n      unmount(children);\n    }\n  } else if (children) {\n    if (flags & 4\n    /* ComponentClass */\n    ) {\n      if (isFunction(children.componentWillUnmount)) {\n        children.componentWillUnmount();\n      }\n\n      unmountRef(vNode.ref);\n      children.$UN = true;\n      unmount(children.$LI);\n    } else if (flags & 8\n    /* ComponentFunction */\n    ) {\n      ref = vNode.ref;\n\n      if (!isNullOrUndef(ref) && isFunction(ref.onComponentWillUnmount)) {\n        ref.onComponentWillUnmount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);\n      }\n\n      unmount(children);\n    } else if (flags & 1024\n    /* Portal */\n    ) {\n      remove(children, vNode.ref);\n    } else if (flags & 8192\n    /* Fragment */\n    ) {\n      if (vNode.childFlags & 12\n      /* MultipleChildren */\n      ) {\n        unmountAllChildren(children);\n      }\n    }\n  }\n}\n\nfunction unmountAllChildren(children) {\n  for (var i = 0, len = children.length; i < len; ++i) {\n    unmount(children[i]);\n  }\n}\n\nfunction clearDOM(dom) {\n  // Optimization for clearing dom\n  dom.textContent = '';\n}\n\nfunction removeAllChildren(dom, vNode, children) {\n  unmountAllChildren(children);\n\n  if (vNode.flags & 8192\n  /* Fragment */\n  ) {\n    removeVNodeDOM(vNode, dom);\n  } else {\n    clearDOM(dom);\n  }\n}\n\nfunction wrapLinkEvent(nextValue) {\n  // This variable makes sure there is no \"this\" context in callback\n  var ev = nextValue.event;\n  return function (e) {\n    ev(nextValue.data, e);\n  };\n}\n\nfunction patchEvent(name, lastValue, nextValue, dom) {\n  if (isLinkEventObject(nextValue)) {\n    if (isLastValueSameLinkEvent(lastValue, nextValue)) {\n      return;\n    }\n\n    nextValue = wrapLinkEvent(nextValue);\n  }\n\n  attachEvent(dom, normalizeEventName(name), nextValue);\n} // We are assuming here that we come from patchProp routine\n// -nextAttrValue cannot be null or undefined\n\n\nfunction patchStyle(lastAttrValue, nextAttrValue, dom) {\n  if (isNullOrUndef(nextAttrValue)) {\n    dom.removeAttribute('style');\n    return;\n  }\n\n  var domStyle = dom.style;\n  var style;\n  var value;\n\n  if (isString(nextAttrValue)) {\n    domStyle.cssText = nextAttrValue;\n    return;\n  }\n\n  if (!isNullOrUndef(lastAttrValue) && !isString(lastAttrValue)) {\n    for (style in nextAttrValue) {\n      // do not add a hasOwnProperty check here, it affects performance\n      value = nextAttrValue[style];\n\n      if (value !== lastAttrValue[style]) {\n        domStyle.setProperty(style, value);\n      }\n    }\n\n    for (style in lastAttrValue) {\n      if (isNullOrUndef(nextAttrValue[style])) {\n        domStyle.removeProperty(style);\n      }\n    }\n  } else {\n    for (style in nextAttrValue) {\n      value = nextAttrValue[style];\n      domStyle.setProperty(style, value);\n    }\n  }\n}\n\nfunction patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom) {\n  var lastHtml = lastValue && lastValue.__html || '';\n  var nextHtml = nextValue && nextValue.__html || '';\n\n  if (lastHtml !== nextHtml) {\n    if (!isNullOrUndef(nextHtml) && !isSameInnerHTML(dom, nextHtml)) {\n      if (!isNull(lastVNode)) {\n        if (lastVNode.childFlags & 12\n        /* MultipleChildren */\n        ) {\n          unmountAllChildren(lastVNode.children);\n        } else if (lastVNode.childFlags === 2\n        /* HasVNodeChildren */\n        ) {\n          unmount(lastVNode.children);\n        }\n\n        lastVNode.children = null;\n        lastVNode.childFlags = 1\n        /* HasInvalidChildren */\n        ;\n      }\n\n      dom.innerHTML = nextHtml;\n    }\n  }\n}\n\nfunction patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode) {\n  switch (prop) {\n    case 'children':\n    case 'childrenType':\n    case 'className':\n    case 'defaultValue':\n    case 'key':\n    case 'multiple':\n    case 'ref':\n    case 'selectedIndex':\n      break;\n\n    case 'autoFocus':\n      dom.autofocus = !!nextValue;\n      break;\n\n    case 'allowfullscreen':\n    case 'autoplay':\n    case 'capture':\n    case 'checked':\n    case 'controls':\n    case 'default':\n    case 'disabled':\n    case 'hidden':\n    case 'indeterminate':\n    case 'loop':\n    case 'muted':\n    case 'novalidate':\n    case 'open':\n    case 'readOnly':\n    case 'required':\n    case 'reversed':\n    case 'scoped':\n    case 'seamless':\n    case 'selected':\n      dom[prop] = !!nextValue;\n      break;\n\n    case 'defaultChecked':\n    case 'value':\n    case 'volume':\n      if (hasControlledValue && prop === 'value') {\n        break;\n      }\n\n      var value = isNullOrUndef(nextValue) ? '' : nextValue;\n\n      if (dom[prop] !== value) {\n        dom[prop] = value;\n      }\n\n      break;\n\n    case 'style':\n      patchStyle(lastValue, nextValue, dom);\n      break;\n\n    case 'dangerouslySetInnerHTML':\n      patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom);\n      break;\n\n    default:\n      if (syntheticEvents[prop]) {\n        handleSyntheticEvent(prop, lastValue, nextValue, dom);\n      } else if (prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110) {\n        patchEvent(prop, lastValue, nextValue, dom);\n      } else if (isNullOrUndef(nextValue)) {\n        dom.removeAttribute(prop);\n      } else if (isSVG && namespaces[prop]) {\n        // We optimize for isSVG being false\n        // If we end up in this path we can read property again\n        dom.setAttributeNS(namespaces[prop], prop, nextValue);\n      } else {\n        dom.setAttribute(prop, nextValue);\n      }\n\n      break;\n  }\n}\n\nfunction mountProps(vNode, flags, props, dom, isSVG) {\n  var hasControlledValue = false;\n  var isFormElement = (flags & 448\n  /* FormElement */\n  ) > 0;\n\n  if (isFormElement) {\n    hasControlledValue = isControlledFormElement(props);\n\n    if (hasControlledValue) {\n      addFormElementEventHandlers(flags, dom, props);\n    }\n  }\n\n  for (var prop in props) {\n    // do not add a hasOwnProperty check here, it affects performance\n    patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue, null);\n  }\n\n  if (isFormElement) {\n    processElement(flags, vNode, dom, props, true, hasControlledValue);\n  }\n}\n\nfunction renderNewInput(instance, props, context) {\n  var nextInput = normalizeRoot(instance.render(props, instance.state, context));\n  var childContext = context;\n\n  if (isFunction(instance.getChildContext)) {\n    childContext = combineFrom(context, instance.getChildContext());\n  }\n\n  instance.$CX = childContext;\n  return nextInput;\n}\n\nfunction createClassComponentInstance(vNode, Component, props, context, isSVG, lifecycle) {\n  var instance = new Component(props, context);\n  var usesNewAPI = instance.$N = Boolean(Component.getDerivedStateFromProps || instance.getSnapshotBeforeUpdate);\n  instance.$SVG = isSVG;\n  instance.$L = lifecycle;\n  vNode.children = instance;\n  instance.$BS = false;\n  instance.context = context;\n\n  if (instance.props === EMPTY_OBJ) {\n    instance.props = props;\n  }\n\n  if (!usesNewAPI) {\n    if (isFunction(instance.componentWillMount)) {\n      instance.$BR = true;\n      instance.componentWillMount();\n      var pending = instance.$PS;\n\n      if (!isNull(pending)) {\n        var state = instance.state;\n\n        if (isNull(state)) {\n          instance.state = pending;\n        } else {\n          for (var key in pending) {\n            state[key] = pending[key];\n          }\n        }\n\n        instance.$PS = null;\n      }\n\n      instance.$BR = false;\n    }\n  } else {\n    instance.state = createDerivedState(instance, props, instance.state);\n  }\n\n  instance.$LI = renderNewInput(instance, props, context);\n  return instance;\n}\n\nfunction renderFunctionalComponent(vNode, context) {\n  var props = vNode.props || EMPTY_OBJ;\n  return vNode.flags & 32768\n  /* ForwardRef */\n  ? vNode.type.render(props, vNode.ref, context) : vNode.type(props, context);\n}\n\nfunction mount(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n  var flags = vNode.flags |= 16384\n  /* InUse */\n  ;\n\n  if (flags & 481\n  /* Element */\n  ) {\n    mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n  } else if (flags & 4\n  /* ComponentClass */\n  ) {\n    mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n  } else if (flags & 8\n  /* ComponentFunction */\n  ) {\n    mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    mountFunctionalComponentCallbacks(vNode, lifecycle);\n  } else if (flags & 512\n  /* Void */\n  || flags & 16\n  /* Text */\n  ) {\n    mountText(vNode, parentDOM, nextNode);\n  } else if (flags & 8192\n  /* Fragment */\n  ) {\n    mountFragment(vNode, context, parentDOM, isSVG, nextNode, lifecycle);\n  } else if (flags & 1024\n  /* Portal */\n  ) {\n    mountPortal(vNode, context, parentDOM, nextNode, lifecycle);\n  } else ;\n}\n\nfunction mountPortal(vNode, context, parentDOM, nextNode, lifecycle) {\n  mount(vNode.children, vNode.ref, context, false, null, lifecycle);\n  var placeHolderVNode = createVoidVNode();\n  mountText(placeHolderVNode, parentDOM, nextNode);\n  vNode.dom = placeHolderVNode.dom;\n}\n\nfunction mountFragment(vNode, context, parentDOM, isSVG, nextNode, lifecycle) {\n  var children = vNode.children;\n  var childFlags = vNode.childFlags; // When fragment is optimized for multiple children, check if there is no children and change flag to invalid\n  // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements\n\n  if (childFlags & 12\n  /* MultipleChildren */\n  && children.length === 0) {\n    childFlags = vNode.childFlags = 2\n    /* HasVNodeChildren */\n    ;\n    children = vNode.children = createVoidVNode();\n  }\n\n  if (childFlags === 2\n  /* HasVNodeChildren */\n  ) {\n    mount(children, parentDOM, context, isSVG, nextNode, lifecycle);\n  } else {\n    mountArrayChildren(children, parentDOM, context, isSVG, nextNode, lifecycle);\n  }\n}\n\nfunction mountText(vNode, parentDOM, nextNode) {\n  var dom = vNode.dom = document.createTextNode(vNode.children);\n\n  if (!isNull(parentDOM)) {\n    insertOrAppend(parentDOM, dom, nextNode);\n  }\n}\n\nfunction mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n  var flags = vNode.flags;\n  var props = vNode.props;\n  var className = vNode.className;\n  var childFlags = vNode.childFlags;\n  var dom = vNode.dom = documentCreateElement(vNode.type, isSVG = isSVG || (flags & 32\n  /* SvgElement */\n  ) > 0);\n  var children = vNode.children;\n\n  if (!isNullOrUndef(className) && className !== '') {\n    if (isSVG) {\n      dom.setAttribute('class', className);\n    } else {\n      dom.className = className;\n    }\n  }\n\n  if (childFlags === 16\n  /* HasTextChildren */\n  ) {\n    setTextContent(dom, children);\n  } else if (childFlags !== 1\n  /* HasInvalidChildren */\n  ) {\n    var childrenIsSVG = isSVG && vNode.type !== 'foreignObject';\n\n    if (childFlags === 2\n    /* HasVNodeChildren */\n    ) {\n      if (children.flags & 16384\n      /* InUse */\n      ) {\n        vNode.children = children = directClone(children);\n      }\n\n      mount(children, dom, context, childrenIsSVG, null, lifecycle);\n    } else if (childFlags === 8\n    /* HasKeyedChildren */\n    || childFlags === 4\n    /* HasNonKeyedChildren */\n    ) {\n      mountArrayChildren(children, dom, context, childrenIsSVG, null, lifecycle);\n    }\n  }\n\n  if (!isNull(parentDOM)) {\n    insertOrAppend(parentDOM, dom, nextNode);\n  }\n\n  if (!isNull(props)) {\n    mountProps(vNode, flags, props, dom, isSVG);\n  }\n\n  mountRef(vNode.ref, dom, lifecycle);\n}\n\nfunction mountArrayChildren(children, dom, context, isSVG, nextNode, lifecycle) {\n  for (var i = 0; i < children.length; ++i) {\n    var child = children[i];\n\n    if (child.flags & 16384\n    /* InUse */\n    ) {\n      children[i] = child = directClone(child);\n    }\n\n    mount(child, dom, context, isSVG, nextNode, lifecycle);\n  }\n}\n\nfunction mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n  var instance = createClassComponentInstance(vNode, vNode.type, vNode.props || EMPTY_OBJ, context, isSVG, lifecycle);\n  mount(instance.$LI, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);\n  mountClassComponentCallbacks(vNode.ref, instance, lifecycle);\n}\n\nfunction mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n  mount(vNode.children = normalizeRoot(renderFunctionalComponent(vNode, context)), parentDOM, context, isSVG, nextNode, lifecycle);\n}\n\nfunction createClassMountCallback(instance) {\n  return function () {\n    instance.componentDidMount();\n  };\n}\n\nfunction mountClassComponentCallbacks(ref, instance, lifecycle) {\n  mountRef(ref, instance, lifecycle);\n\n  if (isFunction(instance.componentDidMount)) {\n    lifecycle.push(createClassMountCallback(instance));\n  }\n}\n\nfunction createOnMountCallback(ref, vNode) {\n  return function () {\n    ref.onComponentDidMount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);\n  };\n}\n\nfunction mountFunctionalComponentCallbacks(vNode, lifecycle) {\n  var ref = vNode.ref;\n\n  if (!isNullOrUndef(ref)) {\n    safeCall1(ref.onComponentWillMount, vNode.props || EMPTY_OBJ);\n\n    if (isFunction(ref.onComponentDidMount)) {\n      lifecycle.push(createOnMountCallback(ref, vNode));\n    }\n  }\n}\n\nfunction replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {\n  unmount(lastVNode);\n\n  if ((nextVNode.flags & lastVNode.flags & 2033\n  /* DOMRef */\n  ) !== 0) {\n    mount(nextVNode, null, context, isSVG, null, lifecycle); // Single DOM operation, when we have dom references available\n\n    replaceChild(parentDOM, nextVNode.dom, lastVNode.dom);\n  } else {\n    mount(nextVNode, parentDOM, context, isSVG, findDOMfromVNode(lastVNode, true), lifecycle);\n    removeVNodeDOM(lastVNode, parentDOM);\n  }\n}\n\nfunction patch(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n  var nextFlags = nextVNode.flags |= 16384\n  /* InUse */\n  ;\n\n  if (lastVNode.flags !== nextFlags || lastVNode.type !== nextVNode.type || lastVNode.key !== nextVNode.key || nextFlags & 2048\n  /* ReCreate */\n  ) {\n    if (lastVNode.flags & 16384\n    /* InUse */\n    ) {\n      replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);\n    } else {\n      // Last vNode is not in use, it has crashed at application level. Just mount nextVNode and ignore last one\n      mount(nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n  } else if (nextFlags & 481\n  /* Element */\n  ) {\n    patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle);\n  } else if (nextFlags & 4\n  /* ComponentClass */\n  ) {\n    patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n  } else if (nextFlags & 8\n  /* ComponentFunction */\n  ) {\n    patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n  } else if (nextFlags & 16\n  /* Text */\n  ) {\n    patchText(lastVNode, nextVNode);\n  } else if (nextFlags & 512\n  /* Void */\n  ) {\n    nextVNode.dom = lastVNode.dom;\n  } else if (nextFlags & 8192\n  /* Fragment */\n  ) {\n    patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);\n  } else {\n    patchPortal(lastVNode, nextVNode, context, lifecycle);\n  }\n}\n\nfunction patchSingleTextChild(lastChildren, nextChildren, parentDOM) {\n  if (lastChildren !== nextChildren) {\n    if (lastChildren !== '') {\n      parentDOM.firstChild.nodeValue = nextChildren;\n    } else {\n      setTextContent(parentDOM, nextChildren);\n    }\n  }\n}\n\nfunction patchContentEditableChildren(dom, nextChildren) {\n  if (dom.textContent !== nextChildren) {\n    dom.textContent = nextChildren;\n  }\n}\n\nfunction patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {\n  var lastChildren = lastVNode.children;\n  var nextChildren = nextVNode.children;\n  var lastChildFlags = lastVNode.childFlags;\n  var nextChildFlags = nextVNode.childFlags;\n  var nextNode = null; // When fragment is optimized for multiple children, check if there is no children and change flag to invalid\n  // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements\n\n  if (nextChildFlags & 12\n  /* MultipleChildren */\n  && nextChildren.length === 0) {\n    nextChildFlags = nextVNode.childFlags = 2\n    /* HasVNodeChildren */\n    ;\n    nextChildren = nextVNode.children = createVoidVNode();\n  }\n\n  var nextIsSingle = (nextChildFlags & 2\n  /* HasVNodeChildren */\n  ) !== 0;\n\n  if (lastChildFlags & 12\n  /* MultipleChildren */\n  ) {\n    var lastLen = lastChildren.length; // We need to know Fragment's edge node when\n\n    if ( // It uses keyed algorithm\n    lastChildFlags & 8\n    /* HasKeyedChildren */\n    && nextChildFlags & 8\n    /* HasKeyedChildren */\n    || // It transforms from many to single\n    nextIsSingle || // It will append more nodes\n    !nextIsSingle && nextChildren.length > lastLen) {\n      // When fragment has multiple children there is always at least one vNode\n      nextNode = findDOMfromVNode(lastChildren[lastLen - 1], false).nextSibling;\n    }\n  }\n\n  patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lastVNode, lifecycle);\n}\n\nfunction patchPortal(lastVNode, nextVNode, context, lifecycle) {\n  var lastContainer = lastVNode.ref;\n  var nextContainer = nextVNode.ref;\n  var nextChildren = nextVNode.children;\n  patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, lastContainer, context, false, null, lastVNode, lifecycle);\n  nextVNode.dom = lastVNode.dom;\n\n  if (lastContainer !== nextContainer && !isInvalid(nextChildren)) {\n    var node = nextChildren.dom;\n    removeChild(lastContainer, node);\n    appendChild(nextContainer, node);\n  }\n}\n\nfunction patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle) {\n  var dom = nextVNode.dom = lastVNode.dom;\n  var lastProps = lastVNode.props;\n  var nextProps = nextVNode.props;\n  var isFormElement = false;\n  var hasControlledValue = false;\n  var nextPropsOrEmpty;\n  isSVG = isSVG || (nextFlags & 32\n  /* SvgElement */\n  ) > 0; // inlined patchProps  -- starts --\n\n  if (lastProps !== nextProps) {\n    var lastPropsOrEmpty = lastProps || EMPTY_OBJ;\n    nextPropsOrEmpty = nextProps || EMPTY_OBJ;\n\n    if (nextPropsOrEmpty !== EMPTY_OBJ) {\n      isFormElement = (nextFlags & 448\n      /* FormElement */\n      ) > 0;\n\n      if (isFormElement) {\n        hasControlledValue = isControlledFormElement(nextPropsOrEmpty);\n      }\n\n      for (var prop in nextPropsOrEmpty) {\n        var lastValue = lastPropsOrEmpty[prop];\n        var nextValue = nextPropsOrEmpty[prop];\n\n        if (lastValue !== nextValue) {\n          patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode);\n        }\n      }\n    }\n\n    if (lastPropsOrEmpty !== EMPTY_OBJ) {\n      for (var prop$1 in lastPropsOrEmpty) {\n        if (isNullOrUndef(nextPropsOrEmpty[prop$1]) && !isNullOrUndef(lastPropsOrEmpty[prop$1])) {\n          patchProp(prop$1, lastPropsOrEmpty[prop$1], null, dom, isSVG, hasControlledValue, lastVNode);\n        }\n      }\n    }\n  }\n\n  var nextChildren = nextVNode.children;\n  var nextClassName = nextVNode.className; // inlined patchProps  -- ends --\n\n  if (lastVNode.className !== nextClassName) {\n    if (isNullOrUndef(nextClassName)) {\n      dom.removeAttribute('class');\n    } else if (isSVG) {\n      dom.setAttribute('class', nextClassName);\n    } else {\n      dom.className = nextClassName;\n    }\n  }\n\n  if (nextFlags & 4096\n  /* ContentEditable */\n  ) {\n    patchContentEditableChildren(dom, nextChildren);\n  } else {\n    patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, dom, context, isSVG && nextVNode.type !== 'foreignObject', null, lastVNode, lifecycle);\n  }\n\n  if (isFormElement) {\n    processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, false, hasControlledValue);\n  }\n\n  var nextRef = nextVNode.ref;\n  var lastRef = lastVNode.ref;\n\n  if (lastRef !== nextRef) {\n    unmountRef(lastRef);\n    mountRef(nextRef, dom, lifecycle);\n  }\n}\n\nfunction replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle) {\n  unmount(lastChildren);\n  mountArrayChildren(nextChildren, parentDOM, context, isSVG, findDOMfromVNode(lastChildren, true), lifecycle);\n  removeVNodeDOM(lastChildren, parentDOM);\n}\n\nfunction patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, parentVNode, lifecycle) {\n  switch (lastChildFlags) {\n    case 2\n    /* HasVNodeChildren */\n    :\n      switch (nextChildFlags) {\n        case 2\n        /* HasVNodeChildren */\n        :\n          patch(lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n          break;\n\n        case 1\n        /* HasInvalidChildren */\n        :\n          remove(lastChildren, parentDOM);\n          break;\n\n        case 16\n        /* HasTextChildren */\n        :\n          unmount(lastChildren);\n          setTextContent(parentDOM, nextChildren);\n          break;\n\n        default:\n          replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle);\n          break;\n      }\n\n      break;\n\n    case 1\n    /* HasInvalidChildren */\n    :\n      switch (nextChildFlags) {\n        case 2\n        /* HasVNodeChildren */\n        :\n          mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n          break;\n\n        case 1\n        /* HasInvalidChildren */\n        :\n          break;\n\n        case 16\n        /* HasTextChildren */\n        :\n          setTextContent(parentDOM, nextChildren);\n          break;\n\n        default:\n          mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n          break;\n      }\n\n      break;\n\n    case 16\n    /* HasTextChildren */\n    :\n      switch (nextChildFlags) {\n        case 16\n        /* HasTextChildren */\n        :\n          patchSingleTextChild(lastChildren, nextChildren, parentDOM);\n          break;\n\n        case 2\n        /* HasVNodeChildren */\n        :\n          clearDOM(parentDOM);\n          mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n          break;\n\n        case 1\n        /* HasInvalidChildren */\n        :\n          clearDOM(parentDOM);\n          break;\n\n        default:\n          clearDOM(parentDOM);\n          mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n          break;\n      }\n\n      break;\n\n    default:\n      switch (nextChildFlags) {\n        case 16\n        /* HasTextChildren */\n        :\n          unmountAllChildren(lastChildren);\n          setTextContent(parentDOM, nextChildren);\n          break;\n\n        case 2\n        /* HasVNodeChildren */\n        :\n          removeAllChildren(parentDOM, parentVNode, lastChildren);\n          mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n          break;\n\n        case 1\n        /* HasInvalidChildren */\n        :\n          removeAllChildren(parentDOM, parentVNode, lastChildren);\n          break;\n\n        default:\n          var lastLength = lastChildren.length | 0;\n          var nextLength = nextChildren.length | 0; // Fast path's for both algorithms\n\n          if (lastLength === 0) {\n            if (nextLength > 0) {\n              mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n            }\n          } else if (nextLength === 0) {\n            removeAllChildren(parentDOM, parentVNode, lastChildren);\n          } else if (nextChildFlags === 8\n          /* HasKeyedChildren */\n          && lastChildFlags === 8\n          /* HasKeyedChildren */\n          ) {\n            patchKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, parentVNode, lifecycle);\n          } else {\n            patchNonKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, lifecycle);\n          }\n\n          break;\n      }\n\n      break;\n  }\n}\n\nfunction createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle) {\n  lifecycle.push(function () {\n    instance.componentDidUpdate(lastProps, lastState, snapshot);\n  });\n}\n\nfunction updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, force, nextNode, lifecycle) {\n  var lastState = instance.state;\n  var lastProps = instance.props;\n  var usesNewAPI = Boolean(instance.$N);\n  var hasSCU = isFunction(instance.shouldComponentUpdate);\n\n  if (usesNewAPI) {\n    nextState = createDerivedState(instance, nextProps, nextState !== lastState ? combineFrom(lastState, nextState) : nextState);\n  }\n\n  if (force || !hasSCU || hasSCU && instance.shouldComponentUpdate(nextProps, nextState, context)) {\n    if (!usesNewAPI && isFunction(instance.componentWillUpdate)) {\n      instance.componentWillUpdate(nextProps, nextState, context);\n    }\n\n    instance.props = nextProps;\n    instance.state = nextState;\n    instance.context = context;\n    var snapshot = null;\n    var nextInput = renderNewInput(instance, nextProps, context);\n\n    if (usesNewAPI && isFunction(instance.getSnapshotBeforeUpdate)) {\n      snapshot = instance.getSnapshotBeforeUpdate(lastProps, lastState);\n    }\n\n    patch(instance.$LI, nextInput, parentDOM, instance.$CX, isSVG, nextNode, lifecycle); // Dont update Last input, until patch has been succesfully executed\n\n    instance.$LI = nextInput;\n\n    if (isFunction(instance.componentDidUpdate)) {\n      createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle);\n    }\n  } else {\n    instance.props = nextProps;\n    instance.state = nextState;\n    instance.context = context;\n  }\n}\n\nfunction patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n  var instance = nextVNode.children = lastVNode.children; // If Component has crashed, ignore it to stay functional\n\n  if (isNull(instance)) {\n    return;\n  }\n\n  instance.$L = lifecycle;\n  var nextProps = nextVNode.props || EMPTY_OBJ;\n  var nextRef = nextVNode.ref;\n  var lastRef = lastVNode.ref;\n  var nextState = instance.state;\n\n  if (!instance.$N) {\n    if (isFunction(instance.componentWillReceiveProps)) {\n      instance.$BR = true;\n      instance.componentWillReceiveProps(nextProps, context); // If instance component was removed during its own update do nothing.\n\n      if (instance.$UN) {\n        return;\n      }\n\n      instance.$BR = false;\n    }\n\n    if (!isNull(instance.$PS)) {\n      nextState = combineFrom(nextState, instance.$PS);\n      instance.$PS = null;\n    }\n  }\n\n  updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, false, nextNode, lifecycle);\n\n  if (lastRef !== nextRef) {\n    unmountRef(lastRef);\n    mountRef(nextRef, instance, lifecycle);\n  }\n}\n\nfunction patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n  var shouldUpdate = true;\n  var nextProps = nextVNode.props || EMPTY_OBJ;\n  var nextRef = nextVNode.ref;\n  var lastProps = lastVNode.props;\n  var nextHooksDefined = !isNullOrUndef(nextRef);\n  var lastInput = lastVNode.children;\n\n  if (nextHooksDefined && isFunction(nextRef.onComponentShouldUpdate)) {\n    shouldUpdate = nextRef.onComponentShouldUpdate(lastProps, nextProps);\n  }\n\n  if (shouldUpdate !== false) {\n    if (nextHooksDefined && isFunction(nextRef.onComponentWillUpdate)) {\n      nextRef.onComponentWillUpdate(lastProps, nextProps);\n    }\n\n    var nextInput = normalizeRoot(renderFunctionalComponent(nextVNode, context));\n    patch(lastInput, nextInput, parentDOM, context, isSVG, nextNode, lifecycle);\n    nextVNode.children = nextInput;\n\n    if (nextHooksDefined && isFunction(nextRef.onComponentDidUpdate)) {\n      nextRef.onComponentDidUpdate(lastProps, nextProps);\n    }\n  } else {\n    nextVNode.children = lastInput;\n  }\n}\n\nfunction patchText(lastVNode, nextVNode) {\n  var nextText = nextVNode.children;\n  var dom = nextVNode.dom = lastVNode.dom;\n\n  if (nextText !== lastVNode.children) {\n    dom.nodeValue = nextText;\n  }\n}\n\nfunction patchNonKeyedChildren(lastChildren, nextChildren, dom, context, isSVG, lastChildrenLength, nextChildrenLength, nextNode, lifecycle) {\n  var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;\n  var i = 0;\n  var nextChild;\n  var lastChild;\n\n  for (; i < commonLength; ++i) {\n    nextChild = nextChildren[i];\n    lastChild = lastChildren[i];\n\n    if (nextChild.flags & 16384\n    /* InUse */\n    ) {\n      nextChild = nextChildren[i] = directClone(nextChild);\n    }\n\n    patch(lastChild, nextChild, dom, context, isSVG, nextNode, lifecycle);\n    lastChildren[i] = nextChild;\n  }\n\n  if (lastChildrenLength < nextChildrenLength) {\n    for (i = commonLength; i < nextChildrenLength; ++i) {\n      nextChild = nextChildren[i];\n\n      if (nextChild.flags & 16384\n      /* InUse */\n      ) {\n        nextChild = nextChildren[i] = directClone(nextChild);\n      }\n\n      mount(nextChild, dom, context, isSVG, nextNode, lifecycle);\n    }\n  } else if (lastChildrenLength > nextChildrenLength) {\n    for (i = commonLength; i < lastChildrenLength; ++i) {\n      remove(lastChildren[i], dom);\n    }\n  }\n}\n\nfunction patchKeyedChildren(a, b, dom, context, isSVG, aLength, bLength, outerEdge, parentVNode, lifecycle) {\n  var aEnd = aLength - 1;\n  var bEnd = bLength - 1;\n  var j = 0;\n  var aNode = a[j];\n  var bNode = b[j];\n  var nextPos;\n  var nextNode; // Step 1\n  // tslint:disable-next-line\n\n  outer: {\n    // Sync nodes with the same key at the beginning.\n    while (aNode.key === bNode.key) {\n      if (bNode.flags & 16384\n      /* InUse */\n      ) {\n        b[j] = bNode = directClone(bNode);\n      }\n\n      patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n      a[j] = bNode;\n      ++j;\n\n      if (j > aEnd || j > bEnd) {\n        break outer;\n      }\n\n      aNode = a[j];\n      bNode = b[j];\n    }\n\n    aNode = a[aEnd];\n    bNode = b[bEnd]; // Sync nodes with the same key at the end.\n\n    while (aNode.key === bNode.key) {\n      if (bNode.flags & 16384\n      /* InUse */\n      ) {\n        b[bEnd] = bNode = directClone(bNode);\n      }\n\n      patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n      a[aEnd] = bNode;\n      aEnd--;\n      bEnd--;\n\n      if (j > aEnd || j > bEnd) {\n        break outer;\n      }\n\n      aNode = a[aEnd];\n      bNode = b[bEnd];\n    }\n  }\n\n  if (j > aEnd) {\n    if (j <= bEnd) {\n      nextPos = bEnd + 1;\n      nextNode = nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge;\n\n      while (j <= bEnd) {\n        bNode = b[j];\n\n        if (bNode.flags & 16384\n        /* InUse */\n        ) {\n          b[j] = bNode = directClone(bNode);\n        }\n\n        ++j;\n        mount(bNode, dom, context, isSVG, nextNode, lifecycle);\n      }\n    }\n  } else if (j > bEnd) {\n    while (j <= aEnd) {\n      remove(a[j++], dom);\n    }\n  } else {\n    patchKeyedChildrenComplex(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle);\n  }\n}\n\nfunction patchKeyedChildrenComplex(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle) {\n  var aNode;\n  var bNode;\n  var nextPos;\n  var i = 0;\n  var aStart = j;\n  var bStart = j;\n  var aLeft = aEnd - j + 1;\n  var bLeft = bEnd - j + 1;\n  var sources = new Int32Array(bLeft + 1); // Keep track if its possible to remove whole DOM using textContent = '';\n\n  var canRemoveWholeContent = aLeft === aLength;\n  var moved = false;\n  var pos = 0;\n  var patched = 0; // When sizes are small, just loop them through\n\n  if (bLength < 4 || (aLeft | bLeft) < 32) {\n    for (i = aStart; i <= aEnd; ++i) {\n      aNode = a[i];\n\n      if (patched < bLeft) {\n        for (j = bStart; j <= bEnd; j++) {\n          bNode = b[j];\n\n          if (aNode.key === bNode.key) {\n            sources[j - bStart] = i + 1;\n\n            if (canRemoveWholeContent) {\n              canRemoveWholeContent = false;\n\n              while (aStart < i) {\n                remove(a[aStart++], dom);\n              }\n            }\n\n            if (pos > j) {\n              moved = true;\n            } else {\n              pos = j;\n            }\n\n            if (bNode.flags & 16384\n            /* InUse */\n            ) {\n              b[j] = bNode = directClone(bNode);\n            }\n\n            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n            ++patched;\n            break;\n          }\n        }\n\n        if (!canRemoveWholeContent && j > bEnd) {\n          remove(aNode, dom);\n        }\n      } else if (!canRemoveWholeContent) {\n        remove(aNode, dom);\n      }\n    }\n  } else {\n    var keyIndex = {}; // Map keys by their index\n\n    for (i = bStart; i <= bEnd; ++i) {\n      keyIndex[b[i].key] = i;\n    } // Try to patch same keys\n\n\n    for (i = aStart; i <= aEnd; ++i) {\n      aNode = a[i];\n\n      if (patched < bLeft) {\n        j = keyIndex[aNode.key];\n\n        if (j !== void 0) {\n          if (canRemoveWholeContent) {\n            canRemoveWholeContent = false;\n\n            while (i > aStart) {\n              remove(a[aStart++], dom);\n            }\n          }\n\n          sources[j - bStart] = i + 1;\n\n          if (pos > j) {\n            moved = true;\n          } else {\n            pos = j;\n          }\n\n          bNode = b[j];\n\n          if (bNode.flags & 16384\n          /* InUse */\n          ) {\n            b[j] = bNode = directClone(bNode);\n          }\n\n          patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n          ++patched;\n        } else if (!canRemoveWholeContent) {\n          remove(aNode, dom);\n        }\n      } else if (!canRemoveWholeContent) {\n        remove(aNode, dom);\n      }\n    }\n  } // fast-path: if nothing patched remove all old and add all new\n\n\n  if (canRemoveWholeContent) {\n    removeAllChildren(dom, parentVNode, a);\n    mountArrayChildren(b, dom, context, isSVG, outerEdge, lifecycle);\n  } else if (moved) {\n    var seq = lis_algorithm(sources);\n    j = seq.length - 1;\n\n    for (i = bLeft - 1; i >= 0; i--) {\n      if (sources[i] === 0) {\n        pos = i + bStart;\n        bNode = b[pos];\n\n        if (bNode.flags & 16384\n        /* InUse */\n        ) {\n          b[pos] = bNode = directClone(bNode);\n        }\n\n        nextPos = pos + 1;\n        mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);\n      } else if (j < 0 || i !== seq[j]) {\n        pos = i + bStart;\n        bNode = b[pos];\n        nextPos = pos + 1;\n        moveVNodeDOM(bNode, dom, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge);\n      } else {\n        j--;\n      }\n    }\n  } else if (patched !== bLeft) {\n    // when patched count doesn't match b length we need to insert those new ones\n    // loop backwards so we can use insertBefore\n    for (i = bLeft - 1; i >= 0; i--) {\n      if (sources[i] === 0) {\n        pos = i + bStart;\n        bNode = b[pos];\n\n        if (bNode.flags & 16384\n        /* InUse */\n        ) {\n          b[pos] = bNode = directClone(bNode);\n        }\n\n        nextPos = pos + 1;\n        mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);\n      }\n    }\n  }\n}\n\nvar result;\nvar p;\nvar maxLen = 0; // https://en.wikipedia.org/wiki/Longest_increasing_subsequence\n\nfunction lis_algorithm(arr) {\n  var arrI = 0;\n  var i = 0;\n  var j = 0;\n  var k = 0;\n  var u = 0;\n  var v = 0;\n  var c = 0;\n  var len = arr.length;\n\n  if (len > maxLen) {\n    maxLen = len;\n    result = new Int32Array(len);\n    p = new Int32Array(len);\n  }\n\n  for (; i < len; ++i) {\n    arrI = arr[i];\n\n    if (arrI !== 0) {\n      j = result[k];\n\n      if (arr[j] < arrI) {\n        p[i] = j;\n        result[++k] = i;\n        continue;\n      }\n\n      u = 0;\n      v = k;\n\n      while (u < v) {\n        c = u + v >> 1;\n\n        if (arr[result[c]] < arrI) {\n          u = c + 1;\n        } else {\n          v = c;\n        }\n      }\n\n      if (arrI < arr[result[u]]) {\n        if (u > 0) {\n          p[i] = result[u - 1];\n        }\n\n        result[u] = i;\n      }\n    }\n  }\n\n  u = k + 1;\n  var seq = new Int32Array(u);\n  v = result[u - 1];\n\n  while (u-- > 0) {\n    seq[u] = v;\n    v = p[v];\n    result[u] = 0;\n  }\n\n  return seq;\n}\n\nvar hasDocumentAvailable = typeof document !== 'undefined';\n\nif (hasDocumentAvailable) {\n  /*\n   * Defining $EV and $V properties on Node.prototype\n   * fixes v8 \"wrong map\" de-optimization\n   */\n  if (window.Node) {\n    Node.prototype.$EV = null;\n    Node.prototype.$V = null;\n  }\n}\n\nfunction __render(input, parentDOM, callback, context) {\n  var lifecycle = [];\n  var rootInput = parentDOM.$V;\n  renderCheck.v = true;\n\n  if (isNullOrUndef(rootInput)) {\n    if (!isNullOrUndef(input)) {\n      if (input.flags & 16384\n      /* InUse */\n      ) {\n        input = directClone(input);\n      }\n\n      mount(input, parentDOM, context, false, null, lifecycle);\n      parentDOM.$V = input;\n      rootInput = input;\n    }\n  } else {\n    if (isNullOrUndef(input)) {\n      remove(rootInput, parentDOM);\n      parentDOM.$V = null;\n    } else {\n      if (input.flags & 16384\n      /* InUse */\n      ) {\n        input = directClone(input);\n      }\n\n      patch(rootInput, input, parentDOM, context, false, null, lifecycle);\n      rootInput = parentDOM.$V = input;\n    }\n  }\n\n  callAll(lifecycle);\n  renderCheck.v = false;\n\n  if (isFunction(callback)) {\n    callback();\n  }\n\n  if (isFunction(options.renderComplete)) {\n    options.renderComplete(rootInput, parentDOM);\n  }\n}\n\nfunction render(input, parentDOM, callback, context) {\n  if (callback === void 0) callback = null;\n  if (context === void 0) context = EMPTY_OBJ;\n\n  __render(input, parentDOM, callback, context);\n}\n\nfunction createRenderer(parentDOM) {\n  return function renderer(lastInput, nextInput, callback, context) {\n    if (!parentDOM) {\n      parentDOM = lastInput;\n    }\n\n    render(nextInput, parentDOM, callback, context);\n  };\n}\n\nvar QUEUE = [];\nvar nextTick = typeof Promise !== 'undefined' ? Promise.resolve().then.bind(Promise.resolve()) : function (a) {\n  window.setTimeout(a, 0);\n};\nvar microTaskPending = false;\n\nfunction queueStateChanges(component, newState, callback, force) {\n  var pending = component.$PS;\n\n  if (isFunction(newState)) {\n    newState = newState(pending ? combineFrom(component.state, pending) : component.state, component.props, component.context);\n  }\n\n  if (isNullOrUndef(pending)) {\n    component.$PS = newState;\n  } else {\n    for (var stateKey in newState) {\n      pending[stateKey] = newState[stateKey];\n    }\n  }\n\n  if (!component.$BR) {\n    if (!renderCheck.v) {\n      if (QUEUE.length === 0) {\n        applyState(component, force);\n\n        if (isFunction(callback)) {\n          callback.call(component);\n        }\n\n        return;\n      }\n    }\n\n    if (QUEUE.indexOf(component) === -1) {\n      QUEUE.push(component);\n    }\n\n    if (force) {\n      component.$F = true;\n    }\n\n    if (!microTaskPending) {\n      microTaskPending = true;\n      nextTick(rerender);\n    }\n\n    if (isFunction(callback)) {\n      var QU = component.$QU;\n\n      if (!QU) {\n        QU = component.$QU = [];\n      }\n\n      QU.push(callback);\n    }\n  } else if (isFunction(callback)) {\n    component.$L.push(callback.bind(component));\n  }\n}\n\nfunction callSetStateCallbacks(component) {\n  var queue = component.$QU;\n\n  for (var i = 0; i < queue.length; ++i) {\n    queue[i].call(component);\n  }\n\n  component.$QU = null;\n}\n\nfunction rerender() {\n  var component;\n  microTaskPending = false;\n\n  while (component = QUEUE.shift()) {\n    if (!component.$UN) {\n      var force = component.$F;\n      component.$F = false;\n      applyState(component, force);\n\n      if (component.$QU) {\n        callSetStateCallbacks(component);\n      }\n    }\n  }\n}\n\nfunction applyState(component, force) {\n  if (force || !component.$BR) {\n    var pendingState = component.$PS;\n    component.$PS = null;\n    var lifecycle = [];\n    renderCheck.v = true;\n    updateClassComponent(component, combineFrom(component.state, pendingState), component.props, findDOMfromVNode(component.$LI, true).parentNode, component.context, component.$SVG, force, null, lifecycle);\n    callAll(lifecycle);\n    renderCheck.v = false;\n  } else {\n    component.state = component.$PS;\n    component.$PS = null;\n  }\n}\n\nvar Component = function Component(props, context) {\n  // Public\n  this.state = null; // Internal properties\n\n  this.$BR = false; // BLOCK RENDER\n\n  this.$BS = true; // BLOCK STATE\n\n  this.$PS = null; // PENDING STATE (PARTIAL or FULL)\n\n  this.$LI = null; // LAST INPUT\n\n  this.$UN = false; // UNMOUNTED\n\n  this.$CX = null; // CHILDCONTEXT\n\n  this.$QU = null; // QUEUE\n\n  this.$N = false; // Uses new lifecycle API Flag\n\n  this.$L = null; // Current lifecycle of this component\n\n  this.$SVG = false; // Flag to keep track if component is inside SVG tree\n\n  this.$F = false; // Force update flag\n\n  this.props = props || EMPTY_OBJ;\n  this.context = context || EMPTY_OBJ; // context should not be mutable\n};\n\nComponent.prototype.forceUpdate = function forceUpdate(callback) {\n  if (this.$UN) {\n    return;\n  } // Do not allow double render during force update\n\n\n  queueStateChanges(this, {}, callback, true);\n};\n\nComponent.prototype.setState = function setState(newState, callback) {\n  if (this.$UN) {\n    return;\n  }\n\n  if (!this.$BS) {\n    queueStateChanges(this, newState, callback, false);\n  }\n};\n\nComponent.prototype.render = function render(_nextProps, _nextState, _nextContext) {\n  return null;\n};\n\nvar version = \"7.4.11\";\nexport { Component, EMPTY_OBJ, Fragment, createClassComponentInstance as _CI, normalizeRoot as _HI, mount as _M, mountClassComponentCallbacks as _MCCC, mountElement as _ME, mountFunctionalComponentCallbacks as _MFCC, mountProps as _MP, mountRef as _MR, renderFunctionalComponent as _RFC, __render, createComponentVNode, createFragment, createPortal, createRef, createRenderer, createTextVNode, createVNode, directClone, findDOMfromVNode, forwardRef, getFlagsForElementVnode, linkEvent, normalizeProps, options, render, rerender, version };","map":{"version":3,"names":["isArray","Array","isStringOrNumber","o","type","isNullOrUndef","isInvalid","isFunction","isString","isNumber","isNull","isUndefined","combineFrom","first","second","out","key","key$1","linkEvent","data","event","isLinkEventObject","EMPTY_OBJ","Fragment","normalizeEventName","name","substr","toLowerCase","appendChild","parentDOM","dom","insertOrAppend","newNode","nextNode","insertBefore","documentCreateElement","tag","isSVG","document","createElementNS","createElement","replaceChild","newDom","lastDom","removeChild","childNode","callAll","arrayFn","i","length","findChildVNode","vNode","startEdge","flags","children","$LI","childFlags","findDOMfromVNode","removeVNodeDOM","len","moveVNodeDOM","createDerivedState","instance","nextProps","state","constructor","getDerivedStateFromProps","renderCheck","v","options","componentComparator","createVNode","renderComplete","setTextContent","textContent","isLastValueSameLinkEvent","lastValue","nextValue","mergeUnsetProperties","to","from","propName","safeCall1","method","arg1","keyPrefix","V","className","props","ref","childFlag","normalizeChildren","mergeDefaultHooks","defaultHooks","render","mergeDefaultProps","defaultProps","resolveComponentFlags","prototype","createComponentVNode","createTextVNode","text","createFragment","fragment","createVoidVNode","normalizeProps","undefined","cloneFragment","vNodeToClone","oldChildren","directClone","map","propsToClone","createPortal","container","normalizedRoot","normalizeRoot","_normalizeVNodes","nodes","result","index","currentKey","n","newKey","oldKey","isPrefixedKey","substring","push","getFlagsForElementVnode","newChildren","newChildFlags","slice","needsCloning","isNullKey","isPrefixed","input","xlinkNS","xmlNS","namespaces","getDelegatedEventObject","onClick","onDblClick","onFocusIn","onFocusOut","onKeyDown","onKeyPress","onKeyUp","onMouseDown","onMouseMove","onMouseUp","onTouchEnd","onTouchMove","onTouchStart","attachedEventCounts","attachedEvents","syntheticEvents","updateOrAddSyntheticEvent","eventsObject","$EV","attachEventToDocument","unmountSyntheticEvent","removeEventListener","handleSyntheticEvent","lastEvent","nextEvent","getTargetNode","composedPath","target","dispatchEvents","isClick","eventData","disabled","currentEvent","cancelBubble","parentNode","stopPropagation","immediatePropagationStopped","stopImmediatePropagation","isDefaultPrevented","defaultPrevented","isPropagationStopped","extendEventProperties","Object","defineProperty","configurable","get","rootClickEvent","button","rootEvent","attachedEvent","addEventListener","isSameInnerHTML","innerHTML","tempdom","triggerEventListener","methodName","e","listener","nativeListenerName","createWrappedFunction","applyValue","fnMethod","$V","newVNode","newProps","enumerable","value","writable","attachEvent","eventName","handler","previousKey","previousArgs","wrapped","isCheckedType","onTextInputChange","applyValueInput","wrappedOnChange","emptywrapper","inputEvents","nextPropsOrEmpty","checked","multiple","defaultValue","hasValue","setAttribute","updateChildOptions","updateChildOption","indexOf","selected","onSelectChange","applyValueSelect","selectEvents","mounting","multiplePropInBoolean","Boolean","selectedIndex","onTextareaInputChange","applyValueTextArea","wrappedOnChange$1","textAreaEvents","onChange","domValue","processElement","isControlled","addFormElementEventHandlers","isControlledFormElement","createRef","current","forwardRef","unmountRef","mountRef","lifecycle","remove","unmount","keys","unmountAllChildren","componentWillUnmount","$UN","onComponentWillUnmount","clearDOM","removeAllChildren","wrapLinkEvent","ev","patchEvent","patchStyle","lastAttrValue","nextAttrValue","removeAttribute","domStyle","style","cssText","setProperty","removeProperty","patchDangerInnerHTML","lastVNode","lastHtml","__html","nextHtml","patchProp","prop","hasControlledValue","autofocus","charCodeAt","setAttributeNS","mountProps","isFormElement","renderNewInput","context","nextInput","childContext","getChildContext","$CX","createClassComponentInstance","Component","usesNewAPI","$N","getSnapshotBeforeUpdate","$SVG","$L","$BS","componentWillMount","$BR","pending","$PS","renderFunctionalComponent","mount","mountElement","mountClassComponent","mountFunctionalComponent","mountFunctionalComponentCallbacks","mountText","mountFragment","mountPortal","placeHolderVNode","mountArrayChildren","createTextNode","childrenIsSVG","child","mountClassComponentCallbacks","createClassMountCallback","componentDidMount","createOnMountCallback","onComponentDidMount","onComponentWillMount","replaceWithNewNode","nextVNode","patch","nextFlags","patchElement","patchClassComponent","patchFunctionalComponent","patchText","patchFragment","patchPortal","patchSingleTextChild","lastChildren","nextChildren","firstChild","nodeValue","patchContentEditableChildren","lastChildFlags","nextChildFlags","nextIsSingle","lastLen","nextSibling","patchChildren","lastContainer","nextContainer","node","lastProps","lastPropsOrEmpty","prop$1","nextClassName","nextRef","lastRef","replaceOneVNodeWithMultipleVNodes","parentVNode","lastLength","nextLength","patchKeyedChildren","patchNonKeyedChildren","createDidUpdate","lastState","snapshot","componentDidUpdate","updateClassComponent","nextState","force","hasSCU","shouldComponentUpdate","componentWillUpdate","componentWillReceiveProps","shouldUpdate","nextHooksDefined","lastInput","onComponentShouldUpdate","onComponentWillUpdate","onComponentDidUpdate","nextText","lastChildrenLength","nextChildrenLength","commonLength","nextChild","lastChild","a","b","aLength","bLength","outerEdge","aEnd","bEnd","j","aNode","bNode","nextPos","outer","patchKeyedChildrenComplex","aStart","bStart","aLeft","bLeft","sources","Int32Array","canRemoveWholeContent","moved","pos","patched","keyIndex","seq","lis_algorithm","p","maxLen","arr","arrI","k","u","c","hasDocumentAvailable","window","Node","__render","callback","rootInput","createRenderer","renderer","QUEUE","nextTick","Promise","resolve","then","bind","setTimeout","microTaskPending","queueStateChanges","component","newState","stateKey","applyState","call","$F","rerender","QU","$QU","callSetStateCallbacks","queue","shift","pendingState","forceUpdate","setState","_nextProps","_nextState","_nextContext","version","_CI","_HI","_M","_MCCC","_ME","_MFCC","_MP","_MR","_RFC"],"sources":["E:/MisaProject/MISA_EMIS/MISA.EMIS.FE/node_modules/inferno/dist/index.esm.js"],"sourcesContent":["var isArray = Array.isArray;\nfunction isStringOrNumber(o) {\n    var type = typeof o;\n    return type === 'string' || type === 'number';\n}\nfunction isNullOrUndef(o) {\n    return o === void 0 || o === null;\n}\nfunction isInvalid(o) {\n    return o === null || o === false || o === true || o === void 0;\n}\nfunction isFunction(o) {\n    return typeof o === 'function';\n}\nfunction isString(o) {\n    return typeof o === 'string';\n}\nfunction isNumber(o) {\n    return typeof o === 'number';\n}\nfunction isNull(o) {\n    return o === null;\n}\nfunction isUndefined(o) {\n    return o === void 0;\n}\nfunction combineFrom(first, second) {\n    var out = {};\n    if (first) {\n        for (var key in first) {\n            out[key] = first[key];\n        }\n    }\n    if (second) {\n        for (var key$1 in second) {\n            out[key$1] = second[key$1];\n        }\n    }\n    return out;\n}\n\n/**\n * Links given data to event as first parameter\n * @param {*} data data to be linked, it will be available in function as first parameter\n * @param {Function} event Function to be called when event occurs\n * @returns {{data: *, event: Function}}\n */\nfunction linkEvent(data, event) {\n    if (isFunction(event)) {\n        return { data: data, event: event };\n    }\n    return null; // Return null when event is invalid, to avoid creating unnecessary event handlers\n}\n// object.event should always be function, otherwise its badly created object.\nfunction isLinkEventObject(o) {\n    return !isNull(o) && typeof o === 'object';\n}\n\n// We need EMPTY_OBJ defined in one place.\n// Its used for comparison so we cant inline it into shared\nvar EMPTY_OBJ = {};\nvar Fragment = '$F';\nfunction normalizeEventName(name) {\n    return name.substr(2).toLowerCase();\n}\nfunction appendChild(parentDOM, dom) {\n    parentDOM.appendChild(dom);\n}\nfunction insertOrAppend(parentDOM, newNode, nextNode) {\n    if (isNull(nextNode)) {\n        appendChild(parentDOM, newNode);\n    }\n    else {\n        parentDOM.insertBefore(newNode, nextNode);\n    }\n}\nfunction documentCreateElement(tag, isSVG) {\n    if (isSVG) {\n        return document.createElementNS('http://www.w3.org/2000/svg', tag);\n    }\n    return document.createElement(tag);\n}\nfunction replaceChild(parentDOM, newDom, lastDom) {\n    parentDOM.replaceChild(newDom, lastDom);\n}\nfunction removeChild(parentDOM, childNode) {\n    parentDOM.removeChild(childNode);\n}\nfunction callAll(arrayFn) {\n    for (var i = 0; i < arrayFn.length; i++) {\n        arrayFn[i]();\n    }\n}\nfunction findChildVNode(vNode, startEdge, flags) {\n    var children = vNode.children;\n    if (flags & 4 /* ComponentClass */) {\n        return children.$LI;\n    }\n    if (flags & 8192 /* Fragment */) {\n        return vNode.childFlags === 2 /* HasVNodeChildren */ ? children : children[startEdge ? 0 : children.length - 1];\n    }\n    return children;\n}\nfunction findDOMfromVNode(vNode, startEdge) {\n    var flags;\n    while (vNode) {\n        flags = vNode.flags;\n        if (flags & 2033 /* DOMRef */) {\n            return vNode.dom;\n        }\n        vNode = findChildVNode(vNode, startEdge, flags);\n    }\n    return null;\n}\nfunction removeVNodeDOM(vNode, parentDOM) {\n    do {\n        var flags = vNode.flags;\n        if (flags & 2033 /* DOMRef */) {\n            removeChild(parentDOM, vNode.dom);\n            return;\n        }\n        var children = vNode.children;\n        if (flags & 4 /* ComponentClass */) {\n            vNode = children.$LI;\n        }\n        if (flags & 8 /* ComponentFunction */) {\n            vNode = children;\n        }\n        if (flags & 8192 /* Fragment */) {\n            if (vNode.childFlags === 2 /* HasVNodeChildren */) {\n                vNode = children;\n            }\n            else {\n                for (var i = 0, len = children.length; i < len; ++i) {\n                    removeVNodeDOM(children[i], parentDOM);\n                }\n                return;\n            }\n        }\n    } while (vNode);\n}\nfunction moveVNodeDOM(vNode, parentDOM, nextNode) {\n    do {\n        var flags = vNode.flags;\n        if (flags & 2033 /* DOMRef */) {\n            insertOrAppend(parentDOM, vNode.dom, nextNode);\n            return;\n        }\n        var children = vNode.children;\n        if (flags & 4 /* ComponentClass */) {\n            vNode = children.$LI;\n        }\n        if (flags & 8 /* ComponentFunction */) {\n            vNode = children;\n        }\n        if (flags & 8192 /* Fragment */) {\n            if (vNode.childFlags === 2 /* HasVNodeChildren */) {\n                vNode = children;\n            }\n            else {\n                for (var i = 0, len = children.length; i < len; ++i) {\n                    moveVNodeDOM(children[i], parentDOM, nextNode);\n                }\n                return;\n            }\n        }\n    } while (vNode);\n}\nfunction createDerivedState(instance, nextProps, state) {\n    if (instance.constructor.getDerivedStateFromProps) {\n        return combineFrom(state, instance.constructor.getDerivedStateFromProps(nextProps, state));\n    }\n    return state;\n}\nvar renderCheck = {\n    v: false\n};\nvar options = {\n    componentComparator: null,\n    createVNode: null,\n    renderComplete: null\n};\nfunction setTextContent(dom, children) {\n    dom.textContent = children;\n}\n// Calling this function assumes, nextValue is linkEvent\nfunction isLastValueSameLinkEvent(lastValue, nextValue) {\n    return (isLinkEventObject(lastValue) &&\n        lastValue.event === nextValue.event &&\n        lastValue.data === nextValue.data);\n}\nfunction mergeUnsetProperties(to, from) {\n    for (var propName in from) {\n        if (isUndefined(to[propName])) {\n            to[propName] = from[propName];\n        }\n    }\n    return to;\n}\nfunction safeCall1(method, arg1) {\n    return !!isFunction(method) && (method(arg1), true);\n}\n\nvar keyPrefix = '$';\nfunction V(childFlags, children, className, flags, key, props, ref, type) {\n    this.childFlags = childFlags;\n    this.children = children;\n    this.className = className;\n    this.dom = null;\n    this.flags = flags;\n    this.key = key === void 0 ? null : key;\n    this.props = props === void 0 ? null : props;\n    this.ref = ref === void 0 ? null : ref;\n    this.type = type;\n}\nfunction createVNode(flags, type, className, children, childFlags, props, key, ref) {\n    var childFlag = childFlags === void 0 ? 1 /* HasInvalidChildren */ : childFlags;\n    var vNode = new V(childFlag, children, className, flags, key, props, ref, type);\n    if (options.createVNode) {\n        options.createVNode(vNode);\n    }\n    if (childFlag === 0 /* UnknownChildren */) {\n        normalizeChildren(vNode, vNode.children);\n    }\n    return vNode;\n}\nfunction mergeDefaultHooks(flags, type, ref) {\n    if (flags & 4 /* ComponentClass */) {\n        return ref;\n    }\n    var defaultHooks = (flags & 32768 /* ForwardRef */ ? type.render : type).defaultHooks;\n    if (isNullOrUndef(defaultHooks)) {\n        return ref;\n    }\n    if (isNullOrUndef(ref)) {\n        return defaultHooks;\n    }\n    return mergeUnsetProperties(ref, defaultHooks);\n}\nfunction mergeDefaultProps(flags, type, props) {\n    // set default props\n    var defaultProps = (flags & 32768 /* ForwardRef */ ? type.render : type).defaultProps;\n    if (isNullOrUndef(defaultProps)) {\n        return props;\n    }\n    if (isNullOrUndef(props)) {\n        return combineFrom(defaultProps, null);\n    }\n    return mergeUnsetProperties(props, defaultProps);\n}\nfunction resolveComponentFlags(flags, type) {\n    if (flags & 12 /* ComponentKnown */) {\n        return flags;\n    }\n    if (type.prototype && type.prototype.render) {\n        return 4 /* ComponentClass */;\n    }\n    if (type.render) {\n        return 32776 /* ForwardRefComponent */;\n    }\n    return 8 /* ComponentFunction */;\n}\nfunction createComponentVNode(flags, type, props, key, ref) {\n    flags = resolveComponentFlags(flags, type);\n    var vNode = new V(1 /* HasInvalidChildren */, null, null, flags, key, mergeDefaultProps(flags, type, props), mergeDefaultHooks(flags, type, ref), type);\n    if (options.createVNode) {\n        options.createVNode(vNode);\n    }\n    return vNode;\n}\nfunction createTextVNode(text, key) {\n    return new V(1 /* HasInvalidChildren */, isNullOrUndef(text) || text === true || text === false ? '' : text, null, 16 /* Text */, key, null, null, null);\n}\nfunction createFragment(children, childFlags, key) {\n    var fragment = createVNode(8192 /* Fragment */, 8192 /* Fragment */, null, children, childFlags, null, key, null);\n    switch (fragment.childFlags) {\n        case 1 /* HasInvalidChildren */:\n            fragment.children = createVoidVNode();\n            fragment.childFlags = 2 /* HasVNodeChildren */;\n            break;\n        case 16 /* HasTextChildren */:\n            fragment.children = [createTextVNode(children)];\n            fragment.childFlags = 4 /* HasNonKeyedChildren */;\n            break;\n    }\n    return fragment;\n}\nfunction normalizeProps(vNode) {\n    var props = vNode.props;\n    if (props) {\n        var flags = vNode.flags;\n        if (flags & 481 /* Element */) {\n            if (props.children !== void 0 && isNullOrUndef(vNode.children)) {\n                normalizeChildren(vNode, props.children);\n            }\n            if (props.className !== void 0) {\n                if (isNullOrUndef(vNode.className)) {\n                    vNode.className = props.className || null;\n                }\n                props.className = undefined;\n            }\n        }\n        if (props.key !== void 0) {\n            vNode.key = props.key;\n            props.key = undefined;\n        }\n        if (props.ref !== void 0) {\n            if (flags & 8 /* ComponentFunction */) {\n                vNode.ref = combineFrom(vNode.ref, props.ref);\n            }\n            else {\n                vNode.ref = props.ref;\n            }\n            props.ref = undefined;\n        }\n    }\n    return vNode;\n}\n/*\n * Fragment is different than normal vNode,\n * because when it needs to be cloned we need to clone its children too\n * But not normalize, because otherwise those possibly get KEY and re-mount\n */\nfunction cloneFragment(vNodeToClone) {\n    var oldChildren = vNodeToClone.children;\n    var childFlags = vNodeToClone.childFlags;\n    return createFragment(childFlags === 2 /* HasVNodeChildren */ ? directClone(oldChildren) : oldChildren.map(directClone), childFlags, vNodeToClone.key);\n}\nfunction directClone(vNodeToClone) {\n    var flags = vNodeToClone.flags & -16385 /* ClearInUse */;\n    var props = vNodeToClone.props;\n    if (flags & 14 /* Component */) {\n        if (!isNull(props)) {\n            var propsToClone = props;\n            props = {};\n            for (var key in propsToClone) {\n                props[key] = propsToClone[key];\n            }\n        }\n    }\n    if ((flags & 8192 /* Fragment */) === 0) {\n        return new V(vNodeToClone.childFlags, vNodeToClone.children, vNodeToClone.className, flags, vNodeToClone.key, props, vNodeToClone.ref, vNodeToClone.type);\n    }\n    return cloneFragment(vNodeToClone);\n}\nfunction createVoidVNode() {\n    return createTextVNode('', null);\n}\nfunction createPortal(children, container) {\n    var normalizedRoot = normalizeRoot(children);\n    return createVNode(1024 /* Portal */, 1024 /* Portal */, null, normalizedRoot, 0 /* UnknownChildren */, null, normalizedRoot.key, container);\n}\nfunction _normalizeVNodes(nodes, result, index, currentKey) {\n    for (var len = nodes.length; index < len; index++) {\n        var n = nodes[index];\n        if (!isInvalid(n)) {\n            var newKey = currentKey + keyPrefix + index;\n            if (isArray(n)) {\n                _normalizeVNodes(n, result, 0, newKey);\n            }\n            else {\n                if (isStringOrNumber(n)) {\n                    n = createTextVNode(n, newKey);\n                }\n                else {\n                    var oldKey = n.key;\n                    var isPrefixedKey = isString(oldKey) && oldKey[0] === keyPrefix;\n                    if (n.flags & 81920 /* InUseOrNormalized */ || isPrefixedKey) {\n                        n = directClone(n);\n                    }\n                    n.flags |= 65536 /* Normalized */;\n                    if (!isPrefixedKey) {\n                        if (isNull(oldKey)) {\n                            n.key = newKey;\n                        }\n                        else {\n                            n.key = currentKey + oldKey;\n                        }\n                    }\n                    else if (oldKey.substring(0, currentKey.length) !== currentKey) {\n                        n.key = currentKey + oldKey;\n                    }\n                }\n                result.push(n);\n            }\n        }\n    }\n}\nfunction getFlagsForElementVnode(type) {\n    switch (type) {\n        case 'svg':\n            return 32 /* SvgElement */;\n        case 'input':\n            return 64 /* InputElement */;\n        case 'select':\n            return 256 /* SelectElement */;\n        case 'textarea':\n            return 128 /* TextareaElement */;\n        case Fragment:\n            return 8192 /* Fragment */;\n        default:\n            return 1 /* HtmlElement */;\n    }\n}\nfunction normalizeChildren(vNode, children) {\n    var newChildren;\n    var newChildFlags = 1 /* HasInvalidChildren */;\n    // Don't change children to match strict equal (===) true in patching\n    if (isInvalid(children)) {\n        newChildren = children;\n    }\n    else if (isStringOrNumber(children)) {\n        newChildFlags = 16 /* HasTextChildren */;\n        newChildren = children;\n    }\n    else if (isArray(children)) {\n        var len = children.length;\n        for (var i = 0; i < len; ++i) {\n            var n = children[i];\n            if (isInvalid(n) || isArray(n)) {\n                newChildren = newChildren || children.slice(0, i);\n                _normalizeVNodes(children, newChildren, i, '');\n                break;\n            }\n            else if (isStringOrNumber(n)) {\n                newChildren = newChildren || children.slice(0, i);\n                newChildren.push(createTextVNode(n, keyPrefix + i));\n            }\n            else {\n                var key = n.key;\n                var needsCloning = (n.flags & 81920 /* InUseOrNormalized */) > 0;\n                var isNullKey = isNull(key);\n                var isPrefixed = isString(key) && key[0] === keyPrefix;\n                if (needsCloning || isNullKey || isPrefixed) {\n                    newChildren = newChildren || children.slice(0, i);\n                    if (needsCloning || isPrefixed) {\n                        n = directClone(n);\n                    }\n                    if (isNullKey || isPrefixed) {\n                        n.key = keyPrefix + i;\n                    }\n                    newChildren.push(n);\n                }\n                else if (newChildren) {\n                    newChildren.push(n);\n                }\n                n.flags |= 65536 /* Normalized */;\n            }\n        }\n        newChildren = newChildren || children;\n        if (newChildren.length === 0) {\n            newChildFlags = 1 /* HasInvalidChildren */;\n        }\n        else {\n            newChildFlags = 8 /* HasKeyedChildren */;\n        }\n    }\n    else {\n        newChildren = children;\n        newChildren.flags |= 65536 /* Normalized */;\n        if (children.flags & 81920 /* InUseOrNormalized */) {\n            newChildren = directClone(children);\n        }\n        newChildFlags = 2 /* HasVNodeChildren */;\n    }\n    vNode.children = newChildren;\n    vNode.childFlags = newChildFlags;\n    return vNode;\n}\nfunction normalizeRoot(input) {\n    if (isInvalid(input) || isStringOrNumber(input)) {\n        return createTextVNode(input, null);\n    }\n    if (isArray(input)) {\n        return createFragment(input, 0 /* UnknownChildren */, null);\n    }\n    return input.flags & 16384 /* InUse */ ? directClone(input) : input;\n}\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\nvar xmlNS = 'http://www.w3.org/XML/1998/namespace';\nvar namespaces = {\n    'xlink:actuate': xlinkNS,\n    'xlink:arcrole': xlinkNS,\n    'xlink:href': xlinkNS,\n    'xlink:role': xlinkNS,\n    'xlink:show': xlinkNS,\n    'xlink:title': xlinkNS,\n    'xlink:type': xlinkNS,\n    'xml:base': xmlNS,\n    'xml:lang': xmlNS,\n    'xml:space': xmlNS\n};\n\nfunction getDelegatedEventObject(v) {\n    return {\n        onClick: v,\n        onDblClick: v,\n        onFocusIn: v,\n        onFocusOut: v,\n        onKeyDown: v,\n        onKeyPress: v,\n        onKeyUp: v,\n        onMouseDown: v,\n        onMouseMove: v,\n        onMouseUp: v,\n        onTouchEnd: v,\n        onTouchMove: v,\n        onTouchStart: v\n    };\n}\nvar attachedEventCounts = getDelegatedEventObject(0);\nvar attachedEvents = getDelegatedEventObject(null);\nvar syntheticEvents = getDelegatedEventObject(true);\nfunction updateOrAddSyntheticEvent(name, dom) {\n    var eventsObject = dom.$EV;\n    if (!eventsObject) {\n        eventsObject = dom.$EV = getDelegatedEventObject(null);\n    }\n    if (!eventsObject[name]) {\n        if (++attachedEventCounts[name] === 1) {\n            attachedEvents[name] = attachEventToDocument(name);\n        }\n    }\n    return eventsObject;\n}\nfunction unmountSyntheticEvent(name, dom) {\n    var eventsObject = dom.$EV;\n    if (eventsObject && eventsObject[name]) {\n        if (--attachedEventCounts[name] === 0) {\n            document.removeEventListener(normalizeEventName(name), attachedEvents[name]);\n            attachedEvents[name] = null;\n        }\n        eventsObject[name] = null;\n    }\n}\nfunction handleSyntheticEvent(name, lastEvent, nextEvent, dom) {\n    if (isFunction(nextEvent)) {\n        updateOrAddSyntheticEvent(name, dom)[name] = nextEvent;\n    }\n    else if (isLinkEventObject(nextEvent)) {\n        if (isLastValueSameLinkEvent(lastEvent, nextEvent)) {\n            return;\n        }\n        updateOrAddSyntheticEvent(name, dom)[name] = nextEvent;\n    }\n    else {\n        unmountSyntheticEvent(name, dom);\n    }\n}\n// When browsers fully support event.composedPath we could loop it through instead of using parentNode property\nfunction getTargetNode(event) {\n    return isFunction(event.composedPath) ? event.composedPath()[0] : event.target;\n}\nfunction dispatchEvents(event, isClick, name, eventData) {\n    var dom = getTargetNode(event);\n    do {\n        // Html Nodes can be nested fe: span inside button in that scenario browser does not handle disabled attribute on parent,\n        // because the event listener is on document.body\n        // Don't process clicks on disabled elements\n        if (isClick && dom.disabled) {\n            return;\n        }\n        var eventsObject = dom.$EV;\n        if (eventsObject) {\n            var currentEvent = eventsObject[name];\n            if (currentEvent) {\n                // linkEvent object\n                eventData.dom = dom;\n                currentEvent.event ? currentEvent.event(currentEvent.data, event) : currentEvent(event);\n                if (event.cancelBubble) {\n                    return;\n                }\n            }\n        }\n        dom = dom.parentNode;\n    } while (!isNull(dom));\n}\nfunction stopPropagation() {\n    this.cancelBubble = true;\n    if (!this.immediatePropagationStopped) {\n        this.stopImmediatePropagation();\n    }\n}\nfunction isDefaultPrevented() {\n    return this.defaultPrevented;\n}\nfunction isPropagationStopped() {\n    return this.cancelBubble;\n}\nfunction extendEventProperties(event) {\n    // Event data needs to be object to save reference to currentTarget getter\n    var eventData = {\n        dom: document\n    };\n    event.isDefaultPrevented = isDefaultPrevented;\n    event.isPropagationStopped = isPropagationStopped;\n    event.stopPropagation = stopPropagation;\n    Object.defineProperty(event, 'currentTarget', {\n        configurable: true,\n        get: function get() {\n            return eventData.dom;\n        }\n    });\n    return eventData;\n}\nfunction rootClickEvent(name) {\n    return function (event) {\n        if (event.button !== 0) {\n            // Firefox incorrectly triggers click event for mid/right mouse buttons.\n            // This bug has been active for 17 years.\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=184051\n            event.stopPropagation();\n            return;\n        }\n        dispatchEvents(event, true, name, extendEventProperties(event));\n    };\n}\nfunction rootEvent(name) {\n    return function (event) {\n        dispatchEvents(event, false, name, extendEventProperties(event));\n    };\n}\nfunction attachEventToDocument(name) {\n    var attachedEvent = name === 'onClick' || name === 'onDblClick' ? rootClickEvent(name) : rootEvent(name);\n    document.addEventListener(normalizeEventName(name), attachedEvent);\n    return attachedEvent;\n}\n\nfunction isSameInnerHTML(dom, innerHTML) {\n    var tempdom = document.createElement('i');\n    tempdom.innerHTML = innerHTML;\n    return tempdom.innerHTML === dom.innerHTML;\n}\n\nfunction triggerEventListener(props, methodName, e) {\n    if (props[methodName]) {\n        var listener = props[methodName];\n        if (listener.event) {\n            listener.event(listener.data, e);\n        }\n        else {\n            listener(e);\n        }\n    }\n    else {\n        var nativeListenerName = methodName.toLowerCase();\n        if (props[nativeListenerName]) {\n            props[nativeListenerName](e);\n        }\n    }\n}\nfunction createWrappedFunction(methodName, applyValue) {\n    var fnMethod = function (e) {\n        var vNode = this.$V;\n        // If vNode is gone by the time event fires, no-op\n        if (!vNode) {\n            return;\n        }\n        var props = vNode.props || EMPTY_OBJ;\n        var dom = vNode.dom;\n        if (isString(methodName)) {\n            triggerEventListener(props, methodName, e);\n        }\n        else {\n            for (var i = 0; i < methodName.length; ++i) {\n                triggerEventListener(props, methodName[i], e);\n            }\n        }\n        if (isFunction(applyValue)) {\n            var newVNode = this.$V;\n            var newProps = newVNode.props || EMPTY_OBJ;\n            applyValue(newProps, dom, false, newVNode);\n        }\n    };\n    Object.defineProperty(fnMethod, 'wrapped', {\n        configurable: false,\n        enumerable: false,\n        value: true,\n        writable: false\n    });\n    return fnMethod;\n}\n\nfunction attachEvent(dom, eventName, handler) {\n    var previousKey = \"$\" + eventName;\n    var previousArgs = dom[previousKey];\n    if (previousArgs) {\n        if (previousArgs[1].wrapped) {\n            return;\n        }\n        dom.removeEventListener(previousArgs[0], previousArgs[1]);\n        dom[previousKey] = null;\n    }\n    if (isFunction(handler)) {\n        dom.addEventListener(eventName, handler);\n        dom[previousKey] = [eventName, handler];\n    }\n}\n\nfunction isCheckedType(type) {\n    return type === 'checkbox' || type === 'radio';\n}\nvar onTextInputChange = createWrappedFunction('onInput', applyValueInput);\nvar wrappedOnChange = createWrappedFunction(['onClick', 'onChange'], applyValueInput);\n/* tslint:disable-next-line:no-empty */\nfunction emptywrapper(event) {\n    event.stopPropagation();\n}\nemptywrapper.wrapped = true;\nfunction inputEvents(dom, nextPropsOrEmpty) {\n    if (isCheckedType(nextPropsOrEmpty.type)) {\n        attachEvent(dom, 'change', wrappedOnChange);\n        attachEvent(dom, 'click', emptywrapper);\n    }\n    else {\n        attachEvent(dom, 'input', onTextInputChange);\n    }\n}\nfunction applyValueInput(nextPropsOrEmpty, dom) {\n    var type = nextPropsOrEmpty.type;\n    var value = nextPropsOrEmpty.value;\n    var checked = nextPropsOrEmpty.checked;\n    var multiple = nextPropsOrEmpty.multiple;\n    var defaultValue = nextPropsOrEmpty.defaultValue;\n    var hasValue = !isNullOrUndef(value);\n    if (type && type !== dom.type) {\n        dom.setAttribute('type', type);\n    }\n    if (!isNullOrUndef(multiple) && multiple !== dom.multiple) {\n        dom.multiple = multiple;\n    }\n    if (!isNullOrUndef(defaultValue) && !hasValue) {\n        dom.defaultValue = defaultValue + '';\n    }\n    if (isCheckedType(type)) {\n        if (hasValue) {\n            dom.value = value;\n        }\n        if (!isNullOrUndef(checked)) {\n            dom.checked = checked;\n        }\n    }\n    else {\n        if (hasValue && dom.value !== value) {\n            dom.defaultValue = value;\n            dom.value = value;\n        }\n        else if (!isNullOrUndef(checked)) {\n            dom.checked = checked;\n        }\n    }\n}\n\nfunction updateChildOptions(vNode, value) {\n    if (vNode.type === 'option') {\n        updateChildOption(vNode, value);\n    }\n    else {\n        var children = vNode.children;\n        var flags = vNode.flags;\n        if (flags & 4 /* ComponentClass */) {\n            updateChildOptions(children.$LI, value);\n        }\n        else if (flags & 8 /* ComponentFunction */) {\n            updateChildOptions(children, value);\n        }\n        else if (vNode.childFlags === 2 /* HasVNodeChildren */) {\n            updateChildOptions(children, value);\n        }\n        else if (vNode.childFlags & 12 /* MultipleChildren */) {\n            for (var i = 0, len = children.length; i < len; ++i) {\n                updateChildOptions(children[i], value);\n            }\n        }\n    }\n}\nfunction updateChildOption(vNode, value) {\n    var props = vNode.props || EMPTY_OBJ;\n    var dom = vNode.dom;\n    // we do this as multiple may have changed\n    dom.value = props.value;\n    if (props.value === value || (isArray(value) && value.indexOf(props.value) !== -1)) {\n        dom.selected = true;\n    }\n    else if (!isNullOrUndef(value) || !isNullOrUndef(props.selected)) {\n        dom.selected = props.selected || false;\n    }\n}\nvar onSelectChange = createWrappedFunction('onChange', applyValueSelect);\nfunction selectEvents(dom) {\n    attachEvent(dom, 'change', onSelectChange);\n}\nfunction applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode) {\n    var multiplePropInBoolean = Boolean(nextPropsOrEmpty.multiple);\n    if (!isNullOrUndef(nextPropsOrEmpty.multiple) && multiplePropInBoolean !== dom.multiple) {\n        dom.multiple = multiplePropInBoolean;\n    }\n    var index = nextPropsOrEmpty.selectedIndex;\n    if (index === -1) {\n        dom.selectedIndex = -1;\n    }\n    var childFlags = vNode.childFlags;\n    if (childFlags !== 1 /* HasInvalidChildren */) {\n        var value = nextPropsOrEmpty.value;\n        if (isNumber(index) && index > -1 && dom.options[index]) {\n            value = dom.options[index].value;\n        }\n        if (mounting && isNullOrUndef(value)) {\n            value = nextPropsOrEmpty.defaultValue;\n        }\n        updateChildOptions(vNode, value);\n    }\n}\n\nvar onTextareaInputChange = createWrappedFunction('onInput', applyValueTextArea);\nvar wrappedOnChange$1 = createWrappedFunction('onChange');\nfunction textAreaEvents(dom, nextPropsOrEmpty) {\n    attachEvent(dom, 'input', onTextareaInputChange);\n    if (nextPropsOrEmpty.onChange) {\n        attachEvent(dom, 'change', wrappedOnChange$1);\n    }\n}\nfunction applyValueTextArea(nextPropsOrEmpty, dom, mounting) {\n    var value = nextPropsOrEmpty.value;\n    var domValue = dom.value;\n    if (isNullOrUndef(value)) {\n        if (mounting) {\n            var defaultValue = nextPropsOrEmpty.defaultValue;\n            if (!isNullOrUndef(defaultValue) && defaultValue !== domValue) {\n                dom.defaultValue = defaultValue;\n                dom.value = defaultValue;\n            }\n        }\n    }\n    else if (domValue !== value) {\n        /* There is value so keep it controlled */\n        dom.defaultValue = value;\n        dom.value = value;\n    }\n}\n\nfunction processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\n    if (flags & 64 /* InputElement */) {\n        applyValueInput(nextPropsOrEmpty, dom);\n    }\n    else if (flags & 256 /* SelectElement */) {\n        applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode);\n    }\n    else if (flags & 128 /* TextareaElement */) {\n        applyValueTextArea(nextPropsOrEmpty, dom, mounting);\n    }\n    if (isControlled) {\n        dom.$V = vNode;\n    }\n}\nfunction addFormElementEventHandlers(flags, dom, nextPropsOrEmpty) {\n    if (flags & 64 /* InputElement */) {\n        inputEvents(dom, nextPropsOrEmpty);\n    }\n    else if (flags & 256 /* SelectElement */) {\n        selectEvents(dom);\n    }\n    else if (flags & 128 /* TextareaElement */) {\n        textAreaEvents(dom, nextPropsOrEmpty);\n    }\n}\nfunction isControlledFormElement(nextPropsOrEmpty) {\n    return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type) ? !isNullOrUndef(nextPropsOrEmpty.checked) : !isNullOrUndef(nextPropsOrEmpty.value);\n}\n\nfunction createRef() {\n    return {\n        current: null\n    };\n}\nfunction forwardRef(render) {\n    // @ts-ignore\n    return {\n        render: render\n    };\n}\nfunction unmountRef(ref) {\n    if (ref) {\n        if (!safeCall1(ref, null) && ref.current) {\n            ref.current = null;\n        }\n    }\n}\nfunction mountRef(ref, value, lifecycle) {\n    if (ref && (isFunction(ref) || ref.current !== void 0)) {\n        lifecycle.push(function () {\n            if (!safeCall1(ref, value) && ref.current !== void 0) {\n                ref.current = value;\n            }\n        });\n    }\n}\n\nfunction remove(vNode, parentDOM) {\n    unmount(vNode);\n    removeVNodeDOM(vNode, parentDOM);\n}\nfunction unmount(vNode) {\n    var flags = vNode.flags;\n    var children = vNode.children;\n    var ref;\n    if (flags & 481 /* Element */) {\n        ref = vNode.ref;\n        var props = vNode.props;\n        unmountRef(ref);\n        var childFlags = vNode.childFlags;\n        if (!isNull(props)) {\n            var keys = Object.keys(props);\n            for (var i = 0, len = keys.length; i < len; i++) {\n                var key = keys[i];\n                if (syntheticEvents[key]) {\n                    unmountSyntheticEvent(key, vNode.dom);\n                }\n            }\n        }\n        if (childFlags & 12 /* MultipleChildren */) {\n            unmountAllChildren(children);\n        }\n        else if (childFlags === 2 /* HasVNodeChildren */) {\n            unmount(children);\n        }\n    }\n    else if (children) {\n        if (flags & 4 /* ComponentClass */) {\n            if (isFunction(children.componentWillUnmount)) {\n                children.componentWillUnmount();\n            }\n            unmountRef(vNode.ref);\n            children.$UN = true;\n            unmount(children.$LI);\n        }\n        else if (flags & 8 /* ComponentFunction */) {\n            ref = vNode.ref;\n            if (!isNullOrUndef(ref) && isFunction(ref.onComponentWillUnmount)) {\n                ref.onComponentWillUnmount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);\n            }\n            unmount(children);\n        }\n        else if (flags & 1024 /* Portal */) {\n            remove(children, vNode.ref);\n        }\n        else if (flags & 8192 /* Fragment */) {\n            if (vNode.childFlags & 12 /* MultipleChildren */) {\n                unmountAllChildren(children);\n            }\n        }\n    }\n}\nfunction unmountAllChildren(children) {\n    for (var i = 0, len = children.length; i < len; ++i) {\n        unmount(children[i]);\n    }\n}\nfunction clearDOM(dom) {\n    // Optimization for clearing dom\n    dom.textContent = '';\n}\nfunction removeAllChildren(dom, vNode, children) {\n    unmountAllChildren(children);\n    if (vNode.flags & 8192 /* Fragment */) {\n        removeVNodeDOM(vNode, dom);\n    }\n    else {\n        clearDOM(dom);\n    }\n}\n\nfunction wrapLinkEvent(nextValue) {\n    // This variable makes sure there is no \"this\" context in callback\n    var ev = nextValue.event;\n    return function (e) {\n        ev(nextValue.data, e);\n    };\n}\nfunction patchEvent(name, lastValue, nextValue, dom) {\n    if (isLinkEventObject(nextValue)) {\n        if (isLastValueSameLinkEvent(lastValue, nextValue)) {\n            return;\n        }\n        nextValue = wrapLinkEvent(nextValue);\n    }\n    attachEvent(dom, normalizeEventName(name), nextValue);\n}\n// We are assuming here that we come from patchProp routine\n// -nextAttrValue cannot be null or undefined\nfunction patchStyle(lastAttrValue, nextAttrValue, dom) {\n    if (isNullOrUndef(nextAttrValue)) {\n        dom.removeAttribute('style');\n        return;\n    }\n    var domStyle = dom.style;\n    var style;\n    var value;\n    if (isString(nextAttrValue)) {\n        domStyle.cssText = nextAttrValue;\n        return;\n    }\n    if (!isNullOrUndef(lastAttrValue) && !isString(lastAttrValue)) {\n        for (style in nextAttrValue) {\n            // do not add a hasOwnProperty check here, it affects performance\n            value = nextAttrValue[style];\n            if (value !== lastAttrValue[style]) {\n                domStyle.setProperty(style, value);\n            }\n        }\n        for (style in lastAttrValue) {\n            if (isNullOrUndef(nextAttrValue[style])) {\n                domStyle.removeProperty(style);\n            }\n        }\n    }\n    else {\n        for (style in nextAttrValue) {\n            value = nextAttrValue[style];\n            domStyle.setProperty(style, value);\n        }\n    }\n}\nfunction patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom) {\n    var lastHtml = (lastValue && lastValue.__html) || '';\n    var nextHtml = (nextValue && nextValue.__html) || '';\n    if (lastHtml !== nextHtml) {\n        if (!isNullOrUndef(nextHtml) && !isSameInnerHTML(dom, nextHtml)) {\n            if (!isNull(lastVNode)) {\n                if (lastVNode.childFlags & 12 /* MultipleChildren */) {\n                    unmountAllChildren(lastVNode.children);\n                }\n                else if (lastVNode.childFlags === 2 /* HasVNodeChildren */) {\n                    unmount(lastVNode.children);\n                }\n                lastVNode.children = null;\n                lastVNode.childFlags = 1 /* HasInvalidChildren */;\n            }\n            dom.innerHTML = nextHtml;\n        }\n    }\n}\nfunction patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode) {\n    switch (prop) {\n        case 'children':\n        case 'childrenType':\n        case 'className':\n        case 'defaultValue':\n        case 'key':\n        case 'multiple':\n        case 'ref':\n        case 'selectedIndex':\n            break;\n        case 'autoFocus':\n            dom.autofocus = !!nextValue;\n            break;\n        case 'allowfullscreen':\n        case 'autoplay':\n        case 'capture':\n        case 'checked':\n        case 'controls':\n        case 'default':\n        case 'disabled':\n        case 'hidden':\n        case 'indeterminate':\n        case 'loop':\n        case 'muted':\n        case 'novalidate':\n        case 'open':\n        case 'readOnly':\n        case 'required':\n        case 'reversed':\n        case 'scoped':\n        case 'seamless':\n        case 'selected':\n            dom[prop] = !!nextValue;\n            break;\n        case 'defaultChecked':\n        case 'value':\n        case 'volume':\n            if (hasControlledValue && prop === 'value') {\n                break;\n            }\n            var value = isNullOrUndef(nextValue) ? '' : nextValue;\n            if (dom[prop] !== value) {\n                dom[prop] = value;\n            }\n            break;\n        case 'style':\n            patchStyle(lastValue, nextValue, dom);\n            break;\n        case 'dangerouslySetInnerHTML':\n            patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom);\n            break;\n        default:\n            if (syntheticEvents[prop]) {\n                handleSyntheticEvent(prop, lastValue, nextValue, dom);\n            }\n            else if (prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110) {\n                patchEvent(prop, lastValue, nextValue, dom);\n            }\n            else if (isNullOrUndef(nextValue)) {\n                dom.removeAttribute(prop);\n            }\n            else if (isSVG && namespaces[prop]) {\n                // We optimize for isSVG being false\n                // If we end up in this path we can read property again\n                dom.setAttributeNS(namespaces[prop], prop, nextValue);\n            }\n            else {\n                dom.setAttribute(prop, nextValue);\n            }\n            break;\n    }\n}\nfunction mountProps(vNode, flags, props, dom, isSVG) {\n    var hasControlledValue = false;\n    var isFormElement = (flags & 448 /* FormElement */) > 0;\n    if (isFormElement) {\n        hasControlledValue = isControlledFormElement(props);\n        if (hasControlledValue) {\n            addFormElementEventHandlers(flags, dom, props);\n        }\n    }\n    for (var prop in props) {\n        // do not add a hasOwnProperty check here, it affects performance\n        patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue, null);\n    }\n    if (isFormElement) {\n        processElement(flags, vNode, dom, props, true, hasControlledValue);\n    }\n}\n\nfunction renderNewInput(instance, props, context) {\n    var nextInput = normalizeRoot(instance.render(props, instance.state, context));\n    var childContext = context;\n    if (isFunction(instance.getChildContext)) {\n        childContext = combineFrom(context, instance.getChildContext());\n    }\n    instance.$CX = childContext;\n    return nextInput;\n}\nfunction createClassComponentInstance(vNode, Component, props, context, isSVG, lifecycle) {\n    var instance = new Component(props, context);\n    var usesNewAPI = (instance.$N = Boolean(Component.getDerivedStateFromProps || instance.getSnapshotBeforeUpdate));\n    instance.$SVG = isSVG;\n    instance.$L = lifecycle;\n    vNode.children = instance;\n    instance.$BS = false;\n    instance.context = context;\n    if (instance.props === EMPTY_OBJ) {\n        instance.props = props;\n    }\n    if (!usesNewAPI) {\n        if (isFunction(instance.componentWillMount)) {\n            instance.$BR = true;\n            instance.componentWillMount();\n            var pending = instance.$PS;\n            if (!isNull(pending)) {\n                var state = instance.state;\n                if (isNull(state)) {\n                    instance.state = pending;\n                }\n                else {\n                    for (var key in pending) {\n                        state[key] = pending[key];\n                    }\n                }\n                instance.$PS = null;\n            }\n            instance.$BR = false;\n        }\n    }\n    else {\n        instance.state = createDerivedState(instance, props, instance.state);\n    }\n    instance.$LI = renderNewInput(instance, props, context);\n    return instance;\n}\nfunction renderFunctionalComponent(vNode, context) {\n    var props = vNode.props || EMPTY_OBJ;\n    return vNode.flags & 32768 /* ForwardRef */ ? vNode.type.render(props, vNode.ref, context) : vNode.type(props, context);\n}\n\nfunction mount(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var flags = (vNode.flags |= 16384 /* InUse */);\n    if (flags & 481 /* Element */) {\n        mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (flags & 4 /* ComponentClass */) {\n        mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (flags & 8 /* ComponentFunction */) {\n        mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n        mountFunctionalComponentCallbacks(vNode, lifecycle);\n    }\n    else if (flags & 512 /* Void */ || flags & 16 /* Text */) {\n        mountText(vNode, parentDOM, nextNode);\n    }\n    else if (flags & 8192 /* Fragment */) {\n        mountFragment(vNode, context, parentDOM, isSVG, nextNode, lifecycle);\n    }\n    else if (flags & 1024 /* Portal */) {\n        mountPortal(vNode, context, parentDOM, nextNode, lifecycle);\n    }\n    else ;\n}\nfunction mountPortal(vNode, context, parentDOM, nextNode, lifecycle) {\n    mount(vNode.children, vNode.ref, context, false, null, lifecycle);\n    var placeHolderVNode = createVoidVNode();\n    mountText(placeHolderVNode, parentDOM, nextNode);\n    vNode.dom = placeHolderVNode.dom;\n}\nfunction mountFragment(vNode, context, parentDOM, isSVG, nextNode, lifecycle) {\n    var children = vNode.children;\n    var childFlags = vNode.childFlags;\n    // When fragment is optimized for multiple children, check if there is no children and change flag to invalid\n    // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements\n    if (childFlags & 12 /* MultipleChildren */ && children.length === 0) {\n        childFlags = vNode.childFlags = 2 /* HasVNodeChildren */;\n        children = vNode.children = createVoidVNode();\n    }\n    if (childFlags === 2 /* HasVNodeChildren */) {\n        mount(children, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else {\n        mountArrayChildren(children, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n}\nfunction mountText(vNode, parentDOM, nextNode) {\n    var dom = (vNode.dom = document.createTextNode(vNode.children));\n    if (!isNull(parentDOM)) {\n        insertOrAppend(parentDOM, dom, nextNode);\n    }\n}\nfunction mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var flags = vNode.flags;\n    var props = vNode.props;\n    var className = vNode.className;\n    var childFlags = vNode.childFlags;\n    var dom = (vNode.dom = documentCreateElement(vNode.type, (isSVG = isSVG || (flags & 32 /* SvgElement */) > 0)));\n    var children = vNode.children;\n    if (!isNullOrUndef(className) && className !== '') {\n        if (isSVG) {\n            dom.setAttribute('class', className);\n        }\n        else {\n            dom.className = className;\n        }\n    }\n    if (childFlags === 16 /* HasTextChildren */) {\n        setTextContent(dom, children);\n    }\n    else if (childFlags !== 1 /* HasInvalidChildren */) {\n        var childrenIsSVG = isSVG && vNode.type !== 'foreignObject';\n        if (childFlags === 2 /* HasVNodeChildren */) {\n            if (children.flags & 16384 /* InUse */) {\n                vNode.children = children = directClone(children);\n            }\n            mount(children, dom, context, childrenIsSVG, null, lifecycle);\n        }\n        else if (childFlags === 8 /* HasKeyedChildren */ || childFlags === 4 /* HasNonKeyedChildren */) {\n            mountArrayChildren(children, dom, context, childrenIsSVG, null, lifecycle);\n        }\n    }\n    if (!isNull(parentDOM)) {\n        insertOrAppend(parentDOM, dom, nextNode);\n    }\n    if (!isNull(props)) {\n        mountProps(vNode, flags, props, dom, isSVG);\n    }\n    mountRef(vNode.ref, dom, lifecycle);\n}\nfunction mountArrayChildren(children, dom, context, isSVG, nextNode, lifecycle) {\n    for (var i = 0; i < children.length; ++i) {\n        var child = children[i];\n        if (child.flags & 16384 /* InUse */) {\n            children[i] = child = directClone(child);\n        }\n        mount(child, dom, context, isSVG, nextNode, lifecycle);\n    }\n}\nfunction mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var instance = createClassComponentInstance(vNode, vNode.type, vNode.props || EMPTY_OBJ, context, isSVG, lifecycle);\n    mount(instance.$LI, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);\n    mountClassComponentCallbacks(vNode.ref, instance, lifecycle);\n}\nfunction mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    mount((vNode.children = normalizeRoot(renderFunctionalComponent(vNode, context))), parentDOM, context, isSVG, nextNode, lifecycle);\n}\nfunction createClassMountCallback(instance) {\n    return function () {\n        instance.componentDidMount();\n    };\n}\nfunction mountClassComponentCallbacks(ref, instance, lifecycle) {\n    mountRef(ref, instance, lifecycle);\n    if (isFunction(instance.componentDidMount)) {\n        lifecycle.push(createClassMountCallback(instance));\n    }\n}\nfunction createOnMountCallback(ref, vNode) {\n    return function () {\n        ref.onComponentDidMount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);\n    };\n}\nfunction mountFunctionalComponentCallbacks(vNode, lifecycle) {\n    var ref = vNode.ref;\n    if (!isNullOrUndef(ref)) {\n        safeCall1(ref.onComponentWillMount, vNode.props || EMPTY_OBJ);\n        if (isFunction(ref.onComponentDidMount)) {\n            lifecycle.push(createOnMountCallback(ref, vNode));\n        }\n    }\n}\n\nfunction replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {\n    unmount(lastVNode);\n    if ((nextVNode.flags & lastVNode.flags & 2033 /* DOMRef */) !== 0) {\n        mount(nextVNode, null, context, isSVG, null, lifecycle);\n        // Single DOM operation, when we have dom references available\n        replaceChild(parentDOM, nextVNode.dom, lastVNode.dom);\n    }\n    else {\n        mount(nextVNode, parentDOM, context, isSVG, findDOMfromVNode(lastVNode, true), lifecycle);\n        removeVNodeDOM(lastVNode, parentDOM);\n    }\n}\nfunction patch(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var nextFlags = (nextVNode.flags |= 16384 /* InUse */);\n    if (lastVNode.flags !== nextFlags || lastVNode.type !== nextVNode.type || lastVNode.key !== nextVNode.key || nextFlags & 2048 /* ReCreate */) {\n        if (lastVNode.flags & 16384 /* InUse */) {\n            replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);\n        }\n        else {\n            // Last vNode is not in use, it has crashed at application level. Just mount nextVNode and ignore last one\n            mount(nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n        }\n    }\n    else if (nextFlags & 481 /* Element */) {\n        patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle);\n    }\n    else if (nextFlags & 4 /* ComponentClass */) {\n        patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (nextFlags & 8 /* ComponentFunction */) {\n        patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (nextFlags & 16 /* Text */) {\n        patchText(lastVNode, nextVNode);\n    }\n    else if (nextFlags & 512 /* Void */) {\n        nextVNode.dom = lastVNode.dom;\n    }\n    else if (nextFlags & 8192 /* Fragment */) {\n        patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);\n    }\n    else {\n        patchPortal(lastVNode, nextVNode, context, lifecycle);\n    }\n}\nfunction patchSingleTextChild(lastChildren, nextChildren, parentDOM) {\n    if (lastChildren !== nextChildren) {\n        if (lastChildren !== '') {\n            parentDOM.firstChild.nodeValue = nextChildren;\n        }\n        else {\n            setTextContent(parentDOM, nextChildren);\n        }\n    }\n}\nfunction patchContentEditableChildren(dom, nextChildren) {\n    if (dom.textContent !== nextChildren) {\n        dom.textContent = nextChildren;\n    }\n}\nfunction patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {\n    var lastChildren = lastVNode.children;\n    var nextChildren = nextVNode.children;\n    var lastChildFlags = lastVNode.childFlags;\n    var nextChildFlags = nextVNode.childFlags;\n    var nextNode = null;\n    // When fragment is optimized for multiple children, check if there is no children and change flag to invalid\n    // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements\n    if (nextChildFlags & 12 /* MultipleChildren */ && nextChildren.length === 0) {\n        nextChildFlags = nextVNode.childFlags = 2 /* HasVNodeChildren */;\n        nextChildren = nextVNode.children = createVoidVNode();\n    }\n    var nextIsSingle = (nextChildFlags & 2 /* HasVNodeChildren */) !== 0;\n    if (lastChildFlags & 12 /* MultipleChildren */) {\n        var lastLen = lastChildren.length;\n        // We need to know Fragment's edge node when\n        if (\n        // It uses keyed algorithm\n        (lastChildFlags & 8 /* HasKeyedChildren */ && nextChildFlags & 8 /* HasKeyedChildren */) ||\n            // It transforms from many to single\n            nextIsSingle ||\n            // It will append more nodes\n            (!nextIsSingle && nextChildren.length > lastLen)) {\n            // When fragment has multiple children there is always at least one vNode\n            nextNode = findDOMfromVNode(lastChildren[lastLen - 1], false).nextSibling;\n        }\n    }\n    patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lastVNode, lifecycle);\n}\nfunction patchPortal(lastVNode, nextVNode, context, lifecycle) {\n    var lastContainer = lastVNode.ref;\n    var nextContainer = nextVNode.ref;\n    var nextChildren = nextVNode.children;\n    patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, lastContainer, context, false, null, lastVNode, lifecycle);\n    nextVNode.dom = lastVNode.dom;\n    if (lastContainer !== nextContainer && !isInvalid(nextChildren)) {\n        var node = nextChildren.dom;\n        removeChild(lastContainer, node);\n        appendChild(nextContainer, node);\n    }\n}\nfunction patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle) {\n    var dom = (nextVNode.dom = lastVNode.dom);\n    var lastProps = lastVNode.props;\n    var nextProps = nextVNode.props;\n    var isFormElement = false;\n    var hasControlledValue = false;\n    var nextPropsOrEmpty;\n    isSVG = isSVG || (nextFlags & 32 /* SvgElement */) > 0;\n    // inlined patchProps  -- starts --\n    if (lastProps !== nextProps) {\n        var lastPropsOrEmpty = lastProps || EMPTY_OBJ;\n        nextPropsOrEmpty = nextProps || EMPTY_OBJ;\n        if (nextPropsOrEmpty !== EMPTY_OBJ) {\n            isFormElement = (nextFlags & 448 /* FormElement */) > 0;\n            if (isFormElement) {\n                hasControlledValue = isControlledFormElement(nextPropsOrEmpty);\n            }\n            for (var prop in nextPropsOrEmpty) {\n                var lastValue = lastPropsOrEmpty[prop];\n                var nextValue = nextPropsOrEmpty[prop];\n                if (lastValue !== nextValue) {\n                    patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode);\n                }\n            }\n        }\n        if (lastPropsOrEmpty !== EMPTY_OBJ) {\n            for (var prop$1 in lastPropsOrEmpty) {\n                if (isNullOrUndef(nextPropsOrEmpty[prop$1]) && !isNullOrUndef(lastPropsOrEmpty[prop$1])) {\n                    patchProp(prop$1, lastPropsOrEmpty[prop$1], null, dom, isSVG, hasControlledValue, lastVNode);\n                }\n            }\n        }\n    }\n    var nextChildren = nextVNode.children;\n    var nextClassName = nextVNode.className;\n    // inlined patchProps  -- ends --\n    if (lastVNode.className !== nextClassName) {\n        if (isNullOrUndef(nextClassName)) {\n            dom.removeAttribute('class');\n        }\n        else if (isSVG) {\n            dom.setAttribute('class', nextClassName);\n        }\n        else {\n            dom.className = nextClassName;\n        }\n    }\n    if (nextFlags & 4096 /* ContentEditable */) {\n        patchContentEditableChildren(dom, nextChildren);\n    }\n    else {\n        patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, dom, context, isSVG && nextVNode.type !== 'foreignObject', null, lastVNode, lifecycle);\n    }\n    if (isFormElement) {\n        processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, false, hasControlledValue);\n    }\n    var nextRef = nextVNode.ref;\n    var lastRef = lastVNode.ref;\n    if (lastRef !== nextRef) {\n        unmountRef(lastRef);\n        mountRef(nextRef, dom, lifecycle);\n    }\n}\nfunction replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle) {\n    unmount(lastChildren);\n    mountArrayChildren(nextChildren, parentDOM, context, isSVG, findDOMfromVNode(lastChildren, true), lifecycle);\n    removeVNodeDOM(lastChildren, parentDOM);\n}\nfunction patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, parentVNode, lifecycle) {\n    switch (lastChildFlags) {\n        case 2 /* HasVNodeChildren */:\n            switch (nextChildFlags) {\n                case 2 /* HasVNodeChildren */:\n                    patch(lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    remove(lastChildren, parentDOM);\n                    break;\n                case 16 /* HasTextChildren */:\n                    unmount(lastChildren);\n                    setTextContent(parentDOM, nextChildren);\n                    break;\n                default:\n                    replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle);\n                    break;\n            }\n            break;\n        case 1 /* HasInvalidChildren */:\n            switch (nextChildFlags) {\n                case 2 /* HasVNodeChildren */:\n                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    break;\n                case 16 /* HasTextChildren */:\n                    setTextContent(parentDOM, nextChildren);\n                    break;\n                default:\n                    mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n            }\n            break;\n        case 16 /* HasTextChildren */:\n            switch (nextChildFlags) {\n                case 16 /* HasTextChildren */:\n                    patchSingleTextChild(lastChildren, nextChildren, parentDOM);\n                    break;\n                case 2 /* HasVNodeChildren */:\n                    clearDOM(parentDOM);\n                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    clearDOM(parentDOM);\n                    break;\n                default:\n                    clearDOM(parentDOM);\n                    mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n            }\n            break;\n        default:\n            switch (nextChildFlags) {\n                case 16 /* HasTextChildren */:\n                    unmountAllChildren(lastChildren);\n                    setTextContent(parentDOM, nextChildren);\n                    break;\n                case 2 /* HasVNodeChildren */:\n                    removeAllChildren(parentDOM, parentVNode, lastChildren);\n                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    removeAllChildren(parentDOM, parentVNode, lastChildren);\n                    break;\n                default:\n                    var lastLength = lastChildren.length | 0;\n                    var nextLength = nextChildren.length | 0;\n                    // Fast path's for both algorithms\n                    if (lastLength === 0) {\n                        if (nextLength > 0) {\n                            mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                        }\n                    }\n                    else if (nextLength === 0) {\n                        removeAllChildren(parentDOM, parentVNode, lastChildren);\n                    }\n                    else if (nextChildFlags === 8 /* HasKeyedChildren */ && lastChildFlags === 8 /* HasKeyedChildren */) {\n                        patchKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, parentVNode, lifecycle);\n                    }\n                    else {\n                        patchNonKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, lifecycle);\n                    }\n                    break;\n            }\n            break;\n    }\n}\nfunction createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle) {\n    lifecycle.push(function () {\n        instance.componentDidUpdate(lastProps, lastState, snapshot);\n    });\n}\nfunction updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, force, nextNode, lifecycle) {\n    var lastState = instance.state;\n    var lastProps = instance.props;\n    var usesNewAPI = Boolean(instance.$N);\n    var hasSCU = isFunction(instance.shouldComponentUpdate);\n    if (usesNewAPI) {\n        nextState = createDerivedState(instance, nextProps, nextState !== lastState ? combineFrom(lastState, nextState) : nextState);\n    }\n    if (force || !hasSCU || (hasSCU && instance.shouldComponentUpdate(nextProps, nextState, context))) {\n        if (!usesNewAPI && isFunction(instance.componentWillUpdate)) {\n            instance.componentWillUpdate(nextProps, nextState, context);\n        }\n        instance.props = nextProps;\n        instance.state = nextState;\n        instance.context = context;\n        var snapshot = null;\n        var nextInput = renderNewInput(instance, nextProps, context);\n        if (usesNewAPI && isFunction(instance.getSnapshotBeforeUpdate)) {\n            snapshot = instance.getSnapshotBeforeUpdate(lastProps, lastState);\n        }\n        patch(instance.$LI, nextInput, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);\n        // Dont update Last input, until patch has been succesfully executed\n        instance.$LI = nextInput;\n        if (isFunction(instance.componentDidUpdate)) {\n            createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle);\n        }\n    }\n    else {\n        instance.props = nextProps;\n        instance.state = nextState;\n        instance.context = context;\n    }\n}\nfunction patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var instance = (nextVNode.children = lastVNode.children);\n    // If Component has crashed, ignore it to stay functional\n    if (isNull(instance)) {\n        return;\n    }\n    instance.$L = lifecycle;\n    var nextProps = nextVNode.props || EMPTY_OBJ;\n    var nextRef = nextVNode.ref;\n    var lastRef = lastVNode.ref;\n    var nextState = instance.state;\n    if (!instance.$N) {\n        if (isFunction(instance.componentWillReceiveProps)) {\n            instance.$BR = true;\n            instance.componentWillReceiveProps(nextProps, context);\n            // If instance component was removed during its own update do nothing.\n            if (instance.$UN) {\n                return;\n            }\n            instance.$BR = false;\n        }\n        if (!isNull(instance.$PS)) {\n            nextState = combineFrom(nextState, instance.$PS);\n            instance.$PS = null;\n        }\n    }\n    updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, false, nextNode, lifecycle);\n    if (lastRef !== nextRef) {\n        unmountRef(lastRef);\n        mountRef(nextRef, instance, lifecycle);\n    }\n}\nfunction patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var shouldUpdate = true;\n    var nextProps = nextVNode.props || EMPTY_OBJ;\n    var nextRef = nextVNode.ref;\n    var lastProps = lastVNode.props;\n    var nextHooksDefined = !isNullOrUndef(nextRef);\n    var lastInput = lastVNode.children;\n    if (nextHooksDefined && isFunction(nextRef.onComponentShouldUpdate)) {\n        shouldUpdate = nextRef.onComponentShouldUpdate(lastProps, nextProps);\n    }\n    if (shouldUpdate !== false) {\n        if (nextHooksDefined && isFunction(nextRef.onComponentWillUpdate)) {\n            nextRef.onComponentWillUpdate(lastProps, nextProps);\n        }\n        var nextInput = normalizeRoot(renderFunctionalComponent(nextVNode, context));\n        patch(lastInput, nextInput, parentDOM, context, isSVG, nextNode, lifecycle);\n        nextVNode.children = nextInput;\n        if (nextHooksDefined && isFunction(nextRef.onComponentDidUpdate)) {\n            nextRef.onComponentDidUpdate(lastProps, nextProps);\n        }\n    }\n    else {\n        nextVNode.children = lastInput;\n    }\n}\nfunction patchText(lastVNode, nextVNode) {\n    var nextText = nextVNode.children;\n    var dom = (nextVNode.dom = lastVNode.dom);\n    if (nextText !== lastVNode.children) {\n        dom.nodeValue = nextText;\n    }\n}\nfunction patchNonKeyedChildren(lastChildren, nextChildren, dom, context, isSVG, lastChildrenLength, nextChildrenLength, nextNode, lifecycle) {\n    var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;\n    var i = 0;\n    var nextChild;\n    var lastChild;\n    for (; i < commonLength; ++i) {\n        nextChild = nextChildren[i];\n        lastChild = lastChildren[i];\n        if (nextChild.flags & 16384 /* InUse */) {\n            nextChild = nextChildren[i] = directClone(nextChild);\n        }\n        patch(lastChild, nextChild, dom, context, isSVG, nextNode, lifecycle);\n        lastChildren[i] = nextChild;\n    }\n    if (lastChildrenLength < nextChildrenLength) {\n        for (i = commonLength; i < nextChildrenLength; ++i) {\n            nextChild = nextChildren[i];\n            if (nextChild.flags & 16384 /* InUse */) {\n                nextChild = nextChildren[i] = directClone(nextChild);\n            }\n            mount(nextChild, dom, context, isSVG, nextNode, lifecycle);\n        }\n    }\n    else if (lastChildrenLength > nextChildrenLength) {\n        for (i = commonLength; i < lastChildrenLength; ++i) {\n            remove(lastChildren[i], dom);\n        }\n    }\n}\nfunction patchKeyedChildren(a, b, dom, context, isSVG, aLength, bLength, outerEdge, parentVNode, lifecycle) {\n    var aEnd = aLength - 1;\n    var bEnd = bLength - 1;\n    var j = 0;\n    var aNode = a[j];\n    var bNode = b[j];\n    var nextPos;\n    var nextNode;\n    // Step 1\n    // tslint:disable-next-line\n    outer: {\n        // Sync nodes with the same key at the beginning.\n        while (aNode.key === bNode.key) {\n            if (bNode.flags & 16384 /* InUse */) {\n                b[j] = bNode = directClone(bNode);\n            }\n            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n            a[j] = bNode;\n            ++j;\n            if (j > aEnd || j > bEnd) {\n                break outer;\n            }\n            aNode = a[j];\n            bNode = b[j];\n        }\n        aNode = a[aEnd];\n        bNode = b[bEnd];\n        // Sync nodes with the same key at the end.\n        while (aNode.key === bNode.key) {\n            if (bNode.flags & 16384 /* InUse */) {\n                b[bEnd] = bNode = directClone(bNode);\n            }\n            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n            a[aEnd] = bNode;\n            aEnd--;\n            bEnd--;\n            if (j > aEnd || j > bEnd) {\n                break outer;\n            }\n            aNode = a[aEnd];\n            bNode = b[bEnd];\n        }\n    }\n    if (j > aEnd) {\n        if (j <= bEnd) {\n            nextPos = bEnd + 1;\n            nextNode = nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge;\n            while (j <= bEnd) {\n                bNode = b[j];\n                if (bNode.flags & 16384 /* InUse */) {\n                    b[j] = bNode = directClone(bNode);\n                }\n                ++j;\n                mount(bNode, dom, context, isSVG, nextNode, lifecycle);\n            }\n        }\n    }\n    else if (j > bEnd) {\n        while (j <= aEnd) {\n            remove(a[j++], dom);\n        }\n    }\n    else {\n        patchKeyedChildrenComplex(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle);\n    }\n}\nfunction patchKeyedChildrenComplex(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle) {\n    var aNode;\n    var bNode;\n    var nextPos;\n    var i = 0;\n    var aStart = j;\n    var bStart = j;\n    var aLeft = aEnd - j + 1;\n    var bLeft = bEnd - j + 1;\n    var sources = new Int32Array(bLeft + 1);\n    // Keep track if its possible to remove whole DOM using textContent = '';\n    var canRemoveWholeContent = aLeft === aLength;\n    var moved = false;\n    var pos = 0;\n    var patched = 0;\n    // When sizes are small, just loop them through\n    if (bLength < 4 || (aLeft | bLeft) < 32) {\n        for (i = aStart; i <= aEnd; ++i) {\n            aNode = a[i];\n            if (patched < bLeft) {\n                for (j = bStart; j <= bEnd; j++) {\n                    bNode = b[j];\n                    if (aNode.key === bNode.key) {\n                        sources[j - bStart] = i + 1;\n                        if (canRemoveWholeContent) {\n                            canRemoveWholeContent = false;\n                            while (aStart < i) {\n                                remove(a[aStart++], dom);\n                            }\n                        }\n                        if (pos > j) {\n                            moved = true;\n                        }\n                        else {\n                            pos = j;\n                        }\n                        if (bNode.flags & 16384 /* InUse */) {\n                            b[j] = bNode = directClone(bNode);\n                        }\n                        patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n                        ++patched;\n                        break;\n                    }\n                }\n                if (!canRemoveWholeContent && j > bEnd) {\n                    remove(aNode, dom);\n                }\n            }\n            else if (!canRemoveWholeContent) {\n                remove(aNode, dom);\n            }\n        }\n    }\n    else {\n        var keyIndex = {};\n        // Map keys by their index\n        for (i = bStart; i <= bEnd; ++i) {\n            keyIndex[b[i].key] = i;\n        }\n        // Try to patch same keys\n        for (i = aStart; i <= aEnd; ++i) {\n            aNode = a[i];\n            if (patched < bLeft) {\n                j = keyIndex[aNode.key];\n                if (j !== void 0) {\n                    if (canRemoveWholeContent) {\n                        canRemoveWholeContent = false;\n                        while (i > aStart) {\n                            remove(a[aStart++], dom);\n                        }\n                    }\n                    sources[j - bStart] = i + 1;\n                    if (pos > j) {\n                        moved = true;\n                    }\n                    else {\n                        pos = j;\n                    }\n                    bNode = b[j];\n                    if (bNode.flags & 16384 /* InUse */) {\n                        b[j] = bNode = directClone(bNode);\n                    }\n                    patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n                    ++patched;\n                }\n                else if (!canRemoveWholeContent) {\n                    remove(aNode, dom);\n                }\n            }\n            else if (!canRemoveWholeContent) {\n                remove(aNode, dom);\n            }\n        }\n    }\n    // fast-path: if nothing patched remove all old and add all new\n    if (canRemoveWholeContent) {\n        removeAllChildren(dom, parentVNode, a);\n        mountArrayChildren(b, dom, context, isSVG, outerEdge, lifecycle);\n    }\n    else if (moved) {\n        var seq = lis_algorithm(sources);\n        j = seq.length - 1;\n        for (i = bLeft - 1; i >= 0; i--) {\n            if (sources[i] === 0) {\n                pos = i + bStart;\n                bNode = b[pos];\n                if (bNode.flags & 16384 /* InUse */) {\n                    b[pos] = bNode = directClone(bNode);\n                }\n                nextPos = pos + 1;\n                mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);\n            }\n            else if (j < 0 || i !== seq[j]) {\n                pos = i + bStart;\n                bNode = b[pos];\n                nextPos = pos + 1;\n                moveVNodeDOM(bNode, dom, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge);\n            }\n            else {\n                j--;\n            }\n        }\n    }\n    else if (patched !== bLeft) {\n        // when patched count doesn't match b length we need to insert those new ones\n        // loop backwards so we can use insertBefore\n        for (i = bLeft - 1; i >= 0; i--) {\n            if (sources[i] === 0) {\n                pos = i + bStart;\n                bNode = b[pos];\n                if (bNode.flags & 16384 /* InUse */) {\n                    b[pos] = bNode = directClone(bNode);\n                }\n                nextPos = pos + 1;\n                mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);\n            }\n        }\n    }\n}\nvar result;\nvar p;\nvar maxLen = 0;\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\nfunction lis_algorithm(arr) {\n    var arrI = 0;\n    var i = 0;\n    var j = 0;\n    var k = 0;\n    var u = 0;\n    var v = 0;\n    var c = 0;\n    var len = arr.length;\n    if (len > maxLen) {\n        maxLen = len;\n        result = new Int32Array(len);\n        p = new Int32Array(len);\n    }\n    for (; i < len; ++i) {\n        arrI = arr[i];\n        if (arrI !== 0) {\n            j = result[k];\n            if (arr[j] < arrI) {\n                p[i] = j;\n                result[++k] = i;\n                continue;\n            }\n            u = 0;\n            v = k;\n            while (u < v) {\n                c = (u + v) >> 1;\n                if (arr[result[c]] < arrI) {\n                    u = c + 1;\n                }\n                else {\n                    v = c;\n                }\n            }\n            if (arrI < arr[result[u]]) {\n                if (u > 0) {\n                    p[i] = result[u - 1];\n                }\n                result[u] = i;\n            }\n        }\n    }\n    u = k + 1;\n    var seq = new Int32Array(u);\n    v = result[u - 1];\n    while (u-- > 0) {\n        seq[u] = v;\n        v = p[v];\n        result[u] = 0;\n    }\n    return seq;\n}\n\nvar hasDocumentAvailable = typeof document !== 'undefined';\nif (hasDocumentAvailable) {\n    /*\n     * Defining $EV and $V properties on Node.prototype\n     * fixes v8 \"wrong map\" de-optimization\n     */\n    if (window.Node) {\n        Node.prototype.$EV = null;\n        Node.prototype.$V = null;\n    }\n}\nfunction __render(input, parentDOM, callback, context) {\n    var lifecycle = [];\n    var rootInput = parentDOM.$V;\n    renderCheck.v = true;\n    if (isNullOrUndef(rootInput)) {\n        if (!isNullOrUndef(input)) {\n            if (input.flags & 16384 /* InUse */) {\n                input = directClone(input);\n            }\n            mount(input, parentDOM, context, false, null, lifecycle);\n            parentDOM.$V = input;\n            rootInput = input;\n        }\n    }\n    else {\n        if (isNullOrUndef(input)) {\n            remove(rootInput, parentDOM);\n            parentDOM.$V = null;\n        }\n        else {\n            if (input.flags & 16384 /* InUse */) {\n                input = directClone(input);\n            }\n            patch(rootInput, input, parentDOM, context, false, null, lifecycle);\n            rootInput = parentDOM.$V = input;\n        }\n    }\n    callAll(lifecycle);\n    renderCheck.v = false;\n    if (isFunction(callback)) {\n        callback();\n    }\n    if (isFunction(options.renderComplete)) {\n        options.renderComplete(rootInput, parentDOM);\n    }\n}\nfunction render(input, parentDOM, callback, context) {\n    if ( callback === void 0 ) callback = null;\n    if ( context === void 0 ) context = EMPTY_OBJ;\n\n    __render(input, parentDOM, callback, context);\n}\nfunction createRenderer(parentDOM) {\n    return function renderer(lastInput, nextInput, callback, context) {\n        if (!parentDOM) {\n            parentDOM = lastInput;\n        }\n        render(nextInput, parentDOM, callback, context);\n    };\n}\n\nvar QUEUE = [];\nvar nextTick = typeof Promise !== 'undefined'\n    ? Promise.resolve().then.bind(Promise.resolve())\n    : function (a) {\n        window.setTimeout(a, 0);\n    };\nvar microTaskPending = false;\nfunction queueStateChanges(component, newState, callback, force) {\n    var pending = component.$PS;\n    if (isFunction(newState)) {\n        newState = newState(pending ? combineFrom(component.state, pending) : component.state, component.props, component.context);\n    }\n    if (isNullOrUndef(pending)) {\n        component.$PS = newState;\n    }\n    else {\n        for (var stateKey in newState) {\n            pending[stateKey] = newState[stateKey];\n        }\n    }\n    if (!component.$BR) {\n        if (!renderCheck.v) {\n            if (QUEUE.length === 0) {\n                applyState(component, force);\n                if (isFunction(callback)) {\n                    callback.call(component);\n                }\n                return;\n            }\n        }\n        if (QUEUE.indexOf(component) === -1) {\n            QUEUE.push(component);\n        }\n        if (force) {\n            component.$F = true;\n        }\n        if (!microTaskPending) {\n            microTaskPending = true;\n            nextTick(rerender);\n        }\n        if (isFunction(callback)) {\n            var QU = component.$QU;\n            if (!QU) {\n                QU = component.$QU = [];\n            }\n            QU.push(callback);\n        }\n    }\n    else if (isFunction(callback)) {\n        component.$L.push(callback.bind(component));\n    }\n}\nfunction callSetStateCallbacks(component) {\n    var queue = component.$QU;\n    for (var i = 0; i < queue.length; ++i) {\n        queue[i].call(component);\n    }\n    component.$QU = null;\n}\nfunction rerender() {\n    var component;\n    microTaskPending = false;\n    while ((component = QUEUE.shift())) {\n        if (!component.$UN) {\n            var force = component.$F;\n            component.$F = false;\n            applyState(component, force);\n            if (component.$QU) {\n                callSetStateCallbacks(component);\n            }\n        }\n    }\n}\nfunction applyState(component, force) {\n    if (force || !component.$BR) {\n        var pendingState = component.$PS;\n        component.$PS = null;\n        var lifecycle = [];\n        renderCheck.v = true;\n        updateClassComponent(component, combineFrom(component.state, pendingState), component.props, findDOMfromVNode(component.$LI, true).parentNode, component.context, component.$SVG, force, null, lifecycle);\n        callAll(lifecycle);\n        renderCheck.v = false;\n    }\n    else {\n        component.state = component.$PS;\n        component.$PS = null;\n    }\n}\nvar Component = function Component(props, context) {\n    // Public\n    this.state = null;\n    // Internal properties\n    this.$BR = false; // BLOCK RENDER\n    this.$BS = true; // BLOCK STATE\n    this.$PS = null; // PENDING STATE (PARTIAL or FULL)\n    this.$LI = null; // LAST INPUT\n    this.$UN = false; // UNMOUNTED\n    this.$CX = null; // CHILDCONTEXT\n    this.$QU = null; // QUEUE\n    this.$N = false; // Uses new lifecycle API Flag\n    this.$L = null; // Current lifecycle of this component\n    this.$SVG = false; // Flag to keep track if component is inside SVG tree\n    this.$F = false; // Force update flag\n    this.props = props || EMPTY_OBJ;\n    this.context = context || EMPTY_OBJ; // context should not be mutable\n};\nComponent.prototype.forceUpdate = function forceUpdate (callback) {\n    if (this.$UN) {\n        return;\n    }\n    // Do not allow double render during force update\n    queueStateChanges(this, {}, callback, true);\n};\nComponent.prototype.setState = function setState (newState, callback) {\n    if (this.$UN) {\n        return;\n    }\n    if (!this.$BS) {\n        queueStateChanges(this, newState, callback, false);\n    }\n};\nComponent.prototype.render = function render (_nextProps, _nextState, _nextContext) {\n    return null;\n};\n\nvar version = \"7.4.11\";\n\nexport { Component, EMPTY_OBJ, Fragment, createClassComponentInstance as _CI, normalizeRoot as _HI, mount as _M, mountClassComponentCallbacks as _MCCC, mountElement as _ME, mountFunctionalComponentCallbacks as _MFCC, mountProps as _MP, mountRef as _MR, renderFunctionalComponent as _RFC, __render, createComponentVNode, createFragment, createPortal, createRef, createRenderer, createTextVNode, createVNode, directClone, findDOMfromVNode, forwardRef, getFlagsForElementVnode, linkEvent, normalizeProps, options, render, rerender, version };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}