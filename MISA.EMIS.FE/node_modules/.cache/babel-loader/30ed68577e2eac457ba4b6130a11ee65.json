{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/components/data_validator.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { isDefined as _isDefined, isFunction as _isFunction, isString as _isString, isDate as _isDate, isNumeric as _isNumber, isObject as _isObject } from \"../../core/utils/type\";\nvar STRING = \"string\";\nvar NUMERIC = \"numeric\";\nvar DATETIME = \"datetime\";\nvar DISCRETE = \"discrete\";\nvar SEMIDISCRETE = \"semidiscrete\";\nvar CONTINUOUS = \"continuous\";\nvar LOGARITHMIC = \"logarithmic\";\nvar VALUE_TYPE = \"valueType\";\nvar ARGUMENT_TYPE = \"argumentType\";\nimport { extend } from \"../../core/utils/extend\";\nimport { enumParser } from \"../core/utils\";\nvar axisTypeParser = enumParser([STRING, NUMERIC, DATETIME]);\nimport { getParser as _getParser } from \"./parse_utils\";\nvar _isArray = Array.isArray;\n\nfunction groupingValues(data, others, valueField, index) {\n  if (index >= 0) {\n    data.slice(index).forEach(function (cell) {\n      if (_isDefined(cell[valueField])) {\n        others[valueField] += cell[valueField];\n        cell[valueField] = void 0;\n      }\n    });\n  }\n}\n\nfunction processGroups(groups) {\n  groups.forEach(function (group) {\n    group.valueType = group.valueAxisType = null;\n    group.series.forEach(function (series) {\n      series.updateDataType({});\n    });\n    group.valueAxis && group.valueAxis.resetTypes(VALUE_TYPE);\n  });\n}\n\nfunction sortValues(data, asc, selector) {\n  var func = asc ? function (a, b) {\n    return a - b;\n  } : function (a, b) {\n    return b - a;\n  };\n  data.sort(function (a, b) {\n    var valA = selector(a);\n    var valB = selector(b);\n    var aa = _isDefined(valA) ? 1 : 0;\n    var bb = _isDefined(valB) ? 1 : 0;\n    return aa && bb ? func(valA, valB) : func(aa, bb);\n  });\n  return data;\n}\n\nfunction resetArgumentAxes(axes) {\n  axes && axes.forEach(function (axis) {\n    axis.resetTypes(ARGUMENT_TYPE);\n  });\n}\n\nfunction parseCategories(categories, parser) {\n  var newArray = [];\n  categories.forEach(function (category) {\n    var parsedCategory = parser(category);\n    void 0 !== parsedCategory && newArray.push(parsedCategory);\n  });\n  return newArray;\n}\n\nfunction parseAxisCategories(groupsData, parsers) {\n  var argumentCategories = groupsData.argumentOptions && groupsData.argumentOptions.categories;\n  groupsData.groups.forEach(function (valueGroup, i) {\n    var categories = valueGroup.valueOptions && valueGroup.valueOptions.categories;\n\n    if (categories) {\n      valueGroup.valueOptions.categories = parseCategories(categories, parsers[i + 1]);\n    }\n  });\n\n  if (argumentCategories) {\n    groupsData.argumentOptions.categories = parseCategories(argumentCategories, parsers[0]);\n  }\n}\n\nfunction eigen(x) {\n  return x;\n}\n\nfunction getType(unit, type) {\n  var result = type;\n\n  if (type === STRING || _isString(unit)) {\n    result = STRING;\n  } else if (type === DATETIME || _isDate(unit)) {\n    result = DATETIME;\n  } else if (_isNumber(unit)) {\n    result = NUMERIC;\n  }\n\n  return result;\n}\n\nfunction correctAxisType(type, axisType, hasCategories, incidentOccurred) {\n  if (type === STRING && (axisType === CONTINUOUS || axisType === LOGARITHMIC || axisType === SEMIDISCRETE)) {\n    incidentOccurred(\"E2002\");\n  }\n\n  return axisType === LOGARITHMIC ? LOGARITHMIC : hasCategories || axisType === DISCRETE || type === STRING ? DISCRETE : axisType === SEMIDISCRETE ? SEMIDISCRETE : CONTINUOUS;\n}\n\nfunction validUnit(unit, field, incidentOccurred) {\n  if (unit) {\n    incidentOccurred(!_isNumber(unit) && !_isDate(unit) && !_isString(unit) ? \"E2003\" : \"E2004\", [field]);\n  }\n}\n\nfunction createParserUnit(type, axisType, incidentOccurred) {\n  var parser = type ? _getParser(type) : eigen;\n  var filterInfinity = axisType !== DISCRETE ? function (x) {\n    return isFinite(x) || void 0 === x ? x : null;\n  } : eigen;\n  return function (unit, field) {\n    var parseUnit = filterInfinity(parser(unit));\n\n    if (void 0 === parseUnit) {\n      validUnit(unit, field, incidentOccurred);\n    }\n\n    return parseUnit;\n  };\n}\n\nfunction prepareParsers(groupsData, incidentOccurred) {\n  var argumentParser = createParserUnit(groupsData.argumentType, groupsData.argumentAxisType, incidentOccurred);\n  var sizeParser;\n  var valueParser;\n  var categoryParsers = [argumentParser];\n  var cache = {};\n  var list = [];\n  groupsData.groups.forEach(function (group, groupIndex) {\n    group.series.forEach(function (series) {\n      valueParser = createParserUnit(group.valueType, group.valueAxisType, incidentOccurred);\n      sizeParser = createParserUnit(NUMERIC, CONTINUOUS, incidentOccurred);\n      cache[series.getArgumentField()] = argumentParser;\n      series.getValueFields().forEach(function (field) {\n        categoryParsers[groupIndex + 1] = valueParser;\n        cache[field] = valueParser;\n      });\n\n      if (series.getSizeField()) {\n        cache[series.getSizeField()] = sizeParser;\n      }\n    });\n  });\n\n  for (var field in cache) {\n    list.push([field, cache[field]]);\n  }\n\n  list.length && parseAxisCategories(groupsData, categoryParsers);\n  return list;\n}\n\nfunction getParsedCell(cell, parsers) {\n  var i;\n  var ii = parsers.length;\n  var obj = extend({}, cell);\n  var field;\n  var value;\n\n  for (i = 0; i < ii; ++i) {\n    field = parsers[i][0];\n    value = cell[field];\n    obj[field] = parsers[i][1](value, field);\n  }\n\n  return obj;\n}\n\nfunction parse(data, parsers) {\n  var parsedData = [];\n  var i;\n  var ii = data.length;\n  parsedData.length = ii;\n\n  for (i = 0; i < ii; ++i) {\n    parsedData[i] = getParsedCell(data[i], parsers);\n  }\n\n  return parsedData;\n}\n\nfunction findIndexByThreshold(data, valueField, threshold) {\n  var i;\n  var ii = data.length;\n  var value;\n\n  for (i = 0; i < ii; ++i) {\n    value = data[i][valueField];\n\n    if (_isDefined(value) && threshold > value) {\n      break;\n    }\n  }\n\n  return i;\n}\n\nfunction groupMinSlices(originalData, argumentField, valueField, smallValuesGrouping) {\n  smallValuesGrouping = smallValuesGrouping || {};\n  var mode = smallValuesGrouping.mode;\n  var others = {};\n\n  if (!mode || \"none\" === mode) {\n    return;\n  }\n\n  others[argumentField] = String(smallValuesGrouping.groupName || \"others\");\n  others[valueField] = 0;\n  var data = sortValues(originalData.slice(), false, function (a) {\n    return a[valueField];\n  });\n  groupingValues(data, others, valueField, \"smallValueThreshold\" === mode ? findIndexByThreshold(data, valueField, smallValuesGrouping.threshold) : smallValuesGrouping.topCount);\n  others[valueField] && originalData.push(others);\n}\n\nfunction groupPieData(data, groupsData) {\n  var firstSeries = groupsData.groups[0] && groupsData.groups[0].series[0];\n  var isPie = firstSeries && (\"pie\" === firstSeries.type || \"doughnut\" === firstSeries.type || \"donut\" === firstSeries.type);\n\n  if (!isPie) {\n    return;\n  }\n\n  groupsData.groups.forEach(function (group) {\n    group.series.forEach(function (series) {\n      groupMinSlices(data, series.getArgumentField(), series.getValueFields()[0], series.getOptions().smallValuesGrouping);\n    });\n  });\n}\n\nfunction addUniqueItemToCollection(item, collection, itemsHash) {\n  if (!itemsHash[item]) {\n    collection.push(item);\n    itemsHash[item] = true;\n  }\n}\n\nfunction getUniqueArgumentFields(groupsData) {\n  var uniqueArgumentFields = [];\n  var hash = {};\n  groupsData.groups.forEach(function (group) {\n    group.series.forEach(function (series) {\n      addUniqueItemToCollection(series.getArgumentField(), uniqueArgumentFields, hash);\n    });\n  });\n  return uniqueArgumentFields;\n}\n\nfunction sort(a, b) {\n  var result = a - b;\n\n  if (isNaN(result)) {\n    if (!_isDefined(a)) {\n      return 1;\n    }\n\n    if (!_isDefined(b)) {\n      return -1;\n    }\n\n    return 0;\n  }\n\n  return result;\n}\n\nfunction sortByArgument(data, argumentField) {\n  return data.slice().sort(function (a, b) {\n    return sort(a[argumentField], b[argumentField]);\n  });\n}\n\nfunction sortByCallback(data, callback) {\n  return data.slice().sort(callback);\n}\n\nfunction checkValueTypeOfGroup(group, cell) {\n  group.series.forEach(function (series) {\n    series.getValueFields().forEach(function (field) {\n      group.valueType = getType(cell[field], group.valueType);\n    });\n  });\n  return group.valueType;\n}\n\nfunction getSortByCategories(categories) {\n  var hash = {};\n  categories.forEach(function (value, i) {\n    hash[value] = i;\n  });\n  return function (data, argumentField) {\n    return sortValues(data.slice(), true, function (a) {\n      return hash[a[argumentField]];\n    });\n  };\n}\n\nfunction sortData(data, groupsData, options, uniqueArgumentFields) {\n  var dataByArguments = {};\n  var isDiscrete = groupsData.argumentAxisType === DISCRETE;\n  var userCategories = isDiscrete && groupsData.argumentOptions && groupsData.argumentOptions.categories;\n\n  var sortFunction = function (data) {\n    return data;\n  };\n\n  var sortingMethodOption = options.sortingMethod;\n  var reSortCategories;\n\n  if (!userCategories && _isFunction(sortingMethodOption)) {\n    data = sortByCallback(data, sortingMethodOption);\n  }\n\n  if (isDiscrete) {\n    groupsData.categories = getCategories(data, uniqueArgumentFields, userCategories);\n  }\n\n  if (userCategories || !_isFunction(sortingMethodOption) && groupsData.argumentType === STRING && !options._skipArgumentSorting) {\n    sortFunction = getSortByCategories(groupsData.categories);\n  } else if (true === sortingMethodOption && groupsData.argumentType !== STRING) {\n    sortFunction = sortByArgument;\n    reSortCategories = isDiscrete;\n  }\n\n  uniqueArgumentFields.forEach(function (field) {\n    dataByArguments[field] = sortFunction(data, field);\n  });\n\n  if (reSortCategories) {\n    groupsData.categories = groupsData.categories.sort(sort);\n  }\n\n  return dataByArguments;\n}\n\nfunction checkItemExistence(collection, item) {\n  return -1 === collection.map(function (collectionItem) {\n    return collectionItem.valueOf();\n  }).indexOf(item.valueOf());\n}\n\nfunction getCategories(data, uniqueArgumentFields, userCategories) {\n  var categories = userCategories ? userCategories.slice() : [];\n  uniqueArgumentFields.forEach(function (field) {\n    data.forEach(function (item) {\n      var dataItem = item[field];\n      _isDefined(dataItem) && checkItemExistence(categories, dataItem) && categories.push(dataItem);\n    });\n  });\n  return categories;\n}\n\nfunction checkArgumentTypeOfGroup(series, cell, groupsData) {\n  series.forEach(function (currentSeries) {\n    groupsData.argumentType = getType(cell[currentSeries.getArgumentField()], groupsData.argumentType);\n  });\n  return groupsData.argumentType;\n}\n\nfunction checkType(data, groupsData, checkTypeForAllData) {\n  var groupsWithUndefinedValueType = [];\n  var groupsWithUndefinedArgumentType = [];\n  var argumentTypeGroup = groupsData.argumentOptions && axisTypeParser(groupsData.argumentOptions.argumentType);\n  var groupsIndexes;\n  groupsData.groups.forEach(function (group) {\n    if (!group.series.length) {\n      return;\n    }\n\n    var valueTypeGroup = group.valueOptions && axisTypeParser(group.valueOptions.valueType);\n    group.valueType = valueTypeGroup;\n    groupsData.argumentType = argumentTypeGroup;\n    !valueTypeGroup && groupsWithUndefinedValueType.push(group);\n    !argumentTypeGroup && groupsWithUndefinedArgumentType.push(group);\n  });\n\n  if (groupsWithUndefinedValueType.length || groupsWithUndefinedArgumentType.length) {\n    groupsIndexes = groupsWithUndefinedValueType.map(function (_, index) {\n      return index;\n    });\n    data.some(function (cell) {\n      var defineArg;\n      groupsWithUndefinedValueType.forEach(function (group, groupIndex) {\n        if (checkValueTypeOfGroup(group, cell) && groupsIndexes.indexOf(groupIndex) >= 0) {\n          groupsIndexes.splice(groupIndex, 1);\n        }\n      });\n\n      if (!defineArg) {\n        groupsWithUndefinedArgumentType.forEach(function (group) {\n          defineArg = checkArgumentTypeOfGroup(group.series, cell, groupsData);\n        });\n      }\n\n      if (!checkTypeForAllData && defineArg && 0 === groupsIndexes.length) {\n        return true;\n      }\n    });\n  }\n}\n\nfunction checkAxisType(groupsData, incidentOccurred) {\n  var argumentOptions = groupsData.argumentOptions || {};\n  var userArgumentCategories = argumentOptions && argumentOptions.categories || [];\n  var argumentAxisType = correctAxisType(groupsData.argumentType, argumentOptions.type, !!userArgumentCategories.length, incidentOccurred);\n  groupsData.groups.forEach(function (group) {\n    var valueOptions = group.valueOptions || {};\n    var valueCategories = valueOptions.categories || [];\n    var valueAxisType = correctAxisType(group.valueType, valueOptions.type, !!valueCategories.length, incidentOccurred);\n    group.series.forEach(function (series) {\n      var optionsSeries = {};\n      optionsSeries.argumentAxisType = argumentAxisType;\n      optionsSeries.valueAxisType = valueAxisType;\n      groupsData.argumentAxisType = groupsData.argumentAxisType || optionsSeries.argumentAxisType;\n      group.valueAxisType = group.valueAxisType || optionsSeries.valueAxisType;\n      optionsSeries.argumentType = groupsData.argumentType;\n      optionsSeries.valueType = group.valueType;\n      optionsSeries.showZero = valueOptions.showZero;\n      series.updateDataType(optionsSeries);\n    });\n    group.valueAxisType = group.valueAxisType || valueAxisType;\n\n    if (group.valueAxis) {\n      group.valueAxis.setTypes(group.valueAxisType, group.valueType, VALUE_TYPE);\n      group.valueAxis.validate();\n    }\n  });\n  groupsData.argumentAxisType = groupsData.argumentAxisType || argumentAxisType;\n\n  if (groupsData.argumentAxes) {\n    groupsData.argumentAxes.forEach(function (axis) {\n      axis.setTypes(groupsData.argumentAxisType, groupsData.argumentType, ARGUMENT_TYPE);\n      axis.validate();\n    });\n  }\n}\n\nfunction verifyData(source, incidentOccurred) {\n  var data = [];\n\n  var sourceIsDefined = _isDefined(source);\n\n  var hasError = sourceIsDefined && !_isArray(source);\n  var i;\n  var ii;\n  var k;\n  var item;\n\n  if (sourceIsDefined && !hasError) {\n    for (i = 0, ii = source.length, k = 0; i < ii; ++i) {\n      item = source[i];\n\n      if (_isObject(item)) {\n        data[k++] = item;\n      } else if (item) {\n        hasError = true;\n      }\n    }\n  }\n\n  if (hasError) {\n    incidentOccurred(\"E2001\");\n  }\n\n  return data;\n}\n\nexport function validateData(data, groupsData, incidentOccurred, options) {\n  data = verifyData(data, incidentOccurred);\n  groupsData.argumentType = groupsData.argumentAxisType = null;\n  processGroups(groupsData.groups);\n  resetArgumentAxes(groupsData.argumentAxes);\n  checkType(data, groupsData, options.checkTypeForAllData);\n  checkAxisType(groupsData, incidentOccurred);\n\n  if (options.convertToAxisDataType) {\n    data = parse(data, prepareParsers(groupsData, incidentOccurred));\n  }\n\n  groupPieData(data, groupsData);\n  var dataByArgumentFields = sortData(data, groupsData, options, getUniqueArgumentFields(groupsData));\n  return dataByArgumentFields;\n}","map":{"version":3,"names":["isDefined","_isDefined","isFunction","_isFunction","isString","_isString","isDate","_isDate","isNumeric","_isNumber","isObject","_isObject","STRING","NUMERIC","DATETIME","DISCRETE","SEMIDISCRETE","CONTINUOUS","LOGARITHMIC","VALUE_TYPE","ARGUMENT_TYPE","extend","enumParser","axisTypeParser","getParser","_getParser","_isArray","Array","isArray","groupingValues","data","others","valueField","index","slice","forEach","cell","processGroups","groups","group","valueType","valueAxisType","series","updateDataType","valueAxis","resetTypes","sortValues","asc","selector","func","a","b","sort","valA","valB","aa","bb","resetArgumentAxes","axes","axis","parseCategories","categories","parser","newArray","category","parsedCategory","push","parseAxisCategories","groupsData","parsers","argumentCategories","argumentOptions","valueGroup","i","valueOptions","eigen","x","getType","unit","type","result","correctAxisType","axisType","hasCategories","incidentOccurred","validUnit","field","createParserUnit","filterInfinity","isFinite","parseUnit","prepareParsers","argumentParser","argumentType","argumentAxisType","sizeParser","valueParser","categoryParsers","cache","list","groupIndex","getArgumentField","getValueFields","getSizeField","length","getParsedCell","ii","obj","value","parse","parsedData","findIndexByThreshold","threshold","groupMinSlices","originalData","argumentField","smallValuesGrouping","mode","String","groupName","topCount","groupPieData","firstSeries","isPie","getOptions","addUniqueItemToCollection","item","collection","itemsHash","getUniqueArgumentFields","uniqueArgumentFields","hash","isNaN","sortByArgument","sortByCallback","callback","checkValueTypeOfGroup","getSortByCategories","sortData","options","dataByArguments","isDiscrete","userCategories","sortFunction","sortingMethodOption","sortingMethod","reSortCategories","getCategories","_skipArgumentSorting","checkItemExistence","map","collectionItem","valueOf","indexOf","dataItem","checkArgumentTypeOfGroup","currentSeries","checkType","checkTypeForAllData","groupsWithUndefinedValueType","groupsWithUndefinedArgumentType","argumentTypeGroup","groupsIndexes","valueTypeGroup","_","some","defineArg","splice","checkAxisType","userArgumentCategories","valueCategories","optionsSeries","showZero","setTypes","validate","argumentAxes","verifyData","source","sourceIsDefined","hasError","k","validateData","convertToAxisDataType","dataByArgumentFields"],"sources":["E:/MisaProject/W2022_06/misa_emis/node_modules/devextreme/esm/viz/components/data_validator.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/viz/components/data_validator.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    isDefined as _isDefined,\r\n    isFunction as _isFunction,\r\n    isString as _isString,\r\n    isDate as _isDate,\r\n    isNumeric as _isNumber,\r\n    isObject as _isObject\r\n} from \"../../core/utils/type\";\r\nvar STRING = \"string\";\r\nvar NUMERIC = \"numeric\";\r\nvar DATETIME = \"datetime\";\r\nvar DISCRETE = \"discrete\";\r\nvar SEMIDISCRETE = \"semidiscrete\";\r\nvar CONTINUOUS = \"continuous\";\r\nvar LOGARITHMIC = \"logarithmic\";\r\nvar VALUE_TYPE = \"valueType\";\r\nvar ARGUMENT_TYPE = \"argumentType\";\r\nimport {\r\n    extend\r\n} from \"../../core/utils/extend\";\r\nimport {\r\n    enumParser\r\n} from \"../core/utils\";\r\nvar axisTypeParser = enumParser([STRING, NUMERIC, DATETIME]);\r\nimport {\r\n    getParser as _getParser\r\n} from \"./parse_utils\";\r\nvar _isArray = Array.isArray;\r\n\r\nfunction groupingValues(data, others, valueField, index) {\r\n    if (index >= 0) {\r\n        data.slice(index).forEach((function(cell) {\r\n            if (_isDefined(cell[valueField])) {\r\n                others[valueField] += cell[valueField];\r\n                cell[valueField] = void 0\r\n            }\r\n        }))\r\n    }\r\n}\r\n\r\nfunction processGroups(groups) {\r\n    groups.forEach((function(group) {\r\n        group.valueType = group.valueAxisType = null;\r\n        group.series.forEach((function(series) {\r\n            series.updateDataType({})\r\n        }));\r\n        group.valueAxis && group.valueAxis.resetTypes(VALUE_TYPE)\r\n    }))\r\n}\r\n\r\nfunction sortValues(data, asc, selector) {\r\n    var func = asc ? function(a, b) {\r\n        return a - b\r\n    } : function(a, b) {\r\n        return b - a\r\n    };\r\n    data.sort((function(a, b) {\r\n        var valA = selector(a);\r\n        var valB = selector(b);\r\n        var aa = _isDefined(valA) ? 1 : 0;\r\n        var bb = _isDefined(valB) ? 1 : 0;\r\n        return aa && bb ? func(valA, valB) : func(aa, bb)\r\n    }));\r\n    return data\r\n}\r\n\r\nfunction resetArgumentAxes(axes) {\r\n    axes && axes.forEach((function(axis) {\r\n        axis.resetTypes(ARGUMENT_TYPE)\r\n    }))\r\n}\r\n\r\nfunction parseCategories(categories, parser) {\r\n    var newArray = [];\r\n    categories.forEach((function(category) {\r\n        var parsedCategory = parser(category);\r\n        void 0 !== parsedCategory && newArray.push(parsedCategory)\r\n    }));\r\n    return newArray\r\n}\r\n\r\nfunction parseAxisCategories(groupsData, parsers) {\r\n    var argumentCategories = groupsData.argumentOptions && groupsData.argumentOptions.categories;\r\n    groupsData.groups.forEach((function(valueGroup, i) {\r\n        var categories = valueGroup.valueOptions && valueGroup.valueOptions.categories;\r\n        if (categories) {\r\n            valueGroup.valueOptions.categories = parseCategories(categories, parsers[i + 1])\r\n        }\r\n    }));\r\n    if (argumentCategories) {\r\n        groupsData.argumentOptions.categories = parseCategories(argumentCategories, parsers[0])\r\n    }\r\n}\r\n\r\nfunction eigen(x) {\r\n    return x\r\n}\r\n\r\nfunction getType(unit, type) {\r\n    var result = type;\r\n    if (type === STRING || _isString(unit)) {\r\n        result = STRING\r\n    } else if (type === DATETIME || _isDate(unit)) {\r\n        result = DATETIME\r\n    } else if (_isNumber(unit)) {\r\n        result = NUMERIC\r\n    }\r\n    return result\r\n}\r\n\r\nfunction correctAxisType(type, axisType, hasCategories, incidentOccurred) {\r\n    if (type === STRING && (axisType === CONTINUOUS || axisType === LOGARITHMIC || axisType === SEMIDISCRETE)) {\r\n        incidentOccurred(\"E2002\")\r\n    }\r\n    return axisType === LOGARITHMIC ? LOGARITHMIC : hasCategories || axisType === DISCRETE || type === STRING ? DISCRETE : axisType === SEMIDISCRETE ? SEMIDISCRETE : CONTINUOUS\r\n}\r\n\r\nfunction validUnit(unit, field, incidentOccurred) {\r\n    if (unit) {\r\n        incidentOccurred(!_isNumber(unit) && !_isDate(unit) && !_isString(unit) ? \"E2003\" : \"E2004\", [field])\r\n    }\r\n}\r\n\r\nfunction createParserUnit(type, axisType, incidentOccurred) {\r\n    var parser = type ? _getParser(type) : eigen;\r\n    var filterInfinity = axisType !== DISCRETE ? function(x) {\r\n        return isFinite(x) || void 0 === x ? x : null\r\n    } : eigen;\r\n    return function(unit, field) {\r\n        var parseUnit = filterInfinity(parser(unit));\r\n        if (void 0 === parseUnit) {\r\n            validUnit(unit, field, incidentOccurred)\r\n        }\r\n        return parseUnit\r\n    }\r\n}\r\n\r\nfunction prepareParsers(groupsData, incidentOccurred) {\r\n    var argumentParser = createParserUnit(groupsData.argumentType, groupsData.argumentAxisType, incidentOccurred);\r\n    var sizeParser;\r\n    var valueParser;\r\n    var categoryParsers = [argumentParser];\r\n    var cache = {};\r\n    var list = [];\r\n    groupsData.groups.forEach((function(group, groupIndex) {\r\n        group.series.forEach((function(series) {\r\n            valueParser = createParserUnit(group.valueType, group.valueAxisType, incidentOccurred);\r\n            sizeParser = createParserUnit(NUMERIC, CONTINUOUS, incidentOccurred);\r\n            cache[series.getArgumentField()] = argumentParser;\r\n            series.getValueFields().forEach((function(field) {\r\n                categoryParsers[groupIndex + 1] = valueParser;\r\n                cache[field] = valueParser\r\n            }));\r\n            if (series.getSizeField()) {\r\n                cache[series.getSizeField()] = sizeParser\r\n            }\r\n        }))\r\n    }));\r\n    for (var field in cache) {\r\n        list.push([field, cache[field]])\r\n    }\r\n    list.length && parseAxisCategories(groupsData, categoryParsers);\r\n    return list\r\n}\r\n\r\nfunction getParsedCell(cell, parsers) {\r\n    var i;\r\n    var ii = parsers.length;\r\n    var obj = extend({}, cell);\r\n    var field;\r\n    var value;\r\n    for (i = 0; i < ii; ++i) {\r\n        field = parsers[i][0];\r\n        value = cell[field];\r\n        obj[field] = parsers[i][1](value, field)\r\n    }\r\n    return obj\r\n}\r\n\r\nfunction parse(data, parsers) {\r\n    var parsedData = [];\r\n    var i;\r\n    var ii = data.length;\r\n    parsedData.length = ii;\r\n    for (i = 0; i < ii; ++i) {\r\n        parsedData[i] = getParsedCell(data[i], parsers)\r\n    }\r\n    return parsedData\r\n}\r\n\r\nfunction findIndexByThreshold(data, valueField, threshold) {\r\n    var i;\r\n    var ii = data.length;\r\n    var value;\r\n    for (i = 0; i < ii; ++i) {\r\n        value = data[i][valueField];\r\n        if (_isDefined(value) && threshold > value) {\r\n            break\r\n        }\r\n    }\r\n    return i\r\n}\r\n\r\nfunction groupMinSlices(originalData, argumentField, valueField, smallValuesGrouping) {\r\n    smallValuesGrouping = smallValuesGrouping || {};\r\n    var mode = smallValuesGrouping.mode;\r\n    var others = {};\r\n    if (!mode || \"none\" === mode) {\r\n        return\r\n    }\r\n    others[argumentField] = String(smallValuesGrouping.groupName || \"others\");\r\n    others[valueField] = 0;\r\n    var data = sortValues(originalData.slice(), false, (function(a) {\r\n        return a[valueField]\r\n    }));\r\n    groupingValues(data, others, valueField, \"smallValueThreshold\" === mode ? findIndexByThreshold(data, valueField, smallValuesGrouping.threshold) : smallValuesGrouping.topCount);\r\n    others[valueField] && originalData.push(others)\r\n}\r\n\r\nfunction groupPieData(data, groupsData) {\r\n    var firstSeries = groupsData.groups[0] && groupsData.groups[0].series[0];\r\n    var isPie = firstSeries && (\"pie\" === firstSeries.type || \"doughnut\" === firstSeries.type || \"donut\" === firstSeries.type);\r\n    if (!isPie) {\r\n        return\r\n    }\r\n    groupsData.groups.forEach((function(group) {\r\n        group.series.forEach((function(series) {\r\n            groupMinSlices(data, series.getArgumentField(), series.getValueFields()[0], series.getOptions().smallValuesGrouping)\r\n        }))\r\n    }))\r\n}\r\n\r\nfunction addUniqueItemToCollection(item, collection, itemsHash) {\r\n    if (!itemsHash[item]) {\r\n        collection.push(item);\r\n        itemsHash[item] = true\r\n    }\r\n}\r\n\r\nfunction getUniqueArgumentFields(groupsData) {\r\n    var uniqueArgumentFields = [];\r\n    var hash = {};\r\n    groupsData.groups.forEach((function(group) {\r\n        group.series.forEach((function(series) {\r\n            addUniqueItemToCollection(series.getArgumentField(), uniqueArgumentFields, hash)\r\n        }))\r\n    }));\r\n    return uniqueArgumentFields\r\n}\r\n\r\nfunction sort(a, b) {\r\n    var result = a - b;\r\n    if (isNaN(result)) {\r\n        if (!_isDefined(a)) {\r\n            return 1\r\n        }\r\n        if (!_isDefined(b)) {\r\n            return -1\r\n        }\r\n        return 0\r\n    }\r\n    return result\r\n}\r\n\r\nfunction sortByArgument(data, argumentField) {\r\n    return data.slice().sort((function(a, b) {\r\n        return sort(a[argumentField], b[argumentField])\r\n    }))\r\n}\r\n\r\nfunction sortByCallback(data, callback) {\r\n    return data.slice().sort(callback)\r\n}\r\n\r\nfunction checkValueTypeOfGroup(group, cell) {\r\n    group.series.forEach((function(series) {\r\n        series.getValueFields().forEach((function(field) {\r\n            group.valueType = getType(cell[field], group.valueType)\r\n        }))\r\n    }));\r\n    return group.valueType\r\n}\r\n\r\nfunction getSortByCategories(categories) {\r\n    var hash = {};\r\n    categories.forEach((function(value, i) {\r\n        hash[value] = i\r\n    }));\r\n    return function(data, argumentField) {\r\n        return sortValues(data.slice(), true, (function(a) {\r\n            return hash[a[argumentField]]\r\n        }))\r\n    }\r\n}\r\n\r\nfunction sortData(data, groupsData, options, uniqueArgumentFields) {\r\n    var dataByArguments = {};\r\n    var isDiscrete = groupsData.argumentAxisType === DISCRETE;\r\n    var userCategories = isDiscrete && groupsData.argumentOptions && groupsData.argumentOptions.categories;\r\n    var sortFunction = function(data) {\r\n        return data\r\n    };\r\n    var sortingMethodOption = options.sortingMethod;\r\n    var reSortCategories;\r\n    if (!userCategories && _isFunction(sortingMethodOption)) {\r\n        data = sortByCallback(data, sortingMethodOption)\r\n    }\r\n    if (isDiscrete) {\r\n        groupsData.categories = getCategories(data, uniqueArgumentFields, userCategories)\r\n    }\r\n    if (userCategories || !_isFunction(sortingMethodOption) && groupsData.argumentType === STRING && !options._skipArgumentSorting) {\r\n        sortFunction = getSortByCategories(groupsData.categories)\r\n    } else if (true === sortingMethodOption && groupsData.argumentType !== STRING) {\r\n        sortFunction = sortByArgument;\r\n        reSortCategories = isDiscrete\r\n    }\r\n    uniqueArgumentFields.forEach((function(field) {\r\n        dataByArguments[field] = sortFunction(data, field)\r\n    }));\r\n    if (reSortCategories) {\r\n        groupsData.categories = groupsData.categories.sort(sort)\r\n    }\r\n    return dataByArguments\r\n}\r\n\r\nfunction checkItemExistence(collection, item) {\r\n    return -1 === collection.map((function(collectionItem) {\r\n        return collectionItem.valueOf()\r\n    })).indexOf(item.valueOf())\r\n}\r\n\r\nfunction getCategories(data, uniqueArgumentFields, userCategories) {\r\n    var categories = userCategories ? userCategories.slice() : [];\r\n    uniqueArgumentFields.forEach((function(field) {\r\n        data.forEach((function(item) {\r\n            var dataItem = item[field];\r\n            _isDefined(dataItem) && checkItemExistence(categories, dataItem) && categories.push(dataItem)\r\n        }))\r\n    }));\r\n    return categories\r\n}\r\n\r\nfunction checkArgumentTypeOfGroup(series, cell, groupsData) {\r\n    series.forEach((function(currentSeries) {\r\n        groupsData.argumentType = getType(cell[currentSeries.getArgumentField()], groupsData.argumentType)\r\n    }));\r\n    return groupsData.argumentType\r\n}\r\n\r\nfunction checkType(data, groupsData, checkTypeForAllData) {\r\n    var groupsWithUndefinedValueType = [];\r\n    var groupsWithUndefinedArgumentType = [];\r\n    var argumentTypeGroup = groupsData.argumentOptions && axisTypeParser(groupsData.argumentOptions.argumentType);\r\n    var groupsIndexes;\r\n    groupsData.groups.forEach((function(group) {\r\n        if (!group.series.length) {\r\n            return\r\n        }\r\n        var valueTypeGroup = group.valueOptions && axisTypeParser(group.valueOptions.valueType);\r\n        group.valueType = valueTypeGroup;\r\n        groupsData.argumentType = argumentTypeGroup;\r\n        !valueTypeGroup && groupsWithUndefinedValueType.push(group);\r\n        !argumentTypeGroup && groupsWithUndefinedArgumentType.push(group)\r\n    }));\r\n    if (groupsWithUndefinedValueType.length || groupsWithUndefinedArgumentType.length) {\r\n        groupsIndexes = groupsWithUndefinedValueType.map((function(_, index) {\r\n            return index\r\n        }));\r\n        data.some((function(cell) {\r\n            var defineArg;\r\n            groupsWithUndefinedValueType.forEach((function(group, groupIndex) {\r\n                if (checkValueTypeOfGroup(group, cell) && groupsIndexes.indexOf(groupIndex) >= 0) {\r\n                    groupsIndexes.splice(groupIndex, 1)\r\n                }\r\n            }));\r\n            if (!defineArg) {\r\n                groupsWithUndefinedArgumentType.forEach((function(group) {\r\n                    defineArg = checkArgumentTypeOfGroup(group.series, cell, groupsData)\r\n                }))\r\n            }\r\n            if (!checkTypeForAllData && defineArg && 0 === groupsIndexes.length) {\r\n                return true\r\n            }\r\n        }))\r\n    }\r\n}\r\n\r\nfunction checkAxisType(groupsData, incidentOccurred) {\r\n    var argumentOptions = groupsData.argumentOptions || {};\r\n    var userArgumentCategories = argumentOptions && argumentOptions.categories || [];\r\n    var argumentAxisType = correctAxisType(groupsData.argumentType, argumentOptions.type, !!userArgumentCategories.length, incidentOccurred);\r\n    groupsData.groups.forEach((function(group) {\r\n        var valueOptions = group.valueOptions || {};\r\n        var valueCategories = valueOptions.categories || [];\r\n        var valueAxisType = correctAxisType(group.valueType, valueOptions.type, !!valueCategories.length, incidentOccurred);\r\n        group.series.forEach((function(series) {\r\n            var optionsSeries = {};\r\n            optionsSeries.argumentAxisType = argumentAxisType;\r\n            optionsSeries.valueAxisType = valueAxisType;\r\n            groupsData.argumentAxisType = groupsData.argumentAxisType || optionsSeries.argumentAxisType;\r\n            group.valueAxisType = group.valueAxisType || optionsSeries.valueAxisType;\r\n            optionsSeries.argumentType = groupsData.argumentType;\r\n            optionsSeries.valueType = group.valueType;\r\n            optionsSeries.showZero = valueOptions.showZero;\r\n            series.updateDataType(optionsSeries)\r\n        }));\r\n        group.valueAxisType = group.valueAxisType || valueAxisType;\r\n        if (group.valueAxis) {\r\n            group.valueAxis.setTypes(group.valueAxisType, group.valueType, VALUE_TYPE);\r\n            group.valueAxis.validate()\r\n        }\r\n    }));\r\n    groupsData.argumentAxisType = groupsData.argumentAxisType || argumentAxisType;\r\n    if (groupsData.argumentAxes) {\r\n        groupsData.argumentAxes.forEach((function(axis) {\r\n            axis.setTypes(groupsData.argumentAxisType, groupsData.argumentType, ARGUMENT_TYPE);\r\n            axis.validate()\r\n        }))\r\n    }\r\n}\r\n\r\nfunction verifyData(source, incidentOccurred) {\r\n    var data = [];\r\n    var sourceIsDefined = _isDefined(source);\r\n    var hasError = sourceIsDefined && !_isArray(source);\r\n    var i;\r\n    var ii;\r\n    var k;\r\n    var item;\r\n    if (sourceIsDefined && !hasError) {\r\n        for (i = 0, ii = source.length, k = 0; i < ii; ++i) {\r\n            item = source[i];\r\n            if (_isObject(item)) {\r\n                data[k++] = item\r\n            } else if (item) {\r\n                hasError = true\r\n            }\r\n        }\r\n    }\r\n    if (hasError) {\r\n        incidentOccurred(\"E2001\")\r\n    }\r\n    return data\r\n}\r\nexport function validateData(data, groupsData, incidentOccurred, options) {\r\n    data = verifyData(data, incidentOccurred);\r\n    groupsData.argumentType = groupsData.argumentAxisType = null;\r\n    processGroups(groupsData.groups);\r\n    resetArgumentAxes(groupsData.argumentAxes);\r\n    checkType(data, groupsData, options.checkTypeForAllData);\r\n    checkAxisType(groupsData, incidentOccurred);\r\n    if (options.convertToAxisDataType) {\r\n        data = parse(data, prepareParsers(groupsData, incidentOccurred))\r\n    }\r\n    groupPieData(data, groupsData);\r\n    var dataByArgumentFields = sortData(data, groupsData, options, getUniqueArgumentFields(groupsData));\r\n    return dataByArgumentFields\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SACIA,SAAS,IAAIC,UADjB,EAEIC,UAAU,IAAIC,WAFlB,EAGIC,QAAQ,IAAIC,SAHhB,EAIIC,MAAM,IAAIC,OAJd,EAKIC,SAAS,IAAIC,SALjB,EAMIC,QAAQ,IAAIC,SANhB,QAOO,uBAPP;AAQA,IAAIC,MAAM,GAAG,QAAb;AACA,IAAIC,OAAO,GAAG,SAAd;AACA,IAAIC,QAAQ,GAAG,UAAf;AACA,IAAIC,QAAQ,GAAG,UAAf;AACA,IAAIC,YAAY,GAAG,cAAnB;AACA,IAAIC,UAAU,GAAG,YAAjB;AACA,IAAIC,WAAW,GAAG,aAAlB;AACA,IAAIC,UAAU,GAAG,WAAjB;AACA,IAAIC,aAAa,GAAG,cAApB;AACA,SACIC,MADJ,QAEO,yBAFP;AAGA,SACIC,UADJ,QAEO,eAFP;AAGA,IAAIC,cAAc,GAAGD,UAAU,CAAC,CAACV,MAAD,EAASC,OAAT,EAAkBC,QAAlB,CAAD,CAA/B;AACA,SACIU,SAAS,IAAIC,UADjB,QAEO,eAFP;AAGA,IAAIC,QAAQ,GAAGC,KAAK,CAACC,OAArB;;AAEA,SAASC,cAAT,CAAwBC,IAAxB,EAA8BC,MAA9B,EAAsCC,UAAtC,EAAkDC,KAAlD,EAAyD;EACrD,IAAIA,KAAK,IAAI,CAAb,EAAgB;IACZH,IAAI,CAACI,KAAL,CAAWD,KAAX,EAAkBE,OAAlB,CAA2B,UAASC,IAAT,EAAe;MACtC,IAAInC,UAAU,CAACmC,IAAI,CAACJ,UAAD,CAAL,CAAd,EAAkC;QAC9BD,MAAM,CAACC,UAAD,CAAN,IAAsBI,IAAI,CAACJ,UAAD,CAA1B;QACAI,IAAI,CAACJ,UAAD,CAAJ,GAAmB,KAAK,CAAxB;MACH;IACJ,CALD;EAMH;AACJ;;AAED,SAASK,aAAT,CAAuBC,MAAvB,EAA+B;EAC3BA,MAAM,CAACH,OAAP,CAAgB,UAASI,KAAT,EAAgB;IAC5BA,KAAK,CAACC,SAAN,GAAkBD,KAAK,CAACE,aAAN,GAAsB,IAAxC;IACAF,KAAK,CAACG,MAAN,CAAaP,OAAb,CAAsB,UAASO,MAAT,EAAiB;MACnCA,MAAM,CAACC,cAAP,CAAsB,EAAtB;IACH,CAFD;IAGAJ,KAAK,CAACK,SAAN,IAAmBL,KAAK,CAACK,SAAN,CAAgBC,UAAhB,CAA2B1B,UAA3B,CAAnB;EACH,CAND;AAOH;;AAED,SAAS2B,UAAT,CAAoBhB,IAApB,EAA0BiB,GAA1B,EAA+BC,QAA/B,EAAyC;EACrC,IAAIC,IAAI,GAAGF,GAAG,GAAG,UAASG,CAAT,EAAYC,CAAZ,EAAe;IAC5B,OAAOD,CAAC,GAAGC,CAAX;EACH,CAFa,GAEV,UAASD,CAAT,EAAYC,CAAZ,EAAe;IACf,OAAOA,CAAC,GAAGD,CAAX;EACH,CAJD;EAKApB,IAAI,CAACsB,IAAL,CAAW,UAASF,CAAT,EAAYC,CAAZ,EAAe;IACtB,IAAIE,IAAI,GAAGL,QAAQ,CAACE,CAAD,CAAnB;IACA,IAAII,IAAI,GAAGN,QAAQ,CAACG,CAAD,CAAnB;IACA,IAAII,EAAE,GAAGtD,UAAU,CAACoD,IAAD,CAAV,GAAmB,CAAnB,GAAuB,CAAhC;IACA,IAAIG,EAAE,GAAGvD,UAAU,CAACqD,IAAD,CAAV,GAAmB,CAAnB,GAAuB,CAAhC;IACA,OAAOC,EAAE,IAAIC,EAAN,GAAWP,IAAI,CAACI,IAAD,EAAOC,IAAP,CAAf,GAA8BL,IAAI,CAACM,EAAD,EAAKC,EAAL,CAAzC;EACH,CAND;EAOA,OAAO1B,IAAP;AACH;;AAED,SAAS2B,iBAAT,CAA2BC,IAA3B,EAAiC;EAC7BA,IAAI,IAAIA,IAAI,CAACvB,OAAL,CAAc,UAASwB,IAAT,EAAe;IACjCA,IAAI,CAACd,UAAL,CAAgBzB,aAAhB;EACH,CAFO,CAAR;AAGH;;AAED,SAASwC,eAAT,CAAyBC,UAAzB,EAAqCC,MAArC,EAA6C;EACzC,IAAIC,QAAQ,GAAG,EAAf;EACAF,UAAU,CAAC1B,OAAX,CAAoB,UAAS6B,QAAT,EAAmB;IACnC,IAAIC,cAAc,GAAGH,MAAM,CAACE,QAAD,CAA3B;IACA,KAAK,CAAL,KAAWC,cAAX,IAA6BF,QAAQ,CAACG,IAAT,CAAcD,cAAd,CAA7B;EACH,CAHD;EAIA,OAAOF,QAAP;AACH;;AAED,SAASI,mBAAT,CAA6BC,UAA7B,EAAyCC,OAAzC,EAAkD;EAC9C,IAAIC,kBAAkB,GAAGF,UAAU,CAACG,eAAX,IAA8BH,UAAU,CAACG,eAAX,CAA2BV,UAAlF;EACAO,UAAU,CAAC9B,MAAX,CAAkBH,OAAlB,CAA2B,UAASqC,UAAT,EAAqBC,CAArB,EAAwB;IAC/C,IAAIZ,UAAU,GAAGW,UAAU,CAACE,YAAX,IAA2BF,UAAU,CAACE,YAAX,CAAwBb,UAApE;;IACA,IAAIA,UAAJ,EAAgB;MACZW,UAAU,CAACE,YAAX,CAAwBb,UAAxB,GAAqCD,eAAe,CAACC,UAAD,EAAaQ,OAAO,CAACI,CAAC,GAAG,CAAL,CAApB,CAApD;IACH;EACJ,CALD;;EAMA,IAAIH,kBAAJ,EAAwB;IACpBF,UAAU,CAACG,eAAX,CAA2BV,UAA3B,GAAwCD,eAAe,CAACU,kBAAD,EAAqBD,OAAO,CAAC,CAAD,CAA5B,CAAvD;EACH;AACJ;;AAED,SAASM,KAAT,CAAeC,CAAf,EAAkB;EACd,OAAOA,CAAP;AACH;;AAED,SAASC,OAAT,CAAiBC,IAAjB,EAAuBC,IAAvB,EAA6B;EACzB,IAAIC,MAAM,GAAGD,IAAb;;EACA,IAAIA,IAAI,KAAKnE,MAAT,IAAmBP,SAAS,CAACyE,IAAD,CAAhC,EAAwC;IACpCE,MAAM,GAAGpE,MAAT;EACH,CAFD,MAEO,IAAImE,IAAI,KAAKjE,QAAT,IAAqBP,OAAO,CAACuE,IAAD,CAAhC,EAAwC;IAC3CE,MAAM,GAAGlE,QAAT;EACH,CAFM,MAEA,IAAIL,SAAS,CAACqE,IAAD,CAAb,EAAqB;IACxBE,MAAM,GAAGnE,OAAT;EACH;;EACD,OAAOmE,MAAP;AACH;;AAED,SAASC,eAAT,CAAyBF,IAAzB,EAA+BG,QAA/B,EAAyCC,aAAzC,EAAwDC,gBAAxD,EAA0E;EACtE,IAAIL,IAAI,KAAKnE,MAAT,KAAoBsE,QAAQ,KAAKjE,UAAb,IAA2BiE,QAAQ,KAAKhE,WAAxC,IAAuDgE,QAAQ,KAAKlE,YAAxF,CAAJ,EAA2G;IACvGoE,gBAAgB,CAAC,OAAD,CAAhB;EACH;;EACD,OAAOF,QAAQ,KAAKhE,WAAb,GAA2BA,WAA3B,GAAyCiE,aAAa,IAAID,QAAQ,KAAKnE,QAA9B,IAA0CgE,IAAI,KAAKnE,MAAnD,GAA4DG,QAA5D,GAAuEmE,QAAQ,KAAKlE,YAAb,GAA4BA,YAA5B,GAA2CC,UAAlK;AACH;;AAED,SAASoE,SAAT,CAAmBP,IAAnB,EAAyBQ,KAAzB,EAAgCF,gBAAhC,EAAkD;EAC9C,IAAIN,IAAJ,EAAU;IACNM,gBAAgB,CAAC,CAAC3E,SAAS,CAACqE,IAAD,CAAV,IAAoB,CAACvE,OAAO,CAACuE,IAAD,CAA5B,IAAsC,CAACzE,SAAS,CAACyE,IAAD,CAAhD,GAAyD,OAAzD,GAAmE,OAApE,EAA6E,CAACQ,KAAD,CAA7E,CAAhB;EACH;AACJ;;AAED,SAASC,gBAAT,CAA0BR,IAA1B,EAAgCG,QAAhC,EAA0CE,gBAA1C,EAA4D;EACxD,IAAItB,MAAM,GAAGiB,IAAI,GAAGtD,UAAU,CAACsD,IAAD,CAAb,GAAsBJ,KAAvC;EACA,IAAIa,cAAc,GAAGN,QAAQ,KAAKnE,QAAb,GAAwB,UAAS6D,CAAT,EAAY;IACrD,OAAOa,QAAQ,CAACb,CAAD,CAAR,IAAe,KAAK,CAAL,KAAWA,CAA1B,GAA8BA,CAA9B,GAAkC,IAAzC;EACH,CAFoB,GAEjBD,KAFJ;EAGA,OAAO,UAASG,IAAT,EAAeQ,KAAf,EAAsB;IACzB,IAAII,SAAS,GAAGF,cAAc,CAAC1B,MAAM,CAACgB,IAAD,CAAP,CAA9B;;IACA,IAAI,KAAK,CAAL,KAAWY,SAAf,EAA0B;MACtBL,SAAS,CAACP,IAAD,EAAOQ,KAAP,EAAcF,gBAAd,CAAT;IACH;;IACD,OAAOM,SAAP;EACH,CAND;AAOH;;AAED,SAASC,cAAT,CAAwBvB,UAAxB,EAAoCgB,gBAApC,EAAsD;EAClD,IAAIQ,cAAc,GAAGL,gBAAgB,CAACnB,UAAU,CAACyB,YAAZ,EAA0BzB,UAAU,CAAC0B,gBAArC,EAAuDV,gBAAvD,CAArC;EACA,IAAIW,UAAJ;EACA,IAAIC,WAAJ;EACA,IAAIC,eAAe,GAAG,CAACL,cAAD,CAAtB;EACA,IAAIM,KAAK,GAAG,EAAZ;EACA,IAAIC,IAAI,GAAG,EAAX;EACA/B,UAAU,CAAC9B,MAAX,CAAkBH,OAAlB,CAA2B,UAASI,KAAT,EAAgB6D,UAAhB,EAA4B;IACnD7D,KAAK,CAACG,MAAN,CAAaP,OAAb,CAAsB,UAASO,MAAT,EAAiB;MACnCsD,WAAW,GAAGT,gBAAgB,CAAChD,KAAK,CAACC,SAAP,EAAkBD,KAAK,CAACE,aAAxB,EAAuC2C,gBAAvC,CAA9B;MACAW,UAAU,GAAGR,gBAAgB,CAAC1E,OAAD,EAAUI,UAAV,EAAsBmE,gBAAtB,CAA7B;MACAc,KAAK,CAACxD,MAAM,CAAC2D,gBAAP,EAAD,CAAL,GAAmCT,cAAnC;MACAlD,MAAM,CAAC4D,cAAP,GAAwBnE,OAAxB,CAAiC,UAASmD,KAAT,EAAgB;QAC7CW,eAAe,CAACG,UAAU,GAAG,CAAd,CAAf,GAAkCJ,WAAlC;QACAE,KAAK,CAACZ,KAAD,CAAL,GAAeU,WAAf;MACH,CAHD;;MAIA,IAAItD,MAAM,CAAC6D,YAAP,EAAJ,EAA2B;QACvBL,KAAK,CAACxD,MAAM,CAAC6D,YAAP,EAAD,CAAL,GAA+BR,UAA/B;MACH;IACJ,CAXD;EAYH,CAbD;;EAcA,KAAK,IAAIT,KAAT,IAAkBY,KAAlB,EAAyB;IACrBC,IAAI,CAACjC,IAAL,CAAU,CAACoB,KAAD,EAAQY,KAAK,CAACZ,KAAD,CAAb,CAAV;EACH;;EACDa,IAAI,CAACK,MAAL,IAAerC,mBAAmB,CAACC,UAAD,EAAa6B,eAAb,CAAlC;EACA,OAAOE,IAAP;AACH;;AAED,SAASM,aAAT,CAAuBrE,IAAvB,EAA6BiC,OAA7B,EAAsC;EAClC,IAAII,CAAJ;EACA,IAAIiC,EAAE,GAAGrC,OAAO,CAACmC,MAAjB;EACA,IAAIG,GAAG,GAAGtF,MAAM,CAAC,EAAD,EAAKe,IAAL,CAAhB;EACA,IAAIkD,KAAJ;EACA,IAAIsB,KAAJ;;EACA,KAAKnC,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGiC,EAAhB,EAAoB,EAAEjC,CAAtB,EAAyB;IACrBa,KAAK,GAAGjB,OAAO,CAACI,CAAD,CAAP,CAAW,CAAX,CAAR;IACAmC,KAAK,GAAGxE,IAAI,CAACkD,KAAD,CAAZ;IACAqB,GAAG,CAACrB,KAAD,CAAH,GAAajB,OAAO,CAACI,CAAD,CAAP,CAAW,CAAX,EAAcmC,KAAd,EAAqBtB,KAArB,CAAb;EACH;;EACD,OAAOqB,GAAP;AACH;;AAED,SAASE,KAAT,CAAe/E,IAAf,EAAqBuC,OAArB,EAA8B;EAC1B,IAAIyC,UAAU,GAAG,EAAjB;EACA,IAAIrC,CAAJ;EACA,IAAIiC,EAAE,GAAG5E,IAAI,CAAC0E,MAAd;EACAM,UAAU,CAACN,MAAX,GAAoBE,EAApB;;EACA,KAAKjC,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGiC,EAAhB,EAAoB,EAAEjC,CAAtB,EAAyB;IACrBqC,UAAU,CAACrC,CAAD,CAAV,GAAgBgC,aAAa,CAAC3E,IAAI,CAAC2C,CAAD,CAAL,EAAUJ,OAAV,CAA7B;EACH;;EACD,OAAOyC,UAAP;AACH;;AAED,SAASC,oBAAT,CAA8BjF,IAA9B,EAAoCE,UAApC,EAAgDgF,SAAhD,EAA2D;EACvD,IAAIvC,CAAJ;EACA,IAAIiC,EAAE,GAAG5E,IAAI,CAAC0E,MAAd;EACA,IAAII,KAAJ;;EACA,KAAKnC,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGiC,EAAhB,EAAoB,EAAEjC,CAAtB,EAAyB;IACrBmC,KAAK,GAAG9E,IAAI,CAAC2C,CAAD,CAAJ,CAAQzC,UAAR,CAAR;;IACA,IAAI/B,UAAU,CAAC2G,KAAD,CAAV,IAAqBI,SAAS,GAAGJ,KAArC,EAA4C;MACxC;IACH;EACJ;;EACD,OAAOnC,CAAP;AACH;;AAED,SAASwC,cAAT,CAAwBC,YAAxB,EAAsCC,aAAtC,EAAqDnF,UAArD,EAAiEoF,mBAAjE,EAAsF;EAClFA,mBAAmB,GAAGA,mBAAmB,IAAI,EAA7C;EACA,IAAIC,IAAI,GAAGD,mBAAmB,CAACC,IAA/B;EACA,IAAItF,MAAM,GAAG,EAAb;;EACA,IAAI,CAACsF,IAAD,IAAS,WAAWA,IAAxB,EAA8B;IAC1B;EACH;;EACDtF,MAAM,CAACoF,aAAD,CAAN,GAAwBG,MAAM,CAACF,mBAAmB,CAACG,SAApB,IAAiC,QAAlC,CAA9B;EACAxF,MAAM,CAACC,UAAD,CAAN,GAAqB,CAArB;EACA,IAAIF,IAAI,GAAGgB,UAAU,CAACoE,YAAY,CAAChF,KAAb,EAAD,EAAuB,KAAvB,EAA+B,UAASgB,CAAT,EAAY;IAC5D,OAAOA,CAAC,CAAClB,UAAD,CAAR;EACH,CAFoB,CAArB;EAGAH,cAAc,CAACC,IAAD,EAAOC,MAAP,EAAeC,UAAf,EAA2B,0BAA0BqF,IAA1B,GAAiCN,oBAAoB,CAACjF,IAAD,EAAOE,UAAP,EAAmBoF,mBAAmB,CAACJ,SAAvC,CAArD,GAAyGI,mBAAmB,CAACI,QAAxJ,CAAd;EACAzF,MAAM,CAACC,UAAD,CAAN,IAAsBkF,YAAY,CAAChD,IAAb,CAAkBnC,MAAlB,CAAtB;AACH;;AAED,SAAS0F,YAAT,CAAsB3F,IAAtB,EAA4BsC,UAA5B,EAAwC;EACpC,IAAIsD,WAAW,GAAGtD,UAAU,CAAC9B,MAAX,CAAkB,CAAlB,KAAwB8B,UAAU,CAAC9B,MAAX,CAAkB,CAAlB,EAAqBI,MAArB,CAA4B,CAA5B,CAA1C;EACA,IAAIiF,KAAK,GAAGD,WAAW,KAAK,UAAUA,WAAW,CAAC3C,IAAtB,IAA8B,eAAe2C,WAAW,CAAC3C,IAAzD,IAAiE,YAAY2C,WAAW,CAAC3C,IAA9F,CAAvB;;EACA,IAAI,CAAC4C,KAAL,EAAY;IACR;EACH;;EACDvD,UAAU,CAAC9B,MAAX,CAAkBH,OAAlB,CAA2B,UAASI,KAAT,EAAgB;IACvCA,KAAK,CAACG,MAAN,CAAaP,OAAb,CAAsB,UAASO,MAAT,EAAiB;MACnCuE,cAAc,CAACnF,IAAD,EAAOY,MAAM,CAAC2D,gBAAP,EAAP,EAAkC3D,MAAM,CAAC4D,cAAP,GAAwB,CAAxB,CAAlC,EAA8D5D,MAAM,CAACkF,UAAP,GAAoBR,mBAAlF,CAAd;IACH,CAFD;EAGH,CAJD;AAKH;;AAED,SAASS,yBAAT,CAAmCC,IAAnC,EAAyCC,UAAzC,EAAqDC,SAArD,EAAgE;EAC5D,IAAI,CAACA,SAAS,CAACF,IAAD,CAAd,EAAsB;IAClBC,UAAU,CAAC7D,IAAX,CAAgB4D,IAAhB;IACAE,SAAS,CAACF,IAAD,CAAT,GAAkB,IAAlB;EACH;AACJ;;AAED,SAASG,uBAAT,CAAiC7D,UAAjC,EAA6C;EACzC,IAAI8D,oBAAoB,GAAG,EAA3B;EACA,IAAIC,IAAI,GAAG,EAAX;EACA/D,UAAU,CAAC9B,MAAX,CAAkBH,OAAlB,CAA2B,UAASI,KAAT,EAAgB;IACvCA,KAAK,CAACG,MAAN,CAAaP,OAAb,CAAsB,UAASO,MAAT,EAAiB;MACnCmF,yBAAyB,CAACnF,MAAM,CAAC2D,gBAAP,EAAD,EAA4B6B,oBAA5B,EAAkDC,IAAlD,CAAzB;IACH,CAFD;EAGH,CAJD;EAKA,OAAOD,oBAAP;AACH;;AAED,SAAS9E,IAAT,CAAcF,CAAd,EAAiBC,CAAjB,EAAoB;EAChB,IAAI6B,MAAM,GAAG9B,CAAC,GAAGC,CAAjB;;EACA,IAAIiF,KAAK,CAACpD,MAAD,CAAT,EAAmB;IACf,IAAI,CAAC/E,UAAU,CAACiD,CAAD,CAAf,EAAoB;MAChB,OAAO,CAAP;IACH;;IACD,IAAI,CAACjD,UAAU,CAACkD,CAAD,CAAf,EAAoB;MAChB,OAAO,CAAC,CAAR;IACH;;IACD,OAAO,CAAP;EACH;;EACD,OAAO6B,MAAP;AACH;;AAED,SAASqD,cAAT,CAAwBvG,IAAxB,EAA8BqF,aAA9B,EAA6C;EACzC,OAAOrF,IAAI,CAACI,KAAL,GAAakB,IAAb,CAAmB,UAASF,CAAT,EAAYC,CAAZ,EAAe;IACrC,OAAOC,IAAI,CAACF,CAAC,CAACiE,aAAD,CAAF,EAAmBhE,CAAC,CAACgE,aAAD,CAApB,CAAX;EACH,CAFM,CAAP;AAGH;;AAED,SAASmB,cAAT,CAAwBxG,IAAxB,EAA8ByG,QAA9B,EAAwC;EACpC,OAAOzG,IAAI,CAACI,KAAL,GAAakB,IAAb,CAAkBmF,QAAlB,CAAP;AACH;;AAED,SAASC,qBAAT,CAA+BjG,KAA/B,EAAsCH,IAAtC,EAA4C;EACxCG,KAAK,CAACG,MAAN,CAAaP,OAAb,CAAsB,UAASO,MAAT,EAAiB;IACnCA,MAAM,CAAC4D,cAAP,GAAwBnE,OAAxB,CAAiC,UAASmD,KAAT,EAAgB;MAC7C/C,KAAK,CAACC,SAAN,GAAkBqC,OAAO,CAACzC,IAAI,CAACkD,KAAD,CAAL,EAAc/C,KAAK,CAACC,SAApB,CAAzB;IACH,CAFD;EAGH,CAJD;EAKA,OAAOD,KAAK,CAACC,SAAb;AACH;;AAED,SAASiG,mBAAT,CAA6B5E,UAA7B,EAAyC;EACrC,IAAIsE,IAAI,GAAG,EAAX;EACAtE,UAAU,CAAC1B,OAAX,CAAoB,UAASyE,KAAT,EAAgBnC,CAAhB,EAAmB;IACnC0D,IAAI,CAACvB,KAAD,CAAJ,GAAcnC,CAAd;EACH,CAFD;EAGA,OAAO,UAAS3C,IAAT,EAAeqF,aAAf,EAA8B;IACjC,OAAOrE,UAAU,CAAChB,IAAI,CAACI,KAAL,EAAD,EAAe,IAAf,EAAsB,UAASgB,CAAT,EAAY;MAC/C,OAAOiF,IAAI,CAACjF,CAAC,CAACiE,aAAD,CAAF,CAAX;IACH,CAFgB,CAAjB;EAGH,CAJD;AAKH;;AAED,SAASuB,QAAT,CAAkB5G,IAAlB,EAAwBsC,UAAxB,EAAoCuE,OAApC,EAA6CT,oBAA7C,EAAmE;EAC/D,IAAIU,eAAe,GAAG,EAAtB;EACA,IAAIC,UAAU,GAAGzE,UAAU,CAAC0B,gBAAX,KAAgC/E,QAAjD;EACA,IAAI+H,cAAc,GAAGD,UAAU,IAAIzE,UAAU,CAACG,eAAzB,IAA4CH,UAAU,CAACG,eAAX,CAA2BV,UAA5F;;EACA,IAAIkF,YAAY,GAAG,UAASjH,IAAT,EAAe;IAC9B,OAAOA,IAAP;EACH,CAFD;;EAGA,IAAIkH,mBAAmB,GAAGL,OAAO,CAACM,aAAlC;EACA,IAAIC,gBAAJ;;EACA,IAAI,CAACJ,cAAD,IAAmB3I,WAAW,CAAC6I,mBAAD,CAAlC,EAAyD;IACrDlH,IAAI,GAAGwG,cAAc,CAACxG,IAAD,EAAOkH,mBAAP,CAArB;EACH;;EACD,IAAIH,UAAJ,EAAgB;IACZzE,UAAU,CAACP,UAAX,GAAwBsF,aAAa,CAACrH,IAAD,EAAOoG,oBAAP,EAA6BY,cAA7B,CAArC;EACH;;EACD,IAAIA,cAAc,IAAI,CAAC3I,WAAW,CAAC6I,mBAAD,CAAZ,IAAqC5E,UAAU,CAACyB,YAAX,KAA4BjF,MAAjE,IAA2E,CAAC+H,OAAO,CAACS,oBAA1G,EAAgI;IAC5HL,YAAY,GAAGN,mBAAmB,CAACrE,UAAU,CAACP,UAAZ,CAAlC;EACH,CAFD,MAEO,IAAI,SAASmF,mBAAT,IAAgC5E,UAAU,CAACyB,YAAX,KAA4BjF,MAAhE,EAAwE;IAC3EmI,YAAY,GAAGV,cAAf;IACAa,gBAAgB,GAAGL,UAAnB;EACH;;EACDX,oBAAoB,CAAC/F,OAArB,CAA8B,UAASmD,KAAT,EAAgB;IAC1CsD,eAAe,CAACtD,KAAD,CAAf,GAAyByD,YAAY,CAACjH,IAAD,EAAOwD,KAAP,CAArC;EACH,CAFD;;EAGA,IAAI4D,gBAAJ,EAAsB;IAClB9E,UAAU,CAACP,UAAX,GAAwBO,UAAU,CAACP,UAAX,CAAsBT,IAAtB,CAA2BA,IAA3B,CAAxB;EACH;;EACD,OAAOwF,eAAP;AACH;;AAED,SAASS,kBAAT,CAA4BtB,UAA5B,EAAwCD,IAAxC,EAA8C;EAC1C,OAAO,CAAC,CAAD,KAAOC,UAAU,CAACuB,GAAX,CAAgB,UAASC,cAAT,EAAyB;IACnD,OAAOA,cAAc,CAACC,OAAf,EAAP;EACH,CAFa,EAEVC,OAFU,CAEF3B,IAAI,CAAC0B,OAAL,EAFE,CAAd;AAGH;;AAED,SAASL,aAAT,CAAuBrH,IAAvB,EAA6BoG,oBAA7B,EAAmDY,cAAnD,EAAmE;EAC/D,IAAIjF,UAAU,GAAGiF,cAAc,GAAGA,cAAc,CAAC5G,KAAf,EAAH,GAA4B,EAA3D;EACAgG,oBAAoB,CAAC/F,OAArB,CAA8B,UAASmD,KAAT,EAAgB;IAC1CxD,IAAI,CAACK,OAAL,CAAc,UAAS2F,IAAT,EAAe;MACzB,IAAI4B,QAAQ,GAAG5B,IAAI,CAACxC,KAAD,CAAnB;MACArF,UAAU,CAACyJ,QAAD,CAAV,IAAwBL,kBAAkB,CAACxF,UAAD,EAAa6F,QAAb,CAA1C,IAAoE7F,UAAU,CAACK,IAAX,CAAgBwF,QAAhB,CAApE;IACH,CAHD;EAIH,CALD;EAMA,OAAO7F,UAAP;AACH;;AAED,SAAS8F,wBAAT,CAAkCjH,MAAlC,EAA0CN,IAA1C,EAAgDgC,UAAhD,EAA4D;EACxD1B,MAAM,CAACP,OAAP,CAAgB,UAASyH,aAAT,EAAwB;IACpCxF,UAAU,CAACyB,YAAX,GAA0BhB,OAAO,CAACzC,IAAI,CAACwH,aAAa,CAACvD,gBAAd,EAAD,CAAL,EAAyCjC,UAAU,CAACyB,YAApD,CAAjC;EACH,CAFD;EAGA,OAAOzB,UAAU,CAACyB,YAAlB;AACH;;AAED,SAASgE,SAAT,CAAmB/H,IAAnB,EAAyBsC,UAAzB,EAAqC0F,mBAArC,EAA0D;EACtD,IAAIC,4BAA4B,GAAG,EAAnC;EACA,IAAIC,+BAA+B,GAAG,EAAtC;EACA,IAAIC,iBAAiB,GAAG7F,UAAU,CAACG,eAAX,IAA8BhD,cAAc,CAAC6C,UAAU,CAACG,eAAX,CAA2BsB,YAA5B,CAApE;EACA,IAAIqE,aAAJ;EACA9F,UAAU,CAAC9B,MAAX,CAAkBH,OAAlB,CAA2B,UAASI,KAAT,EAAgB;IACvC,IAAI,CAACA,KAAK,CAACG,MAAN,CAAa8D,MAAlB,EAA0B;MACtB;IACH;;IACD,IAAI2D,cAAc,GAAG5H,KAAK,CAACmC,YAAN,IAAsBnD,cAAc,CAACgB,KAAK,CAACmC,YAAN,CAAmBlC,SAApB,CAAzD;IACAD,KAAK,CAACC,SAAN,GAAkB2H,cAAlB;IACA/F,UAAU,CAACyB,YAAX,GAA0BoE,iBAA1B;IACA,CAACE,cAAD,IAAmBJ,4BAA4B,CAAC7F,IAA7B,CAAkC3B,KAAlC,CAAnB;IACA,CAAC0H,iBAAD,IAAsBD,+BAA+B,CAAC9F,IAAhC,CAAqC3B,KAArC,CAAtB;EACH,CATD;;EAUA,IAAIwH,4BAA4B,CAACvD,MAA7B,IAAuCwD,+BAA+B,CAACxD,MAA3E,EAAmF;IAC/E0D,aAAa,GAAGH,4BAA4B,CAACT,GAA7B,CAAkC,UAASc,CAAT,EAAYnI,KAAZ,EAAmB;MACjE,OAAOA,KAAP;IACH,CAFe,CAAhB;IAGAH,IAAI,CAACuI,IAAL,CAAW,UAASjI,IAAT,EAAe;MACtB,IAAIkI,SAAJ;MACAP,4BAA4B,CAAC5H,OAA7B,CAAsC,UAASI,KAAT,EAAgB6D,UAAhB,EAA4B;QAC9D,IAAIoC,qBAAqB,CAACjG,KAAD,EAAQH,IAAR,CAArB,IAAsC8H,aAAa,CAACT,OAAd,CAAsBrD,UAAtB,KAAqC,CAA/E,EAAkF;UAC9E8D,aAAa,CAACK,MAAd,CAAqBnE,UAArB,EAAiC,CAAjC;QACH;MACJ,CAJD;;MAKA,IAAI,CAACkE,SAAL,EAAgB;QACZN,+BAA+B,CAAC7H,OAAhC,CAAyC,UAASI,KAAT,EAAgB;UACrD+H,SAAS,GAAGX,wBAAwB,CAACpH,KAAK,CAACG,MAAP,EAAeN,IAAf,EAAqBgC,UAArB,CAApC;QACH,CAFD;MAGH;;MACD,IAAI,CAAC0F,mBAAD,IAAwBQ,SAAxB,IAAqC,MAAMJ,aAAa,CAAC1D,MAA7D,EAAqE;QACjE,OAAO,IAAP;MACH;IACJ,CAfD;EAgBH;AACJ;;AAED,SAASgE,aAAT,CAAuBpG,UAAvB,EAAmCgB,gBAAnC,EAAqD;EACjD,IAAIb,eAAe,GAAGH,UAAU,CAACG,eAAX,IAA8B,EAApD;EACA,IAAIkG,sBAAsB,GAAGlG,eAAe,IAAIA,eAAe,CAACV,UAAnC,IAAiD,EAA9E;EACA,IAAIiC,gBAAgB,GAAGb,eAAe,CAACb,UAAU,CAACyB,YAAZ,EAA0BtB,eAAe,CAACQ,IAA1C,EAAgD,CAAC,CAAC0F,sBAAsB,CAACjE,MAAzE,EAAiFpB,gBAAjF,CAAtC;EACAhB,UAAU,CAAC9B,MAAX,CAAkBH,OAAlB,CAA2B,UAASI,KAAT,EAAgB;IACvC,IAAImC,YAAY,GAAGnC,KAAK,CAACmC,YAAN,IAAsB,EAAzC;IACA,IAAIgG,eAAe,GAAGhG,YAAY,CAACb,UAAb,IAA2B,EAAjD;IACA,IAAIpB,aAAa,GAAGwC,eAAe,CAAC1C,KAAK,CAACC,SAAP,EAAkBkC,YAAY,CAACK,IAA/B,EAAqC,CAAC,CAAC2F,eAAe,CAAClE,MAAvD,EAA+DpB,gBAA/D,CAAnC;IACA7C,KAAK,CAACG,MAAN,CAAaP,OAAb,CAAsB,UAASO,MAAT,EAAiB;MACnC,IAAIiI,aAAa,GAAG,EAApB;MACAA,aAAa,CAAC7E,gBAAd,GAAiCA,gBAAjC;MACA6E,aAAa,CAAClI,aAAd,GAA8BA,aAA9B;MACA2B,UAAU,CAAC0B,gBAAX,GAA8B1B,UAAU,CAAC0B,gBAAX,IAA+B6E,aAAa,CAAC7E,gBAA3E;MACAvD,KAAK,CAACE,aAAN,GAAsBF,KAAK,CAACE,aAAN,IAAuBkI,aAAa,CAAClI,aAA3D;MACAkI,aAAa,CAAC9E,YAAd,GAA6BzB,UAAU,CAACyB,YAAxC;MACA8E,aAAa,CAACnI,SAAd,GAA0BD,KAAK,CAACC,SAAhC;MACAmI,aAAa,CAACC,QAAd,GAAyBlG,YAAY,CAACkG,QAAtC;MACAlI,MAAM,CAACC,cAAP,CAAsBgI,aAAtB;IACH,CAVD;IAWApI,KAAK,CAACE,aAAN,GAAsBF,KAAK,CAACE,aAAN,IAAuBA,aAA7C;;IACA,IAAIF,KAAK,CAACK,SAAV,EAAqB;MACjBL,KAAK,CAACK,SAAN,CAAgBiI,QAAhB,CAAyBtI,KAAK,CAACE,aAA/B,EAA8CF,KAAK,CAACC,SAApD,EAA+DrB,UAA/D;MACAoB,KAAK,CAACK,SAAN,CAAgBkI,QAAhB;IACH;EACJ,CApBD;EAqBA1G,UAAU,CAAC0B,gBAAX,GAA8B1B,UAAU,CAAC0B,gBAAX,IAA+BA,gBAA7D;;EACA,IAAI1B,UAAU,CAAC2G,YAAf,EAA6B;IACzB3G,UAAU,CAAC2G,YAAX,CAAwB5I,OAAxB,CAAiC,UAASwB,IAAT,EAAe;MAC5CA,IAAI,CAACkH,QAAL,CAAczG,UAAU,CAAC0B,gBAAzB,EAA2C1B,UAAU,CAACyB,YAAtD,EAAoEzE,aAApE;MACAuC,IAAI,CAACmH,QAAL;IACH,CAHD;EAIH;AACJ;;AAED,SAASE,UAAT,CAAoBC,MAApB,EAA4B7F,gBAA5B,EAA8C;EAC1C,IAAItD,IAAI,GAAG,EAAX;;EACA,IAAIoJ,eAAe,GAAGjL,UAAU,CAACgL,MAAD,CAAhC;;EACA,IAAIE,QAAQ,GAAGD,eAAe,IAAI,CAACxJ,QAAQ,CAACuJ,MAAD,CAA3C;EACA,IAAIxG,CAAJ;EACA,IAAIiC,EAAJ;EACA,IAAI0E,CAAJ;EACA,IAAItD,IAAJ;;EACA,IAAIoD,eAAe,IAAI,CAACC,QAAxB,EAAkC;IAC9B,KAAK1G,CAAC,GAAG,CAAJ,EAAOiC,EAAE,GAAGuE,MAAM,CAACzE,MAAnB,EAA2B4E,CAAC,GAAG,CAApC,EAAuC3G,CAAC,GAAGiC,EAA3C,EAA+C,EAAEjC,CAAjD,EAAoD;MAChDqD,IAAI,GAAGmD,MAAM,CAACxG,CAAD,CAAb;;MACA,IAAI9D,SAAS,CAACmH,IAAD,CAAb,EAAqB;QACjBhG,IAAI,CAACsJ,CAAC,EAAF,CAAJ,GAAYtD,IAAZ;MACH,CAFD,MAEO,IAAIA,IAAJ,EAAU;QACbqD,QAAQ,GAAG,IAAX;MACH;IACJ;EACJ;;EACD,IAAIA,QAAJ,EAAc;IACV/F,gBAAgB,CAAC,OAAD,CAAhB;EACH;;EACD,OAAOtD,IAAP;AACH;;AACD,OAAO,SAASuJ,YAAT,CAAsBvJ,IAAtB,EAA4BsC,UAA5B,EAAwCgB,gBAAxC,EAA0DuD,OAA1D,EAAmE;EACtE7G,IAAI,GAAGkJ,UAAU,CAAClJ,IAAD,EAAOsD,gBAAP,CAAjB;EACAhB,UAAU,CAACyB,YAAX,GAA0BzB,UAAU,CAAC0B,gBAAX,GAA8B,IAAxD;EACAzD,aAAa,CAAC+B,UAAU,CAAC9B,MAAZ,CAAb;EACAmB,iBAAiB,CAACW,UAAU,CAAC2G,YAAZ,CAAjB;EACAlB,SAAS,CAAC/H,IAAD,EAAOsC,UAAP,EAAmBuE,OAAO,CAACmB,mBAA3B,CAAT;EACAU,aAAa,CAACpG,UAAD,EAAagB,gBAAb,CAAb;;EACA,IAAIuD,OAAO,CAAC2C,qBAAZ,EAAmC;IAC/BxJ,IAAI,GAAG+E,KAAK,CAAC/E,IAAD,EAAO6D,cAAc,CAACvB,UAAD,EAAagB,gBAAb,CAArB,CAAZ;EACH;;EACDqC,YAAY,CAAC3F,IAAD,EAAOsC,UAAP,CAAZ;EACA,IAAImH,oBAAoB,GAAG7C,QAAQ,CAAC5G,IAAD,EAAOsC,UAAP,EAAmBuE,OAAnB,EAA4BV,uBAAuB,CAAC7D,UAAD,CAAnD,CAAnC;EACA,OAAOmH,oBAAP;AACH"},"metadata":{},"sourceType":"module"}