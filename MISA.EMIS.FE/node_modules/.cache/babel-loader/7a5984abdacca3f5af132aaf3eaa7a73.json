{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/axes/xy_axes.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { Range } from \"../translators/range\";\nimport formatHelper from \"../../format_helper\";\nimport dateUtils from \"../../core/utils/date\";\nimport { extend } from \"../../core/utils/extend\";\nimport { generateDateBreaks } from \"./datetime_breaks\";\nimport { noop } from \"../../core/utils/common\";\nimport { getLog, patchFontOptions, getCosAndSin } from \"../core/utils\";\nimport { isDefined } from \"../../core/utils/type\";\nimport constants from \"./axes_constants\";\nvar getNextDateUnit = dateUtils.getNextDateUnit;\nvar correctDateWithUnitBeginning = dateUtils.correctDateWithUnitBeginning;\nvar _math = Math;\nvar _max = _math.max;\nvar TOP = constants.top;\nvar BOTTOM = constants.bottom;\nvar LEFT = constants.left;\nvar RIGHT = constants.right;\nvar CENTER = constants.center;\nvar SCALE_BREAK_OFFSET = 3;\nvar RANGE_RATIO = .3;\nvar WAVED_LINE_CENTER = 2;\nvar WAVED_LINE_TOP = 0;\nvar WAVED_LINE_BOTTOM = 4;\nvar WAVED_LINE_LENGTH = 24;\nvar TICKS_CORRECTIONS = {\n  left: -1,\n  top: -1,\n  right: 0,\n  bottom: 0,\n  center: -.5\n};\n\nfunction prepareDatesDifferences(datesDifferences, tickInterval) {\n  var dateUnitInterval;\n  var i;\n\n  if (\"week\" === tickInterval) {\n    tickInterval = \"day\";\n  }\n\n  if (\"quarter\" === tickInterval) {\n    tickInterval = \"month\";\n  }\n\n  if (datesDifferences[tickInterval]) {\n    for (i = 0; i < dateUtils.dateUnitIntervals.length; i++) {\n      dateUnitInterval = dateUtils.dateUnitIntervals[i];\n\n      if (datesDifferences[dateUnitInterval]) {\n        datesDifferences[dateUnitInterval] = false;\n        datesDifferences.count--;\n      }\n\n      if (dateUnitInterval === tickInterval) {\n        break;\n      }\n    }\n  }\n}\n\nfunction sortingBreaks(breaks) {\n  return breaks.sort(function (a, b) {\n    return a.from - b.from;\n  });\n}\n\nfunction getMarkerDates(min, max, markerInterval) {\n  var origMin = min;\n  var dates;\n  min = correctDateWithUnitBeginning(min, markerInterval);\n  max = correctDateWithUnitBeginning(max, markerInterval);\n  dates = dateUtils.getSequenceByInterval(min, max, markerInterval);\n\n  if (dates.length && origMin > dates[0]) {\n    dates = dates.slice(1);\n  }\n\n  return dates;\n}\n\nfunction getStripHorizontalAlignmentPosition(alignment) {\n  var position = \"start\";\n\n  if (\"center\" === alignment) {\n    position = \"center\";\n  }\n\n  if (\"right\" === alignment) {\n    position = \"end\";\n  }\n\n  return position;\n}\n\nfunction getStripVerticalAlignmentPosition(alignment) {\n  var position = \"start\";\n\n  if (\"center\" === alignment) {\n    position = \"center\";\n  }\n\n  if (\"bottom\" === alignment) {\n    position = \"end\";\n  }\n\n  return position;\n}\n\nfunction getMarkerInterval(tickInterval) {\n  var markerInterval = getNextDateUnit(tickInterval);\n\n  if (\"quarter\" === markerInterval) {\n    markerInterval = getNextDateUnit(markerInterval);\n  }\n\n  return markerInterval;\n}\n\nfunction getMarkerFormat(curDate, prevDate, tickInterval, markerInterval) {\n  var format = markerInterval;\n  var datesDifferences = prevDate && dateUtils.getDatesDifferences(prevDate, curDate);\n\n  if (prevDate && \"year\" !== tickInterval) {\n    prepareDatesDifferences(datesDifferences, tickInterval);\n    format = formatHelper.getDateFormatByDifferences(datesDifferences);\n  }\n\n  return format;\n}\n\nfunction getMaxSide(act, boxes) {\n  return boxes.reduce(function (prevValue, box) {\n    return _max(prevValue, act(box));\n  }, 0);\n}\n\nfunction getDistanceByAngle(bBox, rotationAngle) {\n  rotationAngle = _math.abs(rotationAngle);\n  rotationAngle = rotationAngle % 180 >= 90 ? 90 - rotationAngle % 90 : rotationAngle % 90;\n  var a = rotationAngle * (_math.PI / 180);\n\n  if (a >= _math.atan(bBox.height / bBox.width)) {\n    return bBox.height / _math.abs(_math.sin(a));\n  } else {\n    return bBox.width;\n  }\n}\n\nfunction getMaxConstantLinePadding(constantLines) {\n  return constantLines.reduce(function (padding, options) {\n    return _max(padding, options.paddingTopBottom);\n  }, 0);\n}\n\nfunction getConstantLineLabelMarginForVerticalAlignment(constantLines, alignment, labelHeight) {\n  return constantLines.some(function (options) {\n    return options.label.verticalAlignment === alignment;\n  }) && labelHeight || 0;\n}\n\nfunction getLeftMargin(bBox) {\n  return _math.abs(bBox.x) || 0;\n}\n\nfunction getRightMargin(bBox) {\n  return _math.abs(bBox.width - _math.abs(bBox.x)) || 0;\n}\n\nfunction generateRangesOnPoints(points, edgePoints, getRange) {\n  var i;\n  var length;\n  var maxRange = null;\n  var ranges = [];\n  var curValue;\n  var prevValue;\n  var curRange;\n\n  for (i = 1, length = points.length; i < length; i++) {\n    curValue = points[i];\n    prevValue = points[i - 1];\n    curRange = getRange(curValue, prevValue);\n\n    if (edgePoints.indexOf(curValue) >= 0) {\n      if (!maxRange || curRange > maxRange.length) {\n        maxRange = {\n          start: curValue,\n          end: prevValue,\n          length: curRange\n        };\n      }\n    } else {\n      if (maxRange && curRange < maxRange.length) {\n        ranges.push(maxRange);\n      } else {\n        ranges.push({\n          start: curValue,\n          end: prevValue,\n          length: curRange\n        });\n      }\n\n      maxRange = null;\n    }\n  }\n\n  if (maxRange) {\n    ranges.push(maxRange);\n  }\n\n  return ranges;\n}\n\nfunction generateAutoBreaks(_ref, series, _ref2) {\n  var {\n    logarithmBase: logarithmBase,\n    type: type,\n    maxAutoBreakCount: maxAutoBreakCount\n  } = _ref;\n  var {\n    minVisible: minVisible,\n    maxVisible: maxVisible\n  } = _ref2;\n  var breaks = [];\n  var getRange = \"logarithmic\" === type ? (min, max) => getLog(max / min, logarithmBase) : (min, max) => max - min;\n  var visibleRange = getRange(minVisible, maxVisible);\n  var points = series.reduce((result, s) => {\n    var points = s.getPointsInViewPort();\n    result[0] = result[0].concat(points[0]);\n    result[1] = result[1].concat(points[1]);\n    return result;\n  }, [[], []]);\n  var sortedAllPoints = points[0].concat(points[1]).sort((a, b) => b - a);\n  var edgePoints = points[1].filter(p => points[0].indexOf(p) < 0);\n  var minDiff = RANGE_RATIO * visibleRange;\n  var ranges = generateRangesOnPoints(sortedAllPoints, edgePoints, getRange).sort((a, b) => b.length - a.length);\n  var epsilon = _math.min.apply(null, ranges.map(r => r.length)) / 1e3;\n\n  var _maxAutoBreakCount = isDefined(maxAutoBreakCount) ? _math.min(maxAutoBreakCount, ranges.length) : ranges.length;\n\n  for (var i = 0; i < _maxAutoBreakCount; i++) {\n    if (ranges[i].length >= minDiff) {\n      if (visibleRange <= ranges[i].length) {\n        break;\n      }\n\n      visibleRange -= ranges[i].length;\n\n      if (visibleRange > epsilon || visibleRange < -epsilon) {\n        breaks.push({\n          from: ranges[i].start,\n          to: ranges[i].end\n        });\n        minDiff = RANGE_RATIO * visibleRange;\n      }\n    } else {\n      break;\n    }\n  }\n\n  sortingBreaks(breaks);\n  return breaks;\n}\n\nexport default {\n  linear: {\n    _getStep: function (boxes, rotationAngle) {\n      var spacing = this._options.label.minSpacing;\n      var func = this._isHorizontal ? function (box) {\n        return box.width + spacing;\n      } : function (box) {\n        return box.height;\n      };\n      var maxLabelLength = getMaxSide(func, boxes);\n\n      if (rotationAngle) {\n        maxLabelLength = getDistanceByAngle({\n          width: maxLabelLength,\n          height: this._getMaxLabelHeight(boxes, 0)\n        }, rotationAngle);\n      }\n\n      return constants.getTicksCountInRange(this._majorTicks, this._isHorizontal ? \"x\" : \"y\", maxLabelLength);\n    },\n    _getMaxLabelHeight: function (boxes, spacing) {\n      return getMaxSide(function (box) {\n        return box.height;\n      }, boxes) + spacing;\n    },\n    _validateOverlappingMode: function (mode, displayMode) {\n      if (this._isHorizontal && (\"rotate\" === displayMode || \"stagger\" === displayMode) || !this._isHorizontal) {\n        return constants.validateOverlappingMode(mode);\n      }\n\n      return mode;\n    },\n    _validateDisplayMode: function (mode) {\n      return this._isHorizontal ? mode : \"standard\";\n    },\n    getMarkerTrackers: function () {\n      return this._markerTrackers;\n    },\n    _getSharpParam: function (opposite) {\n      return this._isHorizontal ^ opposite ? \"h\" : \"v\";\n    },\n    _createAxisElement: function () {\n      return this._renderer.path([], \"line\");\n    },\n    _updateAxisElementPosition: function () {\n      var axisCoord = this._axisPosition;\n\n      var canvas = this._getCanvasStartEnd();\n\n      this._axisElement.attr({\n        points: this._isHorizontal ? [canvas.start, axisCoord, canvas.end, axisCoord] : [axisCoord, canvas.start, axisCoord, canvas.end]\n      });\n    },\n    _getTranslatedCoord: function (value, offset) {\n      return this._translator.translate(value, offset);\n    },\n\n    _initAxisPositions() {\n      if (this.customPositionIsAvailable()) {\n        this._customBoundaryPosition = this.getCustomBoundaryPosition();\n      }\n\n      if (!this.customPositionIsAvailable() || this.customPositionIsBoundary()) {\n        this._axisPosition = this.getPredefinedPosition(this.getResolvedBoundaryPosition());\n      } else {\n        this._axisPosition = this.getCustomPosition();\n      }\n    },\n\n    _getTickMarkPoints(coords, length, tickOptions) {\n      var isHorizontal = this._isHorizontal;\n      var tickOrientation = this._options.tickOrientation;\n      var labelPosition = this._options.label.position;\n      var tickStartCoord;\n\n      if (isDefined(tickOrientation)) {\n        tickStartCoord = TICKS_CORRECTIONS[tickOrientation] * length;\n      } else {\n        var shift = tickOptions.shift || 0;\n\n        if (!isHorizontal && labelPosition === LEFT || isHorizontal && labelPosition !== BOTTOM) {\n          shift = -shift;\n        }\n\n        tickStartCoord = shift + this.getTickStartPositionShift(length);\n      }\n\n      return [coords.x + (isHorizontal ? 0 : tickStartCoord), coords.y + (isHorizontal ? tickStartCoord : 0), coords.x + (isHorizontal ? 0 : tickStartCoord + length), coords.y + (isHorizontal ? tickStartCoord + length : 0)];\n    },\n\n    getTickStartPositionShift(length) {\n      var width = this._options.width;\n      var position = this.getResolvedBoundaryPosition();\n      return length % 2 === 1 ? width % 2 === 0 && (position === LEFT || position === TOP) || width % 2 === 1 && (position === RIGHT || position === BOTTOM) && !this.hasNonBoundaryPosition() ? Math.floor(-length / 2) : -Math.floor(length / 2) : -length / 2 + (width % 2 === 0 ? 0 : position === BOTTOM || position === RIGHT ? -1 : 1);\n    },\n\n    _getTitleCoords: function () {\n      var horizontal = this._isHorizontal;\n      var x = this._axisPosition;\n      var y = this._axisPosition;\n      var align = this._options.title.alignment;\n\n      var canvas = this._getCanvasStartEnd();\n\n      var fromStartToEnd = horizontal || this._options.position === LEFT;\n      var canvasStart = fromStartToEnd ? canvas.start : canvas.end;\n      var canvasEnd = fromStartToEnd ? canvas.end : canvas.start;\n      var coord = align === LEFT ? canvasStart : align === RIGHT ? canvasEnd : canvas.start + (canvas.end - canvas.start) / 2;\n\n      if (horizontal) {\n        x = coord;\n      } else {\n        y = coord;\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    },\n    _drawTitleText: function (group, coords) {\n      var options = this._options;\n      var titleOptions = options.title;\n      var attrs = {\n        opacity: titleOptions.opacity,\n        align: titleOptions.alignment,\n        class: titleOptions.cssClass\n      };\n\n      if (!titleOptions.text || !group) {\n        return;\n      }\n\n      coords = coords || this._getTitleCoords();\n\n      if (!this._isHorizontal) {\n        attrs.rotate = options.position === LEFT ? 270 : 90;\n      }\n\n      var text = this._renderer.text(titleOptions.text, coords.x, coords.y).css(patchFontOptions(titleOptions.font)).attr(attrs).append(group);\n\n      this._checkTitleOverflow(text);\n\n      return text;\n    },\n    _updateTitleCoords: function () {\n      this._title && this._title.element.attr(this._getTitleCoords());\n    },\n    _drawTitle: function () {\n      var title = this._drawTitleText(this._axisTitleGroup);\n\n      if (title) {\n        this._title = {\n          element: title\n        };\n      }\n    },\n    _measureTitle: function () {\n      if (this._title) {\n        if (this._title.bBox && !this._title.originalSize) {\n          this._title.originalSize = this._title.bBox;\n        }\n\n        this._title.bBox = this._title.element.getBBox();\n      }\n    },\n    _drawDateMarker: function (date, options, range) {\n      var markerOptions = this._options.marker;\n\n      var invert = this._translator.getBusinessRange().invert;\n\n      var textIndent = markerOptions.width + markerOptions.textLeftIndent;\n      var pathElement;\n\n      if (null === options.x) {\n        return;\n      }\n\n      if (!options.withoutStick) {\n        pathElement = this._renderer.path([options.x, options.y, options.x, options.y + markerOptions.separatorHeight], \"line\").attr({\n          \"stroke-width\": markerOptions.width,\n          stroke: markerOptions.color,\n          \"stroke-opacity\": markerOptions.opacity,\n          sharp: \"h\"\n        }).append(this._axisElementsGroup);\n      }\n\n      var text = String(this.formatLabel(date, options.labelOptions, range));\n      return {\n        date: date,\n        x: options.x,\n        y: options.y,\n        cropped: options.withoutStick,\n        label: this._renderer.text(text, options.x, options.y).css(patchFontOptions(markerOptions.label.font)).append(this._axisElementsGroup),\n        line: pathElement,\n\n        getContentContainer() {\n          return this.label;\n        },\n\n        getEnd: function () {\n          return this.x + (invert ? -1 : 1) * (textIndent + this.labelBBox.width);\n        },\n        setTitle: function () {\n          this.title = text;\n        },\n        hideLabel: function () {\n          this.label.dispose();\n          this.label = null;\n          this.title = text;\n        },\n        hide: function () {\n          if (pathElement) {\n            pathElement.dispose();\n            pathElement = null;\n          }\n\n          this.label.dispose();\n          this.label = null;\n          this.hidden = true;\n        }\n      };\n    },\n    _drawDateMarkers: function () {\n      var that = this;\n      var options = that._options;\n      var translator = that._translator;\n\n      var viewport = that._getViewportRange();\n\n      var minBound = viewport.minVisible;\n      var dateMarkers = [];\n      var dateMarker;\n\n      function draw(markerDate, format, withoutStick) {\n        return that._drawDateMarker(markerDate, {\n          x: translator.translate(markerDate),\n          y: markersAreaTop,\n          labelOptions: that._getLabelFormatOptions(format),\n          withoutStick: withoutStick\n        }, viewport);\n      }\n\n      if (viewport.isEmpty() || !options.marker.visible || \"datetime\" !== options.argumentType || \"discrete\" === options.type || that._majorTicks.length <= 1) {\n        return [];\n      }\n\n      var markersAreaTop = that._axisPosition + options.marker.topIndent;\n      var tickInterval = dateUtils.getDateUnitInterval(this._tickInterval);\n      var markerInterval = getMarkerInterval(tickInterval);\n      var markerDates = getMarkerDates(minBound, viewport.maxVisible, markerInterval);\n\n      if (markerDates.length > 1 || 1 === markerDates.length && minBound < markerDates[0]) {\n        dateMarkers = markerDates.reduce(function (markers, curDate, i, dates) {\n          var marker = draw(curDate, getMarkerFormat(curDate, dates[i - 1] || minBound < curDate && minBound, tickInterval, markerInterval));\n          marker && markers.push(marker);\n          return markers;\n        }, []);\n\n        if (minBound < markerDates[0]) {\n          dateMarker = draw(minBound, getMarkerFormat(minBound, markerDates[0], tickInterval, markerInterval), true);\n          dateMarker && dateMarkers.unshift(dateMarker);\n        }\n      }\n\n      return dateMarkers;\n    },\n    _adjustDateMarkers: function (offset) {\n      offset = offset || 0;\n      var that = this;\n      var markerOptions = this._options.marker;\n      var textIndent = markerOptions.width + markerOptions.textLeftIndent;\n\n      var invert = this._translator.getBusinessRange().invert;\n\n      var canvas = that._getCanvasStartEnd();\n\n      var dateMarkers = this._dateMarkers;\n\n      if (!dateMarkers.length) {\n        return offset;\n      }\n\n      if (dateMarkers[0].cropped) {\n        if (!this._checkMarkersPosition(invert, dateMarkers[1], dateMarkers[0])) {\n          dateMarkers[0].hideLabel();\n        }\n      }\n\n      var prevDateMarker;\n      dateMarkers.forEach(function (marker, i, markers) {\n        if (marker.cropped) {\n          return;\n        }\n\n        if (invert ? marker.getEnd() < canvas.end : marker.getEnd() > canvas.end) {\n          marker.hideLabel();\n        } else if (that._checkMarkersPosition(invert, marker, prevDateMarker)) {\n          prevDateMarker = marker;\n        } else {\n          marker.hide();\n        }\n      });\n\n      this._dateMarkers.forEach(function (marker) {\n        if (marker.label) {\n          var labelBBox = marker.labelBBox;\n          var dy = marker.y + markerOptions.textTopIndent - labelBBox.y;\n          marker.label.attr({\n            translateX: invert ? marker.x - textIndent - labelBBox.x - labelBBox.width : marker.x + textIndent - labelBBox.x,\n            translateY: dy + offset\n          });\n        }\n\n        if (marker.line) {\n          marker.line.attr({\n            translateY: offset\n          });\n        }\n      });\n\n      that._initializeMarkersTrackers(offset);\n\n      return offset + markerOptions.topIndent + markerOptions.separatorHeight;\n    },\n    _checkMarkersPosition: function (invert, dateMarker, prevDateMarker) {\n      if (void 0 === prevDateMarker) {\n        return true;\n      }\n\n      return invert ? dateMarker.x < prevDateMarker.getEnd() : dateMarker.x > prevDateMarker.getEnd();\n    },\n    _initializeMarkersTrackers: function (offset) {\n      var separatorHeight = this._options.marker.separatorHeight;\n      var renderer = this._renderer;\n\n      var businessRange = this._translator.getBusinessRange();\n\n      var canvas = this._getCanvasStartEnd();\n\n      var group = this._axisElementsGroup;\n      this._markerTrackers = this._dateMarkers.filter(function (marker) {\n        return !marker.hidden;\n      }).map(function (marker, i, markers) {\n        var nextMarker = markers[i + 1] || {\n          x: canvas.end,\n          date: businessRange.max\n        };\n        var x = marker.x;\n        var y = marker.y + offset;\n        var markerTracker = renderer.path([x, y, x, y + separatorHeight, nextMarker.x, y + separatorHeight, nextMarker.x, y, x, y], \"area\").attr({\n          \"stroke-width\": 1,\n          stroke: \"grey\",\n          fill: \"grey\",\n          opacity: 1e-4\n        }).append(group);\n        markerTracker.data(\"range\", {\n          startValue: marker.date,\n          endValue: nextMarker.date\n        });\n\n        if (marker.title) {\n          markerTracker.setTitle(marker.title);\n        }\n\n        return markerTracker;\n      });\n    },\n    _getLabelFormatOptions: function (formatString) {\n      var markerLabelOptions = this._markerLabelOptions;\n\n      if (!markerLabelOptions) {\n        this._markerLabelOptions = markerLabelOptions = extend(true, {}, this._options.marker.label);\n      }\n\n      if (!isDefined(this._options.marker.label.format)) {\n        markerLabelOptions.format = formatString;\n      }\n\n      return markerLabelOptions;\n    },\n    _adjustConstantLineLabels: function (constantLines) {\n      var that = this;\n      var axisPosition = that._options.position;\n      var canvas = that.getCanvas();\n      var canvasLeft = canvas.left;\n      var canvasRight = canvas.width - canvas.right;\n      var canvasTop = canvas.top;\n      var canvasBottom = canvas.height - canvas.bottom;\n      var verticalCenter = canvasTop + (canvasBottom - canvasTop) / 2;\n      var horizontalCenter = canvasLeft + (canvasRight - canvasLeft) / 2;\n      var maxLabel = 0;\n      constantLines.forEach(function (item) {\n        var isHorizontal = that._isHorizontal;\n        var linesOptions = item.options;\n        var paddingTopBottom = linesOptions.paddingTopBottom;\n        var paddingLeftRight = linesOptions.paddingLeftRight;\n        var labelOptions = linesOptions.label;\n        var labelVerticalAlignment = labelOptions.verticalAlignment;\n        var labelHorizontalAlignment = labelOptions.horizontalAlignment;\n        var labelIsInside = \"inside\" === labelOptions.position;\n        var label = item.label;\n        var box = item.labelBBox;\n        var translateX;\n        var translateY;\n\n        if (null === label || box.isEmpty) {\n          return;\n        }\n\n        if (isHorizontal) {\n          if (labelIsInside) {\n            if (labelHorizontalAlignment === LEFT) {\n              translateX = item.coord - paddingLeftRight - box.x - box.width;\n            } else {\n              translateX = item.coord + paddingLeftRight - box.x;\n            }\n\n            switch (labelVerticalAlignment) {\n              case CENTER:\n                translateY = verticalCenter - box.y - box.height / 2;\n                break;\n\n              case BOTTOM:\n                translateY = canvasBottom - paddingTopBottom - box.y - box.height;\n                break;\n\n              default:\n                translateY = canvasTop + paddingTopBottom - box.y;\n            }\n          } else {\n            if (axisPosition === labelVerticalAlignment) {\n              maxLabel = _max(maxLabel, box.height + paddingTopBottom);\n            }\n\n            translateX = item.coord - box.x - box.width / 2;\n\n            if (labelVerticalAlignment === BOTTOM) {\n              translateY = canvasBottom + paddingTopBottom - box.y;\n            } else {\n              translateY = canvasTop - paddingTopBottom - box.y - box.height;\n            }\n          }\n        } else if (labelIsInside) {\n          if (labelVerticalAlignment === BOTTOM) {\n            translateY = item.coord + paddingTopBottom - box.y;\n          } else {\n            translateY = item.coord - paddingTopBottom - box.y - box.height;\n          }\n\n          switch (labelHorizontalAlignment) {\n            case CENTER:\n              translateX = horizontalCenter - box.x - box.width / 2;\n              break;\n\n            case RIGHT:\n              translateX = canvasRight - paddingLeftRight - box.x - box.width;\n              break;\n\n            default:\n              translateX = canvasLeft + paddingLeftRight - box.x;\n          }\n        } else {\n          if (axisPosition === labelHorizontalAlignment) {\n            maxLabel = _max(maxLabel, box.width + paddingLeftRight);\n          }\n\n          translateY = item.coord - box.y - box.height / 2;\n\n          if (labelHorizontalAlignment === RIGHT) {\n            translateX = canvasRight + paddingLeftRight - box.x;\n          } else {\n            translateX = canvasLeft - paddingLeftRight - box.x - box.width;\n          }\n        }\n\n        label.attr({\n          translateX: translateX,\n          translateY: translateY\n        });\n      });\n      return maxLabel;\n    },\n    _drawConstantLinesForEstimating: function (constantLines) {\n      var that = this;\n      var renderer = this._renderer;\n      var group = renderer.g();\n      constantLines.forEach(function (options) {\n        that._drawConstantLineLabelText(options.label.text, 0, 0, options.label, group).attr({\n          align: \"center\"\n        });\n      });\n      return group.append(renderer.root);\n    },\n    _estimateLabelHeight: function (bBox, labelOptions) {\n      var height = bBox.height;\n      var drawingType = labelOptions.drawingType;\n\n      if (\"stagger\" === this._validateDisplayMode(drawingType) || \"stagger\" === this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType)) {\n        height = 2 * height + labelOptions.staggeringSpacing;\n      }\n\n      if (\"rotate\" === this._validateDisplayMode(drawingType) || \"rotate\" === this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType)) {\n        var sinCos = getCosAndSin(labelOptions.rotationAngle);\n        height = height * sinCos.cos + bBox.width * sinCos.sin;\n      }\n\n      return height && (height + labelOptions.indentFromAxis || 0) || 0;\n    },\n    estimateMargins: function (canvas) {\n      this.updateCanvas(canvas);\n\n      var range = this._getViewportRange();\n\n      var ticksData = this._createTicksAndLabelFormat(range);\n\n      var ticks = ticksData.ticks;\n      var tickInterval = ticksData.tickInterval;\n      var options = this._options;\n\n      var constantLineOptions = this._outsideConstantLines.filter(l => l.labelOptions.visible).map(l => l.options);\n\n      var rootElement = this._renderer.root;\n      var labelIsVisible = options.label.visible && !range.isEmpty() && ticks.length;\n      var labelValue = labelIsVisible && this.formatLabel(ticks[ticks.length - 1], options.label, void 0, void 0, tickInterval, ticks);\n\n      var labelElement = labelIsVisible && this._renderer.text(labelValue, 0, 0).css(this._textFontStyles).attr(this._textOptions).append(rootElement);\n\n      var titleElement = this._drawTitleText(rootElement, {\n        x: 0,\n        y: 0\n      });\n\n      var constantLinesLabelsElement = this._drawConstantLinesForEstimating(constantLineOptions);\n\n      var labelBox = !options.label.template && labelElement && labelElement.getBBox() || {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n      var titleBox = titleElement && titleElement.getBBox() || {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n      var constantLinesBox = constantLinesLabelsElement.getBBox();\n      var titleHeight = titleBox.height ? titleBox.height + options.title.margin : 0;\n\n      var labelHeight = this._estimateLabelHeight(labelBox, options.label);\n\n      var constantLinesHeight = constantLinesBox.height ? constantLinesBox.height + getMaxConstantLinePadding(constantLineOptions) : 0;\n      var height = labelHeight + titleHeight;\n      var margins = {\n        left: _max(getLeftMargin(labelBox), getLeftMargin(constantLinesBox)),\n        right: _max(getRightMargin(labelBox), getRightMargin(constantLinesBox)),\n        top: (\"top\" === options.position ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, \"top\", constantLinesHeight),\n        bottom: (\"top\" !== options.position ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, \"bottom\", constantLinesHeight)\n      };\n      labelElement && labelElement.remove();\n      titleElement && titleElement.remove();\n      constantLinesLabelsElement && constantLinesLabelsElement.remove();\n      return margins;\n    },\n    _checkAlignmentConstantLineLabels: function (labelOptions) {\n      var position = labelOptions.position;\n      var verticalAlignment = (labelOptions.verticalAlignment || \"\").toLowerCase();\n      var horizontalAlignment = (labelOptions.horizontalAlignment || \"\").toLowerCase();\n\n      if (this._isHorizontal) {\n        if (\"outside\" === position) {\n          verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;\n          horizontalAlignment = CENTER;\n        } else {\n          verticalAlignment = verticalAlignment === CENTER ? CENTER : verticalAlignment === BOTTOM ? BOTTOM : TOP;\n          horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT;\n        }\n      } else if (\"outside\" === position) {\n        verticalAlignment = CENTER;\n        horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT;\n      } else {\n        verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;\n        horizontalAlignment = horizontalAlignment === RIGHT ? RIGHT : horizontalAlignment === CENTER ? CENTER : LEFT;\n      }\n\n      labelOptions.verticalAlignment = verticalAlignment;\n      labelOptions.horizontalAlignment = horizontalAlignment;\n    },\n    _getConstantLineLabelsCoords: function (value, lineLabelOptions) {\n      var x = value;\n      var y = value;\n\n      if (this._isHorizontal) {\n        y = this._orthogonalPositions[\"top\" === lineLabelOptions.verticalAlignment ? \"start\" : \"end\"];\n      } else {\n        x = this._orthogonalPositions[\"right\" === lineLabelOptions.horizontalAlignment ? \"end\" : \"start\"];\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    },\n    _getAdjustedStripLabelCoords: function (strip) {\n      var stripOptions = strip.options;\n      var paddingTopBottom = stripOptions.paddingTopBottom;\n      var paddingLeftRight = stripOptions.paddingLeftRight;\n      var horizontalAlignment = stripOptions.label.horizontalAlignment;\n      var verticalAlignment = stripOptions.label.verticalAlignment;\n      var box = strip.labelBBox;\n      var labelHeight = box.height;\n      var labelWidth = box.width;\n      var labelCoords = strip.labelCoords;\n      var y = labelCoords.y - box.y;\n      var x = labelCoords.x - box.x;\n\n      if (verticalAlignment === TOP) {\n        y += paddingTopBottom;\n      } else if (verticalAlignment === CENTER) {\n        y -= labelHeight / 2;\n      } else if (verticalAlignment === BOTTOM) {\n        y -= paddingTopBottom + labelHeight;\n      }\n\n      if (horizontalAlignment === LEFT) {\n        x += paddingLeftRight;\n      } else if (horizontalAlignment === CENTER) {\n        x -= labelWidth / 2;\n      } else if (horizontalAlignment === RIGHT) {\n        x -= paddingLeftRight + labelWidth;\n      }\n\n      return {\n        translateX: x,\n        translateY: y\n      };\n    },\n    _adjustTitle: function (offset) {\n      offset = offset || 0;\n\n      if (!this._title) {\n        return;\n      }\n\n      var options = this._options;\n      var position = options.position;\n      var margin = options.title.margin;\n      var title = this._title;\n      var boxTitle = title.bBox;\n      var x = boxTitle.x;\n      var y = boxTitle.y;\n      var width = boxTitle.width;\n      var height = boxTitle.height;\n      var axisPosition = this._axisPosition;\n      var loCoord = axisPosition - margin - offset;\n      var hiCoord = axisPosition + margin + offset;\n      var params = {};\n\n      if (this._isHorizontal) {\n        if (position === TOP) {\n          params.translateY = loCoord - (y + height);\n        } else {\n          params.translateY = hiCoord - y;\n        }\n      } else if (position === LEFT) {\n        params.translateX = loCoord - (x + width);\n      } else {\n        params.translateX = hiCoord - x;\n      }\n\n      title.element.attr(params);\n    },\n    _checkTitleOverflow: function (titleElement) {\n      if (!this._title && !titleElement) {\n        return;\n      }\n\n      var canvasLength = this._getScreenDelta();\n\n      var title = titleElement ? {\n        bBox: titleElement.getBBox(),\n        element: titleElement\n      } : this._title;\n      var titleOptions = this._options.title;\n      var boxTitle = title.bBox;\n\n      if ((this._isHorizontal ? boxTitle.width : boxTitle.height) > canvasLength) {\n        title.element.setMaxSize(canvasLength, void 0, {\n          wordWrap: titleOptions.wordWrap || \"none\",\n          textOverflow: titleOptions.textOverflow || \"ellipsis\"\n        });\n        this._wrapped = titleOptions.wordWrap && \"none\" !== titleOptions.wordWrap;\n      } else {\n        var moreThanOriginalSize = title.originalSize && canvasLength > (this._isHorizontal ? title.originalSize.width : title.originalSize.height);\n        !this._wrapped && moreThanOriginalSize && title.element.restoreText();\n      }\n    },\n    coordsIn: function (x, y) {\n      var canvas = this.getCanvas();\n      var isHorizontal = this._options.isHorizontal;\n      var position = this._options.position;\n      var coord = isHorizontal ? y : x;\n\n      if (isHorizontal && (x < canvas.left || x > canvas.width - canvas.right) || !isHorizontal && (y < canvas.top || y > canvas.height - canvas.bottom)) {\n        return false;\n      }\n\n      if (isHorizontal && position === constants.top || !isHorizontal && position === constants.left) {\n        return coord < canvas[position];\n      }\n\n      return coord > canvas[isHorizontal ? \"height\" : \"width\"] - canvas[position];\n    },\n    _boundaryTicksVisibility: {\n      min: true,\n      max: true\n    },\n\n    adjust() {\n      var seriesData = this._seriesData;\n\n      var viewport = this._series.filter(s => s.isVisible()).reduce((range, s) => {\n        var seriesRange = s.getViewport();\n        range.min = isDefined(seriesRange.min) ? range.min < seriesRange.min ? range.min : seriesRange.min : range.min;\n        range.max = isDefined(seriesRange.max) ? range.max > seriesRange.max ? range.max : seriesRange.max : range.max;\n\n        if (s.showZero) {\n          range = new Range(range);\n          range.correctValueZeroLevel();\n        }\n\n        return range;\n      }, {});\n\n      if (isDefined(viewport.min) && isDefined(viewport.max)) {\n        seriesData.minVisible = viewport.min;\n        seriesData.maxVisible = viewport.max;\n      }\n\n      seriesData.userBreaks = this._getScaleBreaks(this._options, {\n        minVisible: seriesData.minVisible,\n        maxVisible: seriesData.maxVisible\n      }, this._series, this.isArgumentAxis);\n\n      this._translator.updateBusinessRange(this._getViewportRange());\n    },\n\n    hasWrap() {\n      return this._wrapped;\n    },\n\n    getAxisPosition() {\n      return this._axisPosition;\n    },\n\n    _getStick: function () {\n      return !this._options.valueMarginsEnabled;\n    },\n    _getStripLabelCoords: function (from, to, stripLabelOptions) {\n      var orthogonalPositions = this._orthogonalPositions;\n      var isHorizontal = this._isHorizontal;\n      var horizontalAlignment = stripLabelOptions.horizontalAlignment;\n      var verticalAlignment = stripLabelOptions.verticalAlignment;\n      var x;\n      var y;\n\n      if (isHorizontal) {\n        if (horizontalAlignment === CENTER) {\n          x = from + (to - from) / 2;\n        } else if (horizontalAlignment === LEFT) {\n          x = from;\n        } else if (horizontalAlignment === RIGHT) {\n          x = to;\n        }\n\n        y = orthogonalPositions[getStripVerticalAlignmentPosition(verticalAlignment)];\n      } else {\n        x = orthogonalPositions[getStripHorizontalAlignmentPosition(horizontalAlignment)];\n\n        if (verticalAlignment === TOP) {\n          y = from;\n        } else if (verticalAlignment === CENTER) {\n          y = to + (from - to) / 2;\n        } else if (verticalAlignment === BOTTOM) {\n          y = to;\n        }\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    },\n    _getTranslatedValue: function (value, offset) {\n      var pos1 = this._translator.translate(value, offset, \"semidiscrete\" === this._options.type && this._options.tickInterval);\n\n      var pos2 = this._axisPosition;\n      var isHorizontal = this._isHorizontal;\n      return {\n        x: isHorizontal ? pos1 : pos2,\n        y: isHorizontal ? pos2 : pos1\n      };\n    },\n    areCoordsOutsideAxis: function (coords) {\n      var coord = this._isHorizontal ? coords.x : coords.y;\n      var visibleArea = this.getVisibleArea();\n\n      if (coord < visibleArea[0] || coord > visibleArea[1]) {\n        return true;\n      }\n\n      return false;\n    },\n    _getSkippedCategory: function (ticks) {\n      var skippedCategory;\n\n      if (this._options.type === constants.discrete && this._tickOffset && 0 !== ticks.length) {\n        skippedCategory = ticks[ticks.length - 1];\n      }\n\n      return skippedCategory;\n    },\n    _filterBreaks: function (breaks, viewport, breakStyle) {\n      var minVisible = viewport.minVisible;\n      var maxVisible = viewport.maxVisible;\n      var breakSize = breakStyle ? breakStyle.width : 0;\n      return breaks.reduce(function (result, currentBreak) {\n        var from = currentBreak.from;\n        var to = currentBreak.to;\n        var lastResult = result[result.length - 1];\n        var newBreak;\n\n        if (!isDefined(from) || !isDefined(to)) {\n          return result;\n        }\n\n        if (from > to) {\n          to = [from, from = to][0];\n        }\n\n        if (result.length && from < lastResult.to) {\n          if (to > lastResult.to) {\n            lastResult.to = to > maxVisible ? maxVisible : to;\n\n            if (lastResult.gapSize) {\n              lastResult.gapSize = void 0;\n              lastResult.cumulativeWidth += breakSize;\n            }\n          }\n        } else if (from >= minVisible && from < maxVisible || to <= maxVisible && to > minVisible) {\n          from = from >= minVisible ? from : minVisible;\n          to = to <= maxVisible ? to : maxVisible;\n\n          if (to - from < maxVisible - minVisible) {\n            var _lastResult$cumulativ;\n\n            newBreak = {\n              from: from,\n              to: to,\n              cumulativeWidth: (null !== (_lastResult$cumulativ = null === lastResult || void 0 === lastResult ? void 0 : lastResult.cumulativeWidth) && void 0 !== _lastResult$cumulativ ? _lastResult$cumulativ : 0) + breakSize\n            };\n\n            if (currentBreak.gapSize) {\n              var _lastResult$cumulativ2;\n\n              newBreak.gapSize = dateUtils.convertMillisecondsToDateUnits(to - from);\n              newBreak.cumulativeWidth = null !== (_lastResult$cumulativ2 = null === lastResult || void 0 === lastResult ? void 0 : lastResult.cumulativeWidth) && void 0 !== _lastResult$cumulativ2 ? _lastResult$cumulativ2 : 0;\n            }\n\n            result.push(newBreak);\n          }\n        }\n\n        return result;\n      }, []);\n    },\n    _getScaleBreaks: function (axisOptions, viewport, series, isArgumentAxis) {\n      var that = this;\n      var breaks = (axisOptions.breaks || []).map(function (b) {\n        return {\n          from: that.parser(b.startValue),\n          to: that.parser(b.endValue)\n        };\n      });\n\n      if (\"discrete\" !== axisOptions.type && \"datetime\" === axisOptions.dataType && axisOptions.workdaysOnly) {\n        breaks = breaks.concat(generateDateBreaks(viewport.minVisible, viewport.maxVisible, axisOptions.workWeek, axisOptions.singleWorkdays, axisOptions.holidays));\n      }\n\n      if (!isArgumentAxis && \"discrete\" !== axisOptions.type && \"datetime\" !== axisOptions.dataType && axisOptions.autoBreaksEnabled && 0 !== axisOptions.maxAutoBreakCount) {\n        breaks = breaks.concat(generateAutoBreaks(axisOptions, series, viewport));\n      }\n\n      return sortingBreaks(breaks);\n    },\n    _drawBreak: function (translatedEnd, positionFrom, positionTo, width, options, group) {\n      var breakStart = translatedEnd - (!this._translator.isInverted() ? width + 1 : 0);\n      var attr = {\n        \"stroke-width\": 1,\n        stroke: options.borderColor,\n        sharp: !options.isWaved ? options.isHorizontal ? \"h\" : \"v\" : void 0\n      };\n      var spaceAttr = {\n        stroke: options.color,\n        \"stroke-width\": width\n      };\n      var getPoints = this._isHorizontal ? rotateLine : function (p) {\n        return p;\n      };\n      var drawer = getLineDrawer(this._renderer, group, getPoints, positionFrom, breakStart, positionTo, options.isWaved);\n      drawer(width / 2, spaceAttr);\n      drawer(0, attr);\n      drawer(width, attr);\n    },\n    _createBreakClipRect: function (from, to) {\n      var canvas = this._canvas;\n      var clipWidth = to - from;\n      var clipRect;\n\n      if (this._isHorizontal) {\n        clipRect = this._renderer.clipRect(canvas.left, from, canvas.width, clipWidth);\n      } else {\n        clipRect = this._renderer.clipRect(from, canvas.top, clipWidth, canvas.height);\n      }\n\n      this._breaksElements = this._breaksElements || [];\n\n      this._breaksElements.push(clipRect);\n\n      return clipRect.id;\n    },\n    _createBreaksGroup: function (clipFrom, clipTo) {\n      var group = this._renderer.g().attr({\n        class: this._axisCssPrefix + \"breaks\",\n        \"clip-path\": this._createBreakClipRect(clipFrom, clipTo)\n      }).append(this._scaleBreaksGroup);\n\n      this._breaksElements = this._breaksElements || [];\n\n      this._breaksElements.push(group);\n\n      return group;\n    },\n    _disposeBreaksGroup: function () {\n      (this._breaksElements || []).forEach(function (clipRect) {\n        clipRect.dispose();\n      });\n      this._breaksElements = null;\n    },\n    drawScaleBreaks: function (customCanvas) {\n      var that = this;\n      var options = that._options;\n      var breakStyle = options.breakStyle;\n      var position = options.position;\n      var positionFrom;\n      var positionTo;\n      var breaks = that._translator.getBusinessRange().breaks || [];\n      var additionGroup;\n      var additionBreakFrom;\n      var additionBreakTo;\n\n      that._disposeBreaksGroup();\n\n      if (!(breaks && breaks.length)) {\n        return;\n      }\n\n      var breakOptions = {\n        color: that._options.containerColor,\n        borderColor: breakStyle.color,\n        isHorizontal: that._isHorizontal,\n        isWaved: \"straight\" !== breakStyle.line.toLowerCase()\n      };\n\n      if (customCanvas) {\n        positionFrom = customCanvas.start;\n        positionTo = customCanvas.end;\n      } else {\n        positionFrom = that._orthogonalPositions.start - (options.visible && !that._axisShift && (position === LEFT || position === TOP) ? SCALE_BREAK_OFFSET : 0);\n        positionTo = that._orthogonalPositions.end + (options.visible && (position === RIGHT || position === BOTTOM) ? SCALE_BREAK_OFFSET : 0);\n      }\n\n      var mainGroup = that._createBreaksGroup(positionFrom, positionTo);\n\n      if (that._axisShift && options.visible) {\n        additionBreakFrom = that._axisPosition - that._axisShift - SCALE_BREAK_OFFSET;\n        additionBreakTo = additionBreakFrom + 2 * SCALE_BREAK_OFFSET;\n        additionGroup = that._createBreaksGroup(additionBreakFrom, additionBreakTo);\n      }\n\n      breaks.forEach(function (br) {\n        if (!br.gapSize) {\n          var breakCoord = that._getTranslatedCoord(br.to);\n\n          that._drawBreak(breakCoord, positionFrom, positionTo, breakStyle.width, breakOptions, mainGroup);\n\n          if (that._axisShift && options.visible) {\n            that._drawBreak(breakCoord, additionBreakFrom, additionBreakTo, breakStyle.width, breakOptions, additionGroup);\n          }\n        }\n      });\n    },\n    _getSpiderCategoryOption: noop,\n    shift: function (margins) {\n      var options = this._options;\n      var isHorizontal = options.isHorizontal;\n      var axesSpacing = this.getMultipleAxesSpacing();\n      var constantLinesGroups = this._axisConstantLineGroups;\n\n      function shiftGroup(side, group) {\n        var attr = {\n          translateX: 0,\n          translateY: 0\n        };\n        var shift = margins[side] ? margins[side] + axesSpacing : 0;\n        attr[isHorizontal ? \"translateY\" : \"translateX\"] = (side === LEFT || side === TOP ? -1 : 1) * shift;\n        (group[side] || group).attr(attr);\n        return shift;\n      }\n\n      this._axisShift = shiftGroup(options.position, this._axisGroup);\n      shiftGroup(options.position, this._axisElementsGroup);\n      (isHorizontal ? [TOP, BOTTOM] : [LEFT, RIGHT]).forEach(side => {\n        shiftGroup(side, constantLinesGroups.above);\n        shiftGroup(side, constantLinesGroups.under);\n      });\n    },\n\n    getCustomPosition(position) {\n      var orthogonalAxis = this.getOrthogonalAxis();\n      var resolvedPosition = null !== position && void 0 !== position ? position : this.getResolvedPositionOption();\n      var offset = this.getOptions().offset;\n      var orthogonalTranslator = orthogonalAxis.getTranslator();\n      var orthogonalAxisType = orthogonalAxis.getOptions().type;\n      var validPosition = orthogonalAxis.validateUnit(resolvedPosition);\n      var currentPosition;\n\n      if (\"discrete\" === orthogonalAxisType && (!orthogonalTranslator._categories || orthogonalTranslator._categories.indexOf(validPosition) < 0)) {\n        validPosition = void 0;\n      }\n\n      if (this.positionIsBoundary(resolvedPosition)) {\n        currentPosition = this.getPredefinedPosition(resolvedPosition);\n      } else if (!isDefined(validPosition)) {\n        currentPosition = this.getPredefinedPosition(this.getOptions().position);\n      } else {\n        currentPosition = orthogonalTranslator.to(validPosition, -1);\n      }\n\n      if (isFinite(currentPosition) && isFinite(offset)) {\n        currentPosition += offset;\n      }\n\n      return currentPosition;\n    },\n\n    getCustomBoundaryPosition(position) {\n      var {\n        customPosition: customPosition,\n        offset: offset\n      } = this.getOptions();\n      var resolvedPosition = null !== position && void 0 !== position ? position : this.getResolvedPositionOption();\n      var orthogonalAxis = this.getOrthogonalAxis();\n      var orthogonalTranslator = orthogonalAxis.getTranslator();\n      var visibleArea = orthogonalTranslator.getCanvasVisibleArea();\n\n      if (!isDefined(orthogonalAxis._orthogonalPositions) || 0 === orthogonalTranslator.canvasLength) {\n        return;\n      }\n\n      var currentPosition = this.getCustomPosition(resolvedPosition);\n\n      if (!isDefined(currentPosition)) {\n        return this.getResolvedBoundaryPosition();\n      } else if (isDefined(customPosition)) {\n        if (currentPosition <= visibleArea.min) {\n          return this._isHorizontal ? TOP : LEFT;\n        } else if (currentPosition >= visibleArea.max) {\n          return this._isHorizontal ? BOTTOM : RIGHT;\n        }\n      } else if (isDefined(offset)) {\n        if (currentPosition <= this._orthogonalPositions.start) {\n          return this._isHorizontal ? TOP : LEFT;\n        } else if (currentPosition >= this._orthogonalPositions.end) {\n          return this._isHorizontal ? BOTTOM : RIGHT;\n        }\n      }\n\n      return currentPosition;\n    },\n\n    getResolvedPositionOption() {\n      var _options$customPositi;\n\n      var options = this.getOptions();\n      return null !== (_options$customPositi = options.customPosition) && void 0 !== _options$customPositi ? _options$customPositi : options.position;\n    },\n\n    customPositionIsAvailable() {\n      var options = this.getOptions();\n      return isDefined(this.getOrthogonalAxis()) && (isDefined(options.customPosition) || isFinite(options.offset));\n    },\n\n    hasNonBoundaryPosition() {\n      return this.customPositionIsAvailable() && !this.customPositionIsBoundary();\n    },\n\n    getResolvedBoundaryPosition() {\n      return this.customPositionIsBoundary() ? this._customBoundaryPosition : this.getOptions().position;\n    },\n\n    customPositionEqualsToPredefined() {\n      return this.customPositionIsBoundary() && this._customBoundaryPosition === this.getOptions().position;\n    },\n\n    customPositionIsBoundary() {\n      return this.positionIsBoundary(this._customBoundaryPosition);\n    },\n\n    positionIsBoundary: position => [TOP, LEFT, BOTTOM, RIGHT].indexOf(position) >= 0,\n\n    getPredefinedPosition(position) {\n      var _this$_orthogonalPosi;\n\n      return null === (_this$_orthogonalPosi = this._orthogonalPositions) || void 0 === _this$_orthogonalPosi ? void 0 : _this$_orthogonalPosi[position === TOP || position === LEFT ? \"start\" : \"end\"];\n    },\n\n    resolveOverlappingForCustomPositioning(oppositeAxes) {\n      var that = this;\n\n      if (!that.hasNonBoundaryPosition() && !that.customPositionIsBoundary() && !oppositeAxes.some(a => a.hasNonBoundaryPosition())) {\n        return;\n      }\n\n      var overlappingObj = {\n        axes: [],\n        ticks: []\n      };\n      oppositeAxes.filter(orthogonalAxis => orthogonalAxis.pane === that.pane).forEach(orthogonalAxis => {\n        for (var i = 0; i < that._majorTicks.length; i++) {\n          var tick = that._majorTicks[i];\n          var label = tick.label;\n\n          if (label) {\n            if (overlappingObj.axes.indexOf(orthogonalAxis) < 0 && that._detectElementsOverlapping(label, orthogonalAxis._axisElement)) {\n              overlappingObj.axes.push(orthogonalAxis);\n\n              that._shiftThroughOrthogonalAxisOverlappedTick(label, orthogonalAxis);\n            }\n\n            for (var j = 0; j < orthogonalAxis._majorTicks.length; j++) {\n              var oppositeTick = orthogonalAxis._majorTicks[j];\n              var oppositeLabel = oppositeTick.label;\n\n              if (oppositeLabel && that._detectElementsOverlapping(label, oppositeLabel)) {\n                overlappingObj.ticks.push(tick);\n\n                that._shiftThroughAxisOverlappedTick(tick);\n\n                i = that._majorTicks.length;\n                break;\n              }\n            }\n          }\n\n          if (tick.mark && overlappingObj.ticks.indexOf(tick) < 0) {\n            if (that._isHorizontal && tick.mark.attr(\"translateY\")) {\n              tick.mark.attr({\n                translateY: 0\n              });\n            } else if (!that._isHorizontal && tick.mark.attr(\"translateX\")) {\n              tick.mark.attr({\n                translateX: 0\n              });\n            }\n          }\n        }\n      });\n    },\n\n    _shiftThroughOrthogonalAxisOverlappedTick(label, orthogonalAxis) {\n      var labelBBox = label.getBBox();\n      var orthogonalAxisPosition = orthogonalAxis.getAxisPosition();\n      var orthogonalAxisLabelOptions = orthogonalAxis.getOptions().label;\n      var orthogonalAxisLabelPosition = orthogonalAxisLabelOptions.position;\n      var orthogonalAxisLabelIndent = orthogonalAxisLabelOptions.indentFromAxis / 2;\n      var translateCoordName = this._isHorizontal ? \"translateX\" : \"translateY\";\n      var defaultOrthogonalAxisLabelPosition = this._isHorizontal ? LEFT : TOP;\n      var translate = label.attr(translateCoordName);\n      var labelCoord = (this._isHorizontal ? labelBBox.x : labelBBox.y) + translate;\n      var labelSize = this._isHorizontal ? labelBBox.width : labelBBox.height;\n      var outsidePart = orthogonalAxisPosition - labelCoord;\n      var insidePart = labelCoord + labelSize - orthogonalAxisPosition;\n      var attr = {};\n      attr[translateCoordName] = translate;\n\n      if (outsidePart > 0 && insidePart > 0) {\n        if (insidePart - outsidePart > 1) {\n          attr[translateCoordName] += outsidePart + orthogonalAxisLabelIndent;\n        } else if (outsidePart - insidePart > 1) {\n          attr[translateCoordName] -= insidePart + orthogonalAxisLabelIndent;\n        } else {\n          attr[translateCoordName] += orthogonalAxisLabelPosition === defaultOrthogonalAxisLabelPosition ? outsidePart + orthogonalAxisLabelIndent : -(insidePart + orthogonalAxisLabelIndent);\n        }\n\n        label.attr(attr);\n      }\n    },\n\n    _shiftThroughAxisOverlappedTick(tick) {\n      var _tick$mark;\n\n      var label = tick.label;\n\n      if (!label) {\n        return;\n      }\n\n      var labelBBox = label.getBBox();\n      var tickMarkBBox = null === (_tick$mark = tick.mark) || void 0 === _tick$mark ? void 0 : _tick$mark.getBBox();\n      var axisPosition = this.getAxisPosition();\n      var labelOptions = this.getOptions().label;\n      var labelIndent = labelOptions.indentFromAxis;\n      var labelPosition = labelOptions.position;\n      var defaultLabelPosition = this._isHorizontal ? TOP : LEFT;\n      var translateCoordName = this._isHorizontal ? \"translateY\" : \"translateX\";\n      var translate = label.attr(translateCoordName);\n      var labelCoord = (this._isHorizontal ? labelBBox.y : labelBBox.x) + translate;\n      var labelSize = this._isHorizontal ? labelBBox.height : labelBBox.width;\n      var attr = {};\n      attr[translateCoordName] = translate + (labelPosition === defaultLabelPosition ? axisPosition - labelCoord + labelIndent : -(labelCoord - axisPosition + labelSize + labelIndent));\n      label.attr(attr);\n\n      if (tick.mark) {\n        var markerSize = this._isHorizontal ? tickMarkBBox.height : tickMarkBBox.width;\n        var dir = labelPosition === defaultLabelPosition ? 1 : -1;\n        attr[translateCoordName] = dir * (markerSize - 1);\n        tick.mark.attr(attr);\n      }\n    },\n\n    _detectElementsOverlapping(element1, element2) {\n      if (!element1 || !element2) {\n        return false;\n      }\n\n      var bBox1 = element1.getBBox();\n      var x1 = bBox1.x + element1.attr(\"translateX\");\n      var y1 = bBox1.y + element1.attr(\"translateY\");\n      var bBox2 = element2.getBBox();\n      var x2 = bBox2.x + element2.attr(\"translateX\");\n      var y2 = bBox2.y + element2.attr(\"translateY\");\n      return (x2 >= x1 && x2 <= x1 + bBox1.width || x1 >= x2 && x1 <= x2 + bBox2.width) && (y2 >= y1 && y2 <= y1 + bBox1.height || y1 >= y2 && y1 <= y2 + bBox2.height);\n    }\n\n  }\n};\n\nfunction getLineDrawer(renderer, root, rotatePoints, positionFrom, breakStart, positionTo, isWaved) {\n  var elementType = isWaved ? \"bezier\" : \"line\";\n  var group = renderer.g().append(root);\n  return function (offset, attr) {\n    renderer.path(rotatePoints(getPoints(positionFrom, breakStart, positionTo, offset, isWaved)), elementType).attr(attr).append(group);\n  };\n}\n\nfunction getPoints(positionFrom, breakStart, positionTo, offset, isWaved) {\n  if (!isWaved) {\n    return [positionFrom, breakStart + offset, positionTo, breakStart + offset];\n  }\n\n  breakStart += offset;\n  var currentPosition;\n  var topPoint = breakStart + WAVED_LINE_TOP;\n  var centerPoint = breakStart + WAVED_LINE_CENTER;\n  var bottomPoint = breakStart + WAVED_LINE_BOTTOM;\n  var points = [[positionFrom, centerPoint]];\n\n  for (currentPosition = positionFrom; currentPosition < positionTo + WAVED_LINE_LENGTH; currentPosition += WAVED_LINE_LENGTH) {\n    points.push([currentPosition + 6, topPoint, currentPosition + 6, topPoint, currentPosition + 12, centerPoint, currentPosition + 18, bottomPoint, currentPosition + 18, bottomPoint, currentPosition + 24, centerPoint]);\n  }\n\n  return [].concat.apply([], points);\n}\n\nfunction rotateLine(lineCoords) {\n  var points = [];\n  var i;\n\n  for (i = 0; i < lineCoords.length; i += 2) {\n    points.push(lineCoords[i + 1]);\n    points.push(lineCoords[i]);\n  }\n\n  return points;\n}","map":{"version":3,"names":["Range","formatHelper","dateUtils","extend","generateDateBreaks","noop","getLog","patchFontOptions","getCosAndSin","isDefined","constants","getNextDateUnit","correctDateWithUnitBeginning","_math","Math","_max","max","TOP","top","BOTTOM","bottom","LEFT","left","RIGHT","right","CENTER","center","SCALE_BREAK_OFFSET","RANGE_RATIO","WAVED_LINE_CENTER","WAVED_LINE_TOP","WAVED_LINE_BOTTOM","WAVED_LINE_LENGTH","TICKS_CORRECTIONS","prepareDatesDifferences","datesDifferences","tickInterval","dateUnitInterval","i","dateUnitIntervals","length","count","sortingBreaks","breaks","sort","a","b","from","getMarkerDates","min","markerInterval","origMin","dates","getSequenceByInterval","slice","getStripHorizontalAlignmentPosition","alignment","position","getStripVerticalAlignmentPosition","getMarkerInterval","getMarkerFormat","curDate","prevDate","format","getDatesDifferences","getDateFormatByDifferences","getMaxSide","act","boxes","reduce","prevValue","box","getDistanceByAngle","bBox","rotationAngle","abs","PI","atan","height","width","sin","getMaxConstantLinePadding","constantLines","padding","options","paddingTopBottom","getConstantLineLabelMarginForVerticalAlignment","labelHeight","some","label","verticalAlignment","getLeftMargin","x","getRightMargin","generateRangesOnPoints","points","edgePoints","getRange","maxRange","ranges","curValue","curRange","indexOf","start","end","push","generateAutoBreaks","_ref","series","_ref2","logarithmBase","type","maxAutoBreakCount","minVisible","maxVisible","visibleRange","result","s","getPointsInViewPort","concat","sortedAllPoints","filter","p","minDiff","epsilon","apply","map","r","_maxAutoBreakCount","to","linear","_getStep","spacing","_options","minSpacing","func","_isHorizontal","maxLabelLength","_getMaxLabelHeight","getTicksCountInRange","_majorTicks","_validateOverlappingMode","mode","displayMode","validateOverlappingMode","_validateDisplayMode","getMarkerTrackers","_markerTrackers","_getSharpParam","opposite","_createAxisElement","_renderer","path","_updateAxisElementPosition","axisCoord","_axisPosition","canvas","_getCanvasStartEnd","_axisElement","attr","_getTranslatedCoord","value","offset","_translator","translate","_initAxisPositions","customPositionIsAvailable","_customBoundaryPosition","getCustomBoundaryPosition","customPositionIsBoundary","getPredefinedPosition","getResolvedBoundaryPosition","getCustomPosition","_getTickMarkPoints","coords","tickOptions","isHorizontal","tickOrientation","labelPosition","tickStartCoord","shift","getTickStartPositionShift","y","hasNonBoundaryPosition","floor","_getTitleCoords","horizontal","align","title","fromStartToEnd","canvasStart","canvasEnd","coord","_drawTitleText","group","titleOptions","attrs","opacity","class","cssClass","text","rotate","css","font","append","_checkTitleOverflow","_updateTitleCoords","_title","element","_drawTitle","_axisTitleGroup","_measureTitle","originalSize","getBBox","_drawDateMarker","date","range","markerOptions","marker","invert","getBusinessRange","textIndent","textLeftIndent","pathElement","withoutStick","separatorHeight","stroke","color","sharp","_axisElementsGroup","String","formatLabel","labelOptions","cropped","line","getContentContainer","getEnd","labelBBox","setTitle","hideLabel","dispose","hide","hidden","_drawDateMarkers","that","translator","viewport","_getViewportRange","minBound","dateMarkers","dateMarker","draw","markerDate","markersAreaTop","_getLabelFormatOptions","isEmpty","visible","argumentType","topIndent","getDateUnitInterval","_tickInterval","markerDates","markers","unshift","_adjustDateMarkers","_dateMarkers","_checkMarkersPosition","prevDateMarker","forEach","dy","textTopIndent","translateX","translateY","_initializeMarkersTrackers","renderer","businessRange","nextMarker","markerTracker","fill","data","startValue","endValue","formatString","markerLabelOptions","_markerLabelOptions","_adjustConstantLineLabels","axisPosition","getCanvas","canvasLeft","canvasRight","canvasTop","canvasBottom","verticalCenter","horizontalCenter","maxLabel","item","linesOptions","paddingLeftRight","labelVerticalAlignment","labelHorizontalAlignment","horizontalAlignment","labelIsInside","_drawConstantLinesForEstimating","g","_drawConstantLineLabelText","root","_estimateLabelHeight","drawingType","overlappingBehavior","staggeringSpacing","sinCos","cos","indentFromAxis","estimateMargins","updateCanvas","ticksData","_createTicksAndLabelFormat","ticks","constantLineOptions","_outsideConstantLines","l","rootElement","labelIsVisible","labelValue","labelElement","_textFontStyles","_textOptions","titleElement","constantLinesLabelsElement","labelBox","template","titleBox","constantLinesBox","titleHeight","margin","constantLinesHeight","margins","remove","_checkAlignmentConstantLineLabels","toLowerCase","_getConstantLineLabelsCoords","lineLabelOptions","_orthogonalPositions","_getAdjustedStripLabelCoords","strip","stripOptions","labelWidth","labelCoords","_adjustTitle","boxTitle","loCoord","hiCoord","params","canvasLength","_getScreenDelta","setMaxSize","wordWrap","textOverflow","_wrapped","moreThanOriginalSize","restoreText","coordsIn","_boundaryTicksVisibility","adjust","seriesData","_seriesData","_series","isVisible","seriesRange","getViewport","showZero","correctValueZeroLevel","userBreaks","_getScaleBreaks","isArgumentAxis","updateBusinessRange","hasWrap","getAxisPosition","_getStick","valueMarginsEnabled","_getStripLabelCoords","stripLabelOptions","orthogonalPositions","_getTranslatedValue","pos1","pos2","areCoordsOutsideAxis","visibleArea","getVisibleArea","_getSkippedCategory","skippedCategory","discrete","_tickOffset","_filterBreaks","breakStyle","breakSize","currentBreak","lastResult","newBreak","gapSize","cumulativeWidth","_lastResult$cumulativ","_lastResult$cumulativ2","convertMillisecondsToDateUnits","axisOptions","parser","dataType","workdaysOnly","workWeek","singleWorkdays","holidays","autoBreaksEnabled","_drawBreak","translatedEnd","positionFrom","positionTo","breakStart","isInverted","borderColor","isWaved","spaceAttr","getPoints","rotateLine","drawer","getLineDrawer","_createBreakClipRect","_canvas","clipWidth","clipRect","_breaksElements","id","_createBreaksGroup","clipFrom","clipTo","_axisCssPrefix","_scaleBreaksGroup","_disposeBreaksGroup","drawScaleBreaks","customCanvas","additionGroup","additionBreakFrom","additionBreakTo","breakOptions","containerColor","_axisShift","mainGroup","br","breakCoord","_getSpiderCategoryOption","axesSpacing","getMultipleAxesSpacing","constantLinesGroups","_axisConstantLineGroups","shiftGroup","side","_axisGroup","above","under","orthogonalAxis","getOrthogonalAxis","resolvedPosition","getResolvedPositionOption","getOptions","orthogonalTranslator","getTranslator","orthogonalAxisType","validPosition","validateUnit","currentPosition","_categories","positionIsBoundary","isFinite","customPosition","getCanvasVisibleArea","_options$customPositi","customPositionEqualsToPredefined","_this$_orthogonalPosi","resolveOverlappingForCustomPositioning","oppositeAxes","overlappingObj","axes","pane","tick","_detectElementsOverlapping","_shiftThroughOrthogonalAxisOverlappedTick","j","oppositeTick","oppositeLabel","_shiftThroughAxisOverlappedTick","mark","orthogonalAxisPosition","orthogonalAxisLabelOptions","orthogonalAxisLabelPosition","orthogonalAxisLabelIndent","translateCoordName","defaultOrthogonalAxisLabelPosition","labelCoord","labelSize","outsidePart","insidePart","_tick$mark","tickMarkBBox","labelIndent","defaultLabelPosition","markerSize","dir","element1","element2","bBox1","x1","y1","bBox2","x2","y2","rotatePoints","elementType","topPoint","centerPoint","bottomPoint","lineCoords"],"sources":["E:/MisaProject/W2022_06/misa_emis/node_modules/devextreme/esm/viz/axes/xy_axes.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/viz/axes/xy_axes.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    Range\r\n} from \"../translators/range\";\r\nimport formatHelper from \"../../format_helper\";\r\nimport dateUtils from \"../../core/utils/date\";\r\nimport {\r\n    extend\r\n} from \"../../core/utils/extend\";\r\nimport {\r\n    generateDateBreaks\r\n} from \"./datetime_breaks\";\r\nimport {\r\n    noop\r\n} from \"../../core/utils/common\";\r\nimport {\r\n    getLog,\r\n    patchFontOptions,\r\n    getCosAndSin\r\n} from \"../core/utils\";\r\nimport {\r\n    isDefined\r\n} from \"../../core/utils/type\";\r\nimport constants from \"./axes_constants\";\r\nvar getNextDateUnit = dateUtils.getNextDateUnit;\r\nvar correctDateWithUnitBeginning = dateUtils.correctDateWithUnitBeginning;\r\nvar _math = Math;\r\nvar _max = _math.max;\r\nvar TOP = constants.top;\r\nvar BOTTOM = constants.bottom;\r\nvar LEFT = constants.left;\r\nvar RIGHT = constants.right;\r\nvar CENTER = constants.center;\r\nvar SCALE_BREAK_OFFSET = 3;\r\nvar RANGE_RATIO = .3;\r\nvar WAVED_LINE_CENTER = 2;\r\nvar WAVED_LINE_TOP = 0;\r\nvar WAVED_LINE_BOTTOM = 4;\r\nvar WAVED_LINE_LENGTH = 24;\r\nvar TICKS_CORRECTIONS = {\r\n    left: -1,\r\n    top: -1,\r\n    right: 0,\r\n    bottom: 0,\r\n    center: -.5\r\n};\r\n\r\nfunction prepareDatesDifferences(datesDifferences, tickInterval) {\r\n    var dateUnitInterval;\r\n    var i;\r\n    if (\"week\" === tickInterval) {\r\n        tickInterval = \"day\"\r\n    }\r\n    if (\"quarter\" === tickInterval) {\r\n        tickInterval = \"month\"\r\n    }\r\n    if (datesDifferences[tickInterval]) {\r\n        for (i = 0; i < dateUtils.dateUnitIntervals.length; i++) {\r\n            dateUnitInterval = dateUtils.dateUnitIntervals[i];\r\n            if (datesDifferences[dateUnitInterval]) {\r\n                datesDifferences[dateUnitInterval] = false;\r\n                datesDifferences.count--\r\n            }\r\n            if (dateUnitInterval === tickInterval) {\r\n                break\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction sortingBreaks(breaks) {\r\n    return breaks.sort((function(a, b) {\r\n        return a.from - b.from\r\n    }))\r\n}\r\n\r\nfunction getMarkerDates(min, max, markerInterval) {\r\n    var origMin = min;\r\n    var dates;\r\n    min = correctDateWithUnitBeginning(min, markerInterval);\r\n    max = correctDateWithUnitBeginning(max, markerInterval);\r\n    dates = dateUtils.getSequenceByInterval(min, max, markerInterval);\r\n    if (dates.length && origMin > dates[0]) {\r\n        dates = dates.slice(1)\r\n    }\r\n    return dates\r\n}\r\n\r\nfunction getStripHorizontalAlignmentPosition(alignment) {\r\n    var position = \"start\";\r\n    if (\"center\" === alignment) {\r\n        position = \"center\"\r\n    }\r\n    if (\"right\" === alignment) {\r\n        position = \"end\"\r\n    }\r\n    return position\r\n}\r\n\r\nfunction getStripVerticalAlignmentPosition(alignment) {\r\n    var position = \"start\";\r\n    if (\"center\" === alignment) {\r\n        position = \"center\"\r\n    }\r\n    if (\"bottom\" === alignment) {\r\n        position = \"end\"\r\n    }\r\n    return position\r\n}\r\n\r\nfunction getMarkerInterval(tickInterval) {\r\n    var markerInterval = getNextDateUnit(tickInterval);\r\n    if (\"quarter\" === markerInterval) {\r\n        markerInterval = getNextDateUnit(markerInterval)\r\n    }\r\n    return markerInterval\r\n}\r\n\r\nfunction getMarkerFormat(curDate, prevDate, tickInterval, markerInterval) {\r\n    var format = markerInterval;\r\n    var datesDifferences = prevDate && dateUtils.getDatesDifferences(prevDate, curDate);\r\n    if (prevDate && \"year\" !== tickInterval) {\r\n        prepareDatesDifferences(datesDifferences, tickInterval);\r\n        format = formatHelper.getDateFormatByDifferences(datesDifferences)\r\n    }\r\n    return format\r\n}\r\n\r\nfunction getMaxSide(act, boxes) {\r\n    return boxes.reduce((function(prevValue, box) {\r\n        return _max(prevValue, act(box))\r\n    }), 0)\r\n}\r\n\r\nfunction getDistanceByAngle(bBox, rotationAngle) {\r\n    rotationAngle = _math.abs(rotationAngle);\r\n    rotationAngle = rotationAngle % 180 >= 90 ? 90 - rotationAngle % 90 : rotationAngle % 90;\r\n    var a = rotationAngle * (_math.PI / 180);\r\n    if (a >= _math.atan(bBox.height / bBox.width)) {\r\n        return bBox.height / _math.abs(_math.sin(a))\r\n    } else {\r\n        return bBox.width\r\n    }\r\n}\r\n\r\nfunction getMaxConstantLinePadding(constantLines) {\r\n    return constantLines.reduce((function(padding, options) {\r\n        return _max(padding, options.paddingTopBottom)\r\n    }), 0)\r\n}\r\n\r\nfunction getConstantLineLabelMarginForVerticalAlignment(constantLines, alignment, labelHeight) {\r\n    return constantLines.some((function(options) {\r\n        return options.label.verticalAlignment === alignment\r\n    })) && labelHeight || 0\r\n}\r\n\r\nfunction getLeftMargin(bBox) {\r\n    return _math.abs(bBox.x) || 0\r\n}\r\n\r\nfunction getRightMargin(bBox) {\r\n    return _math.abs(bBox.width - _math.abs(bBox.x)) || 0\r\n}\r\n\r\nfunction generateRangesOnPoints(points, edgePoints, getRange) {\r\n    var i;\r\n    var length;\r\n    var maxRange = null;\r\n    var ranges = [];\r\n    var curValue;\r\n    var prevValue;\r\n    var curRange;\r\n    for (i = 1, length = points.length; i < length; i++) {\r\n        curValue = points[i];\r\n        prevValue = points[i - 1];\r\n        curRange = getRange(curValue, prevValue);\r\n        if (edgePoints.indexOf(curValue) >= 0) {\r\n            if (!maxRange || curRange > maxRange.length) {\r\n                maxRange = {\r\n                    start: curValue,\r\n                    end: prevValue,\r\n                    length: curRange\r\n                }\r\n            }\r\n        } else {\r\n            if (maxRange && curRange < maxRange.length) {\r\n                ranges.push(maxRange)\r\n            } else {\r\n                ranges.push({\r\n                    start: curValue,\r\n                    end: prevValue,\r\n                    length: curRange\r\n                })\r\n            }\r\n            maxRange = null\r\n        }\r\n    }\r\n    if (maxRange) {\r\n        ranges.push(maxRange)\r\n    }\r\n    return ranges\r\n}\r\n\r\nfunction generateAutoBreaks(_ref, series, _ref2) {\r\n    var {\r\n        logarithmBase: logarithmBase,\r\n        type: type,\r\n        maxAutoBreakCount: maxAutoBreakCount\r\n    } = _ref;\r\n    var {\r\n        minVisible: minVisible,\r\n        maxVisible: maxVisible\r\n    } = _ref2;\r\n    var breaks = [];\r\n    var getRange = \"logarithmic\" === type ? (min, max) => getLog(max / min, logarithmBase) : (min, max) => max - min;\r\n    var visibleRange = getRange(minVisible, maxVisible);\r\n    var points = series.reduce((result, s) => {\r\n        var points = s.getPointsInViewPort();\r\n        result[0] = result[0].concat(points[0]);\r\n        result[1] = result[1].concat(points[1]);\r\n        return result\r\n    }, [\r\n        [],\r\n        []\r\n    ]);\r\n    var sortedAllPoints = points[0].concat(points[1]).sort((a, b) => b - a);\r\n    var edgePoints = points[1].filter(p => points[0].indexOf(p) < 0);\r\n    var minDiff = RANGE_RATIO * visibleRange;\r\n    var ranges = generateRangesOnPoints(sortedAllPoints, edgePoints, getRange).sort((a, b) => b.length - a.length);\r\n    var epsilon = _math.min.apply(null, ranges.map(r => r.length)) / 1e3;\r\n    var _maxAutoBreakCount = isDefined(maxAutoBreakCount) ? _math.min(maxAutoBreakCount, ranges.length) : ranges.length;\r\n    for (var i = 0; i < _maxAutoBreakCount; i++) {\r\n        if (ranges[i].length >= minDiff) {\r\n            if (visibleRange <= ranges[i].length) {\r\n                break\r\n            }\r\n            visibleRange -= ranges[i].length;\r\n            if (visibleRange > epsilon || visibleRange < -epsilon) {\r\n                breaks.push({\r\n                    from: ranges[i].start,\r\n                    to: ranges[i].end\r\n                });\r\n                minDiff = RANGE_RATIO * visibleRange\r\n            }\r\n        } else {\r\n            break\r\n        }\r\n    }\r\n    sortingBreaks(breaks);\r\n    return breaks\r\n}\r\nexport default {\r\n    linear: {\r\n        _getStep: function(boxes, rotationAngle) {\r\n            var spacing = this._options.label.minSpacing;\r\n            var func = this._isHorizontal ? function(box) {\r\n                return box.width + spacing\r\n            } : function(box) {\r\n                return box.height\r\n            };\r\n            var maxLabelLength = getMaxSide(func, boxes);\r\n            if (rotationAngle) {\r\n                maxLabelLength = getDistanceByAngle({\r\n                    width: maxLabelLength,\r\n                    height: this._getMaxLabelHeight(boxes, 0)\r\n                }, rotationAngle)\r\n            }\r\n            return constants.getTicksCountInRange(this._majorTicks, this._isHorizontal ? \"x\" : \"y\", maxLabelLength)\r\n        },\r\n        _getMaxLabelHeight: function(boxes, spacing) {\r\n            return getMaxSide((function(box) {\r\n                return box.height\r\n            }), boxes) + spacing\r\n        },\r\n        _validateOverlappingMode: function(mode, displayMode) {\r\n            if (this._isHorizontal && (\"rotate\" === displayMode || \"stagger\" === displayMode) || !this._isHorizontal) {\r\n                return constants.validateOverlappingMode(mode)\r\n            }\r\n            return mode\r\n        },\r\n        _validateDisplayMode: function(mode) {\r\n            return this._isHorizontal ? mode : \"standard\"\r\n        },\r\n        getMarkerTrackers: function() {\r\n            return this._markerTrackers\r\n        },\r\n        _getSharpParam: function(opposite) {\r\n            return this._isHorizontal ^ opposite ? \"h\" : \"v\"\r\n        },\r\n        _createAxisElement: function() {\r\n            return this._renderer.path([], \"line\")\r\n        },\r\n        _updateAxisElementPosition: function() {\r\n            var axisCoord = this._axisPosition;\r\n            var canvas = this._getCanvasStartEnd();\r\n            this._axisElement.attr({\r\n                points: this._isHorizontal ? [canvas.start, axisCoord, canvas.end, axisCoord] : [axisCoord, canvas.start, axisCoord, canvas.end]\r\n            })\r\n        },\r\n        _getTranslatedCoord: function(value, offset) {\r\n            return this._translator.translate(value, offset)\r\n        },\r\n        _initAxisPositions() {\r\n            if (this.customPositionIsAvailable()) {\r\n                this._customBoundaryPosition = this.getCustomBoundaryPosition()\r\n            }\r\n            if (!this.customPositionIsAvailable() || this.customPositionIsBoundary()) {\r\n                this._axisPosition = this.getPredefinedPosition(this.getResolvedBoundaryPosition())\r\n            } else {\r\n                this._axisPosition = this.getCustomPosition()\r\n            }\r\n        },\r\n        _getTickMarkPoints(coords, length, tickOptions) {\r\n            var isHorizontal = this._isHorizontal;\r\n            var tickOrientation = this._options.tickOrientation;\r\n            var labelPosition = this._options.label.position;\r\n            var tickStartCoord;\r\n            if (isDefined(tickOrientation)) {\r\n                tickStartCoord = TICKS_CORRECTIONS[tickOrientation] * length\r\n            } else {\r\n                var shift = tickOptions.shift || 0;\r\n                if (!isHorizontal && labelPosition === LEFT || isHorizontal && labelPosition !== BOTTOM) {\r\n                    shift = -shift\r\n                }\r\n                tickStartCoord = shift + this.getTickStartPositionShift(length)\r\n            }\r\n            return [coords.x + (isHorizontal ? 0 : tickStartCoord), coords.y + (isHorizontal ? tickStartCoord : 0), coords.x + (isHorizontal ? 0 : tickStartCoord + length), coords.y + (isHorizontal ? tickStartCoord + length : 0)]\r\n        },\r\n        getTickStartPositionShift(length) {\r\n            var width = this._options.width;\r\n            var position = this.getResolvedBoundaryPosition();\r\n            return length % 2 === 1 ? width % 2 === 0 && (position === LEFT || position === TOP) || width % 2 === 1 && (position === RIGHT || position === BOTTOM) && !this.hasNonBoundaryPosition() ? Math.floor(-length / 2) : -Math.floor(length / 2) : -length / 2 + (width % 2 === 0 ? 0 : position === BOTTOM || position === RIGHT ? -1 : 1)\r\n        },\r\n        _getTitleCoords: function() {\r\n            var horizontal = this._isHorizontal;\r\n            var x = this._axisPosition;\r\n            var y = this._axisPosition;\r\n            var align = this._options.title.alignment;\r\n            var canvas = this._getCanvasStartEnd();\r\n            var fromStartToEnd = horizontal || this._options.position === LEFT;\r\n            var canvasStart = fromStartToEnd ? canvas.start : canvas.end;\r\n            var canvasEnd = fromStartToEnd ? canvas.end : canvas.start;\r\n            var coord = align === LEFT ? canvasStart : align === RIGHT ? canvasEnd : canvas.start + (canvas.end - canvas.start) / 2;\r\n            if (horizontal) {\r\n                x = coord\r\n            } else {\r\n                y = coord\r\n            }\r\n            return {\r\n                x: x,\r\n                y: y\r\n            }\r\n        },\r\n        _drawTitleText: function(group, coords) {\r\n            var options = this._options;\r\n            var titleOptions = options.title;\r\n            var attrs = {\r\n                opacity: titleOptions.opacity,\r\n                align: titleOptions.alignment,\r\n                class: titleOptions.cssClass\r\n            };\r\n            if (!titleOptions.text || !group) {\r\n                return\r\n            }\r\n            coords = coords || this._getTitleCoords();\r\n            if (!this._isHorizontal) {\r\n                attrs.rotate = options.position === LEFT ? 270 : 90\r\n            }\r\n            var text = this._renderer.text(titleOptions.text, coords.x, coords.y).css(patchFontOptions(titleOptions.font)).attr(attrs).append(group);\r\n            this._checkTitleOverflow(text);\r\n            return text\r\n        },\r\n        _updateTitleCoords: function() {\r\n            this._title && this._title.element.attr(this._getTitleCoords())\r\n        },\r\n        _drawTitle: function() {\r\n            var title = this._drawTitleText(this._axisTitleGroup);\r\n            if (title) {\r\n                this._title = {\r\n                    element: title\r\n                }\r\n            }\r\n        },\r\n        _measureTitle: function() {\r\n            if (this._title) {\r\n                if (this._title.bBox && !this._title.originalSize) {\r\n                    this._title.originalSize = this._title.bBox\r\n                }\r\n                this._title.bBox = this._title.element.getBBox()\r\n            }\r\n        },\r\n        _drawDateMarker: function(date, options, range) {\r\n            var markerOptions = this._options.marker;\r\n            var invert = this._translator.getBusinessRange().invert;\r\n            var textIndent = markerOptions.width + markerOptions.textLeftIndent;\r\n            var pathElement;\r\n            if (null === options.x) {\r\n                return\r\n            }\r\n            if (!options.withoutStick) {\r\n                pathElement = this._renderer.path([options.x, options.y, options.x, options.y + markerOptions.separatorHeight], \"line\").attr({\r\n                    \"stroke-width\": markerOptions.width,\r\n                    stroke: markerOptions.color,\r\n                    \"stroke-opacity\": markerOptions.opacity,\r\n                    sharp: \"h\"\r\n                }).append(this._axisElementsGroup)\r\n            }\r\n            var text = String(this.formatLabel(date, options.labelOptions, range));\r\n            return {\r\n                date: date,\r\n                x: options.x,\r\n                y: options.y,\r\n                cropped: options.withoutStick,\r\n                label: this._renderer.text(text, options.x, options.y).css(patchFontOptions(markerOptions.label.font)).append(this._axisElementsGroup),\r\n                line: pathElement,\r\n                getContentContainer() {\r\n                    return this.label\r\n                },\r\n                getEnd: function() {\r\n                    return this.x + (invert ? -1 : 1) * (textIndent + this.labelBBox.width)\r\n                },\r\n                setTitle: function() {\r\n                    this.title = text\r\n                },\r\n                hideLabel: function() {\r\n                    this.label.dispose();\r\n                    this.label = null;\r\n                    this.title = text\r\n                },\r\n                hide: function() {\r\n                    if (pathElement) {\r\n                        pathElement.dispose();\r\n                        pathElement = null\r\n                    }\r\n                    this.label.dispose();\r\n                    this.label = null;\r\n                    this.hidden = true\r\n                }\r\n            }\r\n        },\r\n        _drawDateMarkers: function() {\r\n            var that = this;\r\n            var options = that._options;\r\n            var translator = that._translator;\r\n            var viewport = that._getViewportRange();\r\n            var minBound = viewport.minVisible;\r\n            var dateMarkers = [];\r\n            var dateMarker;\r\n\r\n            function draw(markerDate, format, withoutStick) {\r\n                return that._drawDateMarker(markerDate, {\r\n                    x: translator.translate(markerDate),\r\n                    y: markersAreaTop,\r\n                    labelOptions: that._getLabelFormatOptions(format),\r\n                    withoutStick: withoutStick\r\n                }, viewport)\r\n            }\r\n            if (viewport.isEmpty() || !options.marker.visible || \"datetime\" !== options.argumentType || \"discrete\" === options.type || that._majorTicks.length <= 1) {\r\n                return []\r\n            }\r\n            var markersAreaTop = that._axisPosition + options.marker.topIndent;\r\n            var tickInterval = dateUtils.getDateUnitInterval(this._tickInterval);\r\n            var markerInterval = getMarkerInterval(tickInterval);\r\n            var markerDates = getMarkerDates(minBound, viewport.maxVisible, markerInterval);\r\n            if (markerDates.length > 1 || 1 === markerDates.length && minBound < markerDates[0]) {\r\n                dateMarkers = markerDates.reduce((function(markers, curDate, i, dates) {\r\n                    var marker = draw(curDate, getMarkerFormat(curDate, dates[i - 1] || minBound < curDate && minBound, tickInterval, markerInterval));\r\n                    marker && markers.push(marker);\r\n                    return markers\r\n                }), []);\r\n                if (minBound < markerDates[0]) {\r\n                    dateMarker = draw(minBound, getMarkerFormat(minBound, markerDates[0], tickInterval, markerInterval), true);\r\n                    dateMarker && dateMarkers.unshift(dateMarker)\r\n                }\r\n            }\r\n            return dateMarkers\r\n        },\r\n        _adjustDateMarkers: function(offset) {\r\n            offset = offset || 0;\r\n            var that = this;\r\n            var markerOptions = this._options.marker;\r\n            var textIndent = markerOptions.width + markerOptions.textLeftIndent;\r\n            var invert = this._translator.getBusinessRange().invert;\r\n            var canvas = that._getCanvasStartEnd();\r\n            var dateMarkers = this._dateMarkers;\r\n            if (!dateMarkers.length) {\r\n                return offset\r\n            }\r\n            if (dateMarkers[0].cropped) {\r\n                if (!this._checkMarkersPosition(invert, dateMarkers[1], dateMarkers[0])) {\r\n                    dateMarkers[0].hideLabel()\r\n                }\r\n            }\r\n            var prevDateMarker;\r\n            dateMarkers.forEach((function(marker, i, markers) {\r\n                if (marker.cropped) {\r\n                    return\r\n                }\r\n                if (invert ? marker.getEnd() < canvas.end : marker.getEnd() > canvas.end) {\r\n                    marker.hideLabel()\r\n                } else if (that._checkMarkersPosition(invert, marker, prevDateMarker)) {\r\n                    prevDateMarker = marker\r\n                } else {\r\n                    marker.hide()\r\n                }\r\n            }));\r\n            this._dateMarkers.forEach((function(marker) {\r\n                if (marker.label) {\r\n                    var labelBBox = marker.labelBBox;\r\n                    var dy = marker.y + markerOptions.textTopIndent - labelBBox.y;\r\n                    marker.label.attr({\r\n                        translateX: invert ? marker.x - textIndent - labelBBox.x - labelBBox.width : marker.x + textIndent - labelBBox.x,\r\n                        translateY: dy + offset\r\n                    })\r\n                }\r\n                if (marker.line) {\r\n                    marker.line.attr({\r\n                        translateY: offset\r\n                    })\r\n                }\r\n            }));\r\n            that._initializeMarkersTrackers(offset);\r\n            return offset + markerOptions.topIndent + markerOptions.separatorHeight\r\n        },\r\n        _checkMarkersPosition: function(invert, dateMarker, prevDateMarker) {\r\n            if (void 0 === prevDateMarker) {\r\n                return true\r\n            }\r\n            return invert ? dateMarker.x < prevDateMarker.getEnd() : dateMarker.x > prevDateMarker.getEnd()\r\n        },\r\n        _initializeMarkersTrackers: function(offset) {\r\n            var separatorHeight = this._options.marker.separatorHeight;\r\n            var renderer = this._renderer;\r\n            var businessRange = this._translator.getBusinessRange();\r\n            var canvas = this._getCanvasStartEnd();\r\n            var group = this._axisElementsGroup;\r\n            this._markerTrackers = this._dateMarkers.filter((function(marker) {\r\n                return !marker.hidden\r\n            })).map((function(marker, i, markers) {\r\n                var nextMarker = markers[i + 1] || {\r\n                    x: canvas.end,\r\n                    date: businessRange.max\r\n                };\r\n                var x = marker.x;\r\n                var y = marker.y + offset;\r\n                var markerTracker = renderer.path([x, y, x, y + separatorHeight, nextMarker.x, y + separatorHeight, nextMarker.x, y, x, y], \"area\").attr({\r\n                    \"stroke-width\": 1,\r\n                    stroke: \"grey\",\r\n                    fill: \"grey\",\r\n                    opacity: 1e-4\r\n                }).append(group);\r\n                markerTracker.data(\"range\", {\r\n                    startValue: marker.date,\r\n                    endValue: nextMarker.date\r\n                });\r\n                if (marker.title) {\r\n                    markerTracker.setTitle(marker.title)\r\n                }\r\n                return markerTracker\r\n            }))\r\n        },\r\n        _getLabelFormatOptions: function(formatString) {\r\n            var markerLabelOptions = this._markerLabelOptions;\r\n            if (!markerLabelOptions) {\r\n                this._markerLabelOptions = markerLabelOptions = extend(true, {}, this._options.marker.label)\r\n            }\r\n            if (!isDefined(this._options.marker.label.format)) {\r\n                markerLabelOptions.format = formatString\r\n            }\r\n            return markerLabelOptions\r\n        },\r\n        _adjustConstantLineLabels: function(constantLines) {\r\n            var that = this;\r\n            var axisPosition = that._options.position;\r\n            var canvas = that.getCanvas();\r\n            var canvasLeft = canvas.left;\r\n            var canvasRight = canvas.width - canvas.right;\r\n            var canvasTop = canvas.top;\r\n            var canvasBottom = canvas.height - canvas.bottom;\r\n            var verticalCenter = canvasTop + (canvasBottom - canvasTop) / 2;\r\n            var horizontalCenter = canvasLeft + (canvasRight - canvasLeft) / 2;\r\n            var maxLabel = 0;\r\n            constantLines.forEach((function(item) {\r\n                var isHorizontal = that._isHorizontal;\r\n                var linesOptions = item.options;\r\n                var paddingTopBottom = linesOptions.paddingTopBottom;\r\n                var paddingLeftRight = linesOptions.paddingLeftRight;\r\n                var labelOptions = linesOptions.label;\r\n                var labelVerticalAlignment = labelOptions.verticalAlignment;\r\n                var labelHorizontalAlignment = labelOptions.horizontalAlignment;\r\n                var labelIsInside = \"inside\" === labelOptions.position;\r\n                var label = item.label;\r\n                var box = item.labelBBox;\r\n                var translateX;\r\n                var translateY;\r\n                if (null === label || box.isEmpty) {\r\n                    return\r\n                }\r\n                if (isHorizontal) {\r\n                    if (labelIsInside) {\r\n                        if (labelHorizontalAlignment === LEFT) {\r\n                            translateX = item.coord - paddingLeftRight - box.x - box.width\r\n                        } else {\r\n                            translateX = item.coord + paddingLeftRight - box.x\r\n                        }\r\n                        switch (labelVerticalAlignment) {\r\n                            case CENTER:\r\n                                translateY = verticalCenter - box.y - box.height / 2;\r\n                                break;\r\n                            case BOTTOM:\r\n                                translateY = canvasBottom - paddingTopBottom - box.y - box.height;\r\n                                break;\r\n                            default:\r\n                                translateY = canvasTop + paddingTopBottom - box.y\r\n                        }\r\n                    } else {\r\n                        if (axisPosition === labelVerticalAlignment) {\r\n                            maxLabel = _max(maxLabel, box.height + paddingTopBottom)\r\n                        }\r\n                        translateX = item.coord - box.x - box.width / 2;\r\n                        if (labelVerticalAlignment === BOTTOM) {\r\n                            translateY = canvasBottom + paddingTopBottom - box.y\r\n                        } else {\r\n                            translateY = canvasTop - paddingTopBottom - box.y - box.height\r\n                        }\r\n                    }\r\n                } else if (labelIsInside) {\r\n                    if (labelVerticalAlignment === BOTTOM) {\r\n                        translateY = item.coord + paddingTopBottom - box.y\r\n                    } else {\r\n                        translateY = item.coord - paddingTopBottom - box.y - box.height\r\n                    }\r\n                    switch (labelHorizontalAlignment) {\r\n                        case CENTER:\r\n                            translateX = horizontalCenter - box.x - box.width / 2;\r\n                            break;\r\n                        case RIGHT:\r\n                            translateX = canvasRight - paddingLeftRight - box.x - box.width;\r\n                            break;\r\n                        default:\r\n                            translateX = canvasLeft + paddingLeftRight - box.x\r\n                    }\r\n                } else {\r\n                    if (axisPosition === labelHorizontalAlignment) {\r\n                        maxLabel = _max(maxLabel, box.width + paddingLeftRight)\r\n                    }\r\n                    translateY = item.coord - box.y - box.height / 2;\r\n                    if (labelHorizontalAlignment === RIGHT) {\r\n                        translateX = canvasRight + paddingLeftRight - box.x\r\n                    } else {\r\n                        translateX = canvasLeft - paddingLeftRight - box.x - box.width\r\n                    }\r\n                }\r\n                label.attr({\r\n                    translateX: translateX,\r\n                    translateY: translateY\r\n                })\r\n            }));\r\n            return maxLabel\r\n        },\r\n        _drawConstantLinesForEstimating: function(constantLines) {\r\n            var that = this;\r\n            var renderer = this._renderer;\r\n            var group = renderer.g();\r\n            constantLines.forEach((function(options) {\r\n                that._drawConstantLineLabelText(options.label.text, 0, 0, options.label, group).attr({\r\n                    align: \"center\"\r\n                })\r\n            }));\r\n            return group.append(renderer.root)\r\n        },\r\n        _estimateLabelHeight: function(bBox, labelOptions) {\r\n            var height = bBox.height;\r\n            var drawingType = labelOptions.drawingType;\r\n            if (\"stagger\" === this._validateDisplayMode(drawingType) || \"stagger\" === this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType)) {\r\n                height = 2 * height + labelOptions.staggeringSpacing\r\n            }\r\n            if (\"rotate\" === this._validateDisplayMode(drawingType) || \"rotate\" === this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType)) {\r\n                var sinCos = getCosAndSin(labelOptions.rotationAngle);\r\n                height = height * sinCos.cos + bBox.width * sinCos.sin\r\n            }\r\n            return height && (height + labelOptions.indentFromAxis || 0) || 0\r\n        },\r\n        estimateMargins: function(canvas) {\r\n            this.updateCanvas(canvas);\r\n            var range = this._getViewportRange();\r\n            var ticksData = this._createTicksAndLabelFormat(range);\r\n            var ticks = ticksData.ticks;\r\n            var tickInterval = ticksData.tickInterval;\r\n            var options = this._options;\r\n            var constantLineOptions = this._outsideConstantLines.filter(l => l.labelOptions.visible).map(l => l.options);\r\n            var rootElement = this._renderer.root;\r\n            var labelIsVisible = options.label.visible && !range.isEmpty() && ticks.length;\r\n            var labelValue = labelIsVisible && this.formatLabel(ticks[ticks.length - 1], options.label, void 0, void 0, tickInterval, ticks);\r\n            var labelElement = labelIsVisible && this._renderer.text(labelValue, 0, 0).css(this._textFontStyles).attr(this._textOptions).append(rootElement);\r\n            var titleElement = this._drawTitleText(rootElement, {\r\n                x: 0,\r\n                y: 0\r\n            });\r\n            var constantLinesLabelsElement = this._drawConstantLinesForEstimating(constantLineOptions);\r\n            var labelBox = !options.label.template && labelElement && labelElement.getBBox() || {\r\n                x: 0,\r\n                y: 0,\r\n                width: 0,\r\n                height: 0\r\n            };\r\n            var titleBox = titleElement && titleElement.getBBox() || {\r\n                x: 0,\r\n                y: 0,\r\n                width: 0,\r\n                height: 0\r\n            };\r\n            var constantLinesBox = constantLinesLabelsElement.getBBox();\r\n            var titleHeight = titleBox.height ? titleBox.height + options.title.margin : 0;\r\n            var labelHeight = this._estimateLabelHeight(labelBox, options.label);\r\n            var constantLinesHeight = constantLinesBox.height ? constantLinesBox.height + getMaxConstantLinePadding(constantLineOptions) : 0;\r\n            var height = labelHeight + titleHeight;\r\n            var margins = {\r\n                left: _max(getLeftMargin(labelBox), getLeftMargin(constantLinesBox)),\r\n                right: _max(getRightMargin(labelBox), getRightMargin(constantLinesBox)),\r\n                top: (\"top\" === options.position ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, \"top\", constantLinesHeight),\r\n                bottom: (\"top\" !== options.position ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, \"bottom\", constantLinesHeight)\r\n            };\r\n            labelElement && labelElement.remove();\r\n            titleElement && titleElement.remove();\r\n            constantLinesLabelsElement && constantLinesLabelsElement.remove();\r\n            return margins\r\n        },\r\n        _checkAlignmentConstantLineLabels: function(labelOptions) {\r\n            var position = labelOptions.position;\r\n            var verticalAlignment = (labelOptions.verticalAlignment || \"\").toLowerCase();\r\n            var horizontalAlignment = (labelOptions.horizontalAlignment || \"\").toLowerCase();\r\n            if (this._isHorizontal) {\r\n                if (\"outside\" === position) {\r\n                    verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;\r\n                    horizontalAlignment = CENTER\r\n                } else {\r\n                    verticalAlignment = verticalAlignment === CENTER ? CENTER : verticalAlignment === BOTTOM ? BOTTOM : TOP;\r\n                    horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT\r\n                }\r\n            } else if (\"outside\" === position) {\r\n                verticalAlignment = CENTER;\r\n                horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT\r\n            } else {\r\n                verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;\r\n                horizontalAlignment = horizontalAlignment === RIGHT ? RIGHT : horizontalAlignment === CENTER ? CENTER : LEFT\r\n            }\r\n            labelOptions.verticalAlignment = verticalAlignment;\r\n            labelOptions.horizontalAlignment = horizontalAlignment\r\n        },\r\n        _getConstantLineLabelsCoords: function(value, lineLabelOptions) {\r\n            var x = value;\r\n            var y = value;\r\n            if (this._isHorizontal) {\r\n                y = this._orthogonalPositions[\"top\" === lineLabelOptions.verticalAlignment ? \"start\" : \"end\"]\r\n            } else {\r\n                x = this._orthogonalPositions[\"right\" === lineLabelOptions.horizontalAlignment ? \"end\" : \"start\"]\r\n            }\r\n            return {\r\n                x: x,\r\n                y: y\r\n            }\r\n        },\r\n        _getAdjustedStripLabelCoords: function(strip) {\r\n            var stripOptions = strip.options;\r\n            var paddingTopBottom = stripOptions.paddingTopBottom;\r\n            var paddingLeftRight = stripOptions.paddingLeftRight;\r\n            var horizontalAlignment = stripOptions.label.horizontalAlignment;\r\n            var verticalAlignment = stripOptions.label.verticalAlignment;\r\n            var box = strip.labelBBox;\r\n            var labelHeight = box.height;\r\n            var labelWidth = box.width;\r\n            var labelCoords = strip.labelCoords;\r\n            var y = labelCoords.y - box.y;\r\n            var x = labelCoords.x - box.x;\r\n            if (verticalAlignment === TOP) {\r\n                y += paddingTopBottom\r\n            } else if (verticalAlignment === CENTER) {\r\n                y -= labelHeight / 2\r\n            } else if (verticalAlignment === BOTTOM) {\r\n                y -= paddingTopBottom + labelHeight\r\n            }\r\n            if (horizontalAlignment === LEFT) {\r\n                x += paddingLeftRight\r\n            } else if (horizontalAlignment === CENTER) {\r\n                x -= labelWidth / 2\r\n            } else if (horizontalAlignment === RIGHT) {\r\n                x -= paddingLeftRight + labelWidth\r\n            }\r\n            return {\r\n                translateX: x,\r\n                translateY: y\r\n            }\r\n        },\r\n        _adjustTitle: function(offset) {\r\n            offset = offset || 0;\r\n            if (!this._title) {\r\n                return\r\n            }\r\n            var options = this._options;\r\n            var position = options.position;\r\n            var margin = options.title.margin;\r\n            var title = this._title;\r\n            var boxTitle = title.bBox;\r\n            var x = boxTitle.x;\r\n            var y = boxTitle.y;\r\n            var width = boxTitle.width;\r\n            var height = boxTitle.height;\r\n            var axisPosition = this._axisPosition;\r\n            var loCoord = axisPosition - margin - offset;\r\n            var hiCoord = axisPosition + margin + offset;\r\n            var params = {};\r\n            if (this._isHorizontal) {\r\n                if (position === TOP) {\r\n                    params.translateY = loCoord - (y + height)\r\n                } else {\r\n                    params.translateY = hiCoord - y\r\n                }\r\n            } else if (position === LEFT) {\r\n                params.translateX = loCoord - (x + width)\r\n            } else {\r\n                params.translateX = hiCoord - x\r\n            }\r\n            title.element.attr(params)\r\n        },\r\n        _checkTitleOverflow: function(titleElement) {\r\n            if (!this._title && !titleElement) {\r\n                return\r\n            }\r\n            var canvasLength = this._getScreenDelta();\r\n            var title = titleElement ? {\r\n                bBox: titleElement.getBBox(),\r\n                element: titleElement\r\n            } : this._title;\r\n            var titleOptions = this._options.title;\r\n            var boxTitle = title.bBox;\r\n            if ((this._isHorizontal ? boxTitle.width : boxTitle.height) > canvasLength) {\r\n                title.element.setMaxSize(canvasLength, void 0, {\r\n                    wordWrap: titleOptions.wordWrap || \"none\",\r\n                    textOverflow: titleOptions.textOverflow || \"ellipsis\"\r\n                });\r\n                this._wrapped = titleOptions.wordWrap && \"none\" !== titleOptions.wordWrap\r\n            } else {\r\n                var moreThanOriginalSize = title.originalSize && canvasLength > (this._isHorizontal ? title.originalSize.width : title.originalSize.height);\r\n                !this._wrapped && moreThanOriginalSize && title.element.restoreText()\r\n            }\r\n        },\r\n        coordsIn: function(x, y) {\r\n            var canvas = this.getCanvas();\r\n            var isHorizontal = this._options.isHorizontal;\r\n            var position = this._options.position;\r\n            var coord = isHorizontal ? y : x;\r\n            if (isHorizontal && (x < canvas.left || x > canvas.width - canvas.right) || !isHorizontal && (y < canvas.top || y > canvas.height - canvas.bottom)) {\r\n                return false\r\n            }\r\n            if (isHorizontal && position === constants.top || !isHorizontal && position === constants.left) {\r\n                return coord < canvas[position]\r\n            }\r\n            return coord > canvas[isHorizontal ? \"height\" : \"width\"] - canvas[position]\r\n        },\r\n        _boundaryTicksVisibility: {\r\n            min: true,\r\n            max: true\r\n        },\r\n        adjust() {\r\n            var seriesData = this._seriesData;\r\n            var viewport = this._series.filter(s => s.isVisible()).reduce((range, s) => {\r\n                var seriesRange = s.getViewport();\r\n                range.min = isDefined(seriesRange.min) ? range.min < seriesRange.min ? range.min : seriesRange.min : range.min;\r\n                range.max = isDefined(seriesRange.max) ? range.max > seriesRange.max ? range.max : seriesRange.max : range.max;\r\n                if (s.showZero) {\r\n                    range = new Range(range);\r\n                    range.correctValueZeroLevel()\r\n                }\r\n                return range\r\n            }, {});\r\n            if (isDefined(viewport.min) && isDefined(viewport.max)) {\r\n                seriesData.minVisible = viewport.min;\r\n                seriesData.maxVisible = viewport.max\r\n            }\r\n            seriesData.userBreaks = this._getScaleBreaks(this._options, {\r\n                minVisible: seriesData.minVisible,\r\n                maxVisible: seriesData.maxVisible\r\n            }, this._series, this.isArgumentAxis);\r\n            this._translator.updateBusinessRange(this._getViewportRange())\r\n        },\r\n        hasWrap() {\r\n            return this._wrapped\r\n        },\r\n        getAxisPosition() {\r\n            return this._axisPosition\r\n        },\r\n        _getStick: function() {\r\n            return !this._options.valueMarginsEnabled\r\n        },\r\n        _getStripLabelCoords: function(from, to, stripLabelOptions) {\r\n            var orthogonalPositions = this._orthogonalPositions;\r\n            var isHorizontal = this._isHorizontal;\r\n            var horizontalAlignment = stripLabelOptions.horizontalAlignment;\r\n            var verticalAlignment = stripLabelOptions.verticalAlignment;\r\n            var x;\r\n            var y;\r\n            if (isHorizontal) {\r\n                if (horizontalAlignment === CENTER) {\r\n                    x = from + (to - from) / 2\r\n                } else if (horizontalAlignment === LEFT) {\r\n                    x = from\r\n                } else if (horizontalAlignment === RIGHT) {\r\n                    x = to\r\n                }\r\n                y = orthogonalPositions[getStripVerticalAlignmentPosition(verticalAlignment)]\r\n            } else {\r\n                x = orthogonalPositions[getStripHorizontalAlignmentPosition(horizontalAlignment)];\r\n                if (verticalAlignment === TOP) {\r\n                    y = from\r\n                } else if (verticalAlignment === CENTER) {\r\n                    y = to + (from - to) / 2\r\n                } else if (verticalAlignment === BOTTOM) {\r\n                    y = to\r\n                }\r\n            }\r\n            return {\r\n                x: x,\r\n                y: y\r\n            }\r\n        },\r\n        _getTranslatedValue: function(value, offset) {\r\n            var pos1 = this._translator.translate(value, offset, \"semidiscrete\" === this._options.type && this._options.tickInterval);\r\n            var pos2 = this._axisPosition;\r\n            var isHorizontal = this._isHorizontal;\r\n            return {\r\n                x: isHorizontal ? pos1 : pos2,\r\n                y: isHorizontal ? pos2 : pos1\r\n            }\r\n        },\r\n        areCoordsOutsideAxis: function(coords) {\r\n            var coord = this._isHorizontal ? coords.x : coords.y;\r\n            var visibleArea = this.getVisibleArea();\r\n            if (coord < visibleArea[0] || coord > visibleArea[1]) {\r\n                return true\r\n            }\r\n            return false\r\n        },\r\n        _getSkippedCategory: function(ticks) {\r\n            var skippedCategory;\r\n            if (this._options.type === constants.discrete && this._tickOffset && 0 !== ticks.length) {\r\n                skippedCategory = ticks[ticks.length - 1]\r\n            }\r\n            return skippedCategory\r\n        },\r\n        _filterBreaks: function(breaks, viewport, breakStyle) {\r\n            var minVisible = viewport.minVisible;\r\n            var maxVisible = viewport.maxVisible;\r\n            var breakSize = breakStyle ? breakStyle.width : 0;\r\n            return breaks.reduce((function(result, currentBreak) {\r\n                var from = currentBreak.from;\r\n                var to = currentBreak.to;\r\n                var lastResult = result[result.length - 1];\r\n                var newBreak;\r\n                if (!isDefined(from) || !isDefined(to)) {\r\n                    return result\r\n                }\r\n                if (from > to) {\r\n                    to = [from, from = to][0]\r\n                }\r\n                if (result.length && from < lastResult.to) {\r\n                    if (to > lastResult.to) {\r\n                        lastResult.to = to > maxVisible ? maxVisible : to;\r\n                        if (lastResult.gapSize) {\r\n                            lastResult.gapSize = void 0;\r\n                            lastResult.cumulativeWidth += breakSize\r\n                        }\r\n                    }\r\n                } else if (from >= minVisible && from < maxVisible || to <= maxVisible && to > minVisible) {\r\n                    from = from >= minVisible ? from : minVisible;\r\n                    to = to <= maxVisible ? to : maxVisible;\r\n                    if (to - from < maxVisible - minVisible) {\r\n                        var _lastResult$cumulativ;\r\n                        newBreak = {\r\n                            from: from,\r\n                            to: to,\r\n                            cumulativeWidth: (null !== (_lastResult$cumulativ = null === lastResult || void 0 === lastResult ? void 0 : lastResult.cumulativeWidth) && void 0 !== _lastResult$cumulativ ? _lastResult$cumulativ : 0) + breakSize\r\n                        };\r\n                        if (currentBreak.gapSize) {\r\n                            var _lastResult$cumulativ2;\r\n                            newBreak.gapSize = dateUtils.convertMillisecondsToDateUnits(to - from);\r\n                            newBreak.cumulativeWidth = null !== (_lastResult$cumulativ2 = null === lastResult || void 0 === lastResult ? void 0 : lastResult.cumulativeWidth) && void 0 !== _lastResult$cumulativ2 ? _lastResult$cumulativ2 : 0\r\n                        }\r\n                        result.push(newBreak)\r\n                    }\r\n                }\r\n                return result\r\n            }), [])\r\n        },\r\n        _getScaleBreaks: function(axisOptions, viewport, series, isArgumentAxis) {\r\n            var that = this;\r\n            var breaks = (axisOptions.breaks || []).map((function(b) {\r\n                return {\r\n                    from: that.parser(b.startValue),\r\n                    to: that.parser(b.endValue)\r\n                }\r\n            }));\r\n            if (\"discrete\" !== axisOptions.type && \"datetime\" === axisOptions.dataType && axisOptions.workdaysOnly) {\r\n                breaks = breaks.concat(generateDateBreaks(viewport.minVisible, viewport.maxVisible, axisOptions.workWeek, axisOptions.singleWorkdays, axisOptions.holidays))\r\n            }\r\n            if (!isArgumentAxis && \"discrete\" !== axisOptions.type && \"datetime\" !== axisOptions.dataType && axisOptions.autoBreaksEnabled && 0 !== axisOptions.maxAutoBreakCount) {\r\n                breaks = breaks.concat(generateAutoBreaks(axisOptions, series, viewport))\r\n            }\r\n            return sortingBreaks(breaks)\r\n        },\r\n        _drawBreak: function(translatedEnd, positionFrom, positionTo, width, options, group) {\r\n            var breakStart = translatedEnd - (!this._translator.isInverted() ? width + 1 : 0);\r\n            var attr = {\r\n                \"stroke-width\": 1,\r\n                stroke: options.borderColor,\r\n                sharp: !options.isWaved ? options.isHorizontal ? \"h\" : \"v\" : void 0\r\n            };\r\n            var spaceAttr = {\r\n                stroke: options.color,\r\n                \"stroke-width\": width\r\n            };\r\n            var getPoints = this._isHorizontal ? rotateLine : function(p) {\r\n                return p\r\n            };\r\n            var drawer = getLineDrawer(this._renderer, group, getPoints, positionFrom, breakStart, positionTo, options.isWaved);\r\n            drawer(width / 2, spaceAttr);\r\n            drawer(0, attr);\r\n            drawer(width, attr)\r\n        },\r\n        _createBreakClipRect: function(from, to) {\r\n            var canvas = this._canvas;\r\n            var clipWidth = to - from;\r\n            var clipRect;\r\n            if (this._isHorizontal) {\r\n                clipRect = this._renderer.clipRect(canvas.left, from, canvas.width, clipWidth)\r\n            } else {\r\n                clipRect = this._renderer.clipRect(from, canvas.top, clipWidth, canvas.height)\r\n            }\r\n            this._breaksElements = this._breaksElements || [];\r\n            this._breaksElements.push(clipRect);\r\n            return clipRect.id\r\n        },\r\n        _createBreaksGroup: function(clipFrom, clipTo) {\r\n            var group = this._renderer.g().attr({\r\n                class: this._axisCssPrefix + \"breaks\",\r\n                \"clip-path\": this._createBreakClipRect(clipFrom, clipTo)\r\n            }).append(this._scaleBreaksGroup);\r\n            this._breaksElements = this._breaksElements || [];\r\n            this._breaksElements.push(group);\r\n            return group\r\n        },\r\n        _disposeBreaksGroup: function() {\r\n            (this._breaksElements || []).forEach((function(clipRect) {\r\n                clipRect.dispose()\r\n            }));\r\n            this._breaksElements = null\r\n        },\r\n        drawScaleBreaks: function(customCanvas) {\r\n            var that = this;\r\n            var options = that._options;\r\n            var breakStyle = options.breakStyle;\r\n            var position = options.position;\r\n            var positionFrom;\r\n            var positionTo;\r\n            var breaks = that._translator.getBusinessRange().breaks || [];\r\n            var additionGroup;\r\n            var additionBreakFrom;\r\n            var additionBreakTo;\r\n            that._disposeBreaksGroup();\r\n            if (!(breaks && breaks.length)) {\r\n                return\r\n            }\r\n            var breakOptions = {\r\n                color: that._options.containerColor,\r\n                borderColor: breakStyle.color,\r\n                isHorizontal: that._isHorizontal,\r\n                isWaved: \"straight\" !== breakStyle.line.toLowerCase()\r\n            };\r\n            if (customCanvas) {\r\n                positionFrom = customCanvas.start;\r\n                positionTo = customCanvas.end\r\n            } else {\r\n                positionFrom = that._orthogonalPositions.start - (options.visible && !that._axisShift && (position === LEFT || position === TOP) ? SCALE_BREAK_OFFSET : 0);\r\n                positionTo = that._orthogonalPositions.end + (options.visible && (position === RIGHT || position === BOTTOM) ? SCALE_BREAK_OFFSET : 0)\r\n            }\r\n            var mainGroup = that._createBreaksGroup(positionFrom, positionTo);\r\n            if (that._axisShift && options.visible) {\r\n                additionBreakFrom = that._axisPosition - that._axisShift - SCALE_BREAK_OFFSET;\r\n                additionBreakTo = additionBreakFrom + 2 * SCALE_BREAK_OFFSET;\r\n                additionGroup = that._createBreaksGroup(additionBreakFrom, additionBreakTo)\r\n            }\r\n            breaks.forEach((function(br) {\r\n                if (!br.gapSize) {\r\n                    var breakCoord = that._getTranslatedCoord(br.to);\r\n                    that._drawBreak(breakCoord, positionFrom, positionTo, breakStyle.width, breakOptions, mainGroup);\r\n                    if (that._axisShift && options.visible) {\r\n                        that._drawBreak(breakCoord, additionBreakFrom, additionBreakTo, breakStyle.width, breakOptions, additionGroup)\r\n                    }\r\n                }\r\n            }))\r\n        },\r\n        _getSpiderCategoryOption: noop,\r\n        shift: function(margins) {\r\n            var options = this._options;\r\n            var isHorizontal = options.isHorizontal;\r\n            var axesSpacing = this.getMultipleAxesSpacing();\r\n            var constantLinesGroups = this._axisConstantLineGroups;\r\n\r\n            function shiftGroup(side, group) {\r\n                var attr = {\r\n                    translateX: 0,\r\n                    translateY: 0\r\n                };\r\n                var shift = margins[side] ? margins[side] + axesSpacing : 0;\r\n                attr[isHorizontal ? \"translateY\" : \"translateX\"] = (side === LEFT || side === TOP ? -1 : 1) * shift;\r\n                (group[side] || group).attr(attr);\r\n                return shift\r\n            }\r\n            this._axisShift = shiftGroup(options.position, this._axisGroup);\r\n            shiftGroup(options.position, this._axisElementsGroup);\r\n            (isHorizontal ? [TOP, BOTTOM] : [LEFT, RIGHT]).forEach(side => {\r\n                shiftGroup(side, constantLinesGroups.above);\r\n                shiftGroup(side, constantLinesGroups.under)\r\n            })\r\n        },\r\n        getCustomPosition(position) {\r\n            var orthogonalAxis = this.getOrthogonalAxis();\r\n            var resolvedPosition = null !== position && void 0 !== position ? position : this.getResolvedPositionOption();\r\n            var offset = this.getOptions().offset;\r\n            var orthogonalTranslator = orthogonalAxis.getTranslator();\r\n            var orthogonalAxisType = orthogonalAxis.getOptions().type;\r\n            var validPosition = orthogonalAxis.validateUnit(resolvedPosition);\r\n            var currentPosition;\r\n            if (\"discrete\" === orthogonalAxisType && (!orthogonalTranslator._categories || orthogonalTranslator._categories.indexOf(validPosition) < 0)) {\r\n                validPosition = void 0\r\n            }\r\n            if (this.positionIsBoundary(resolvedPosition)) {\r\n                currentPosition = this.getPredefinedPosition(resolvedPosition)\r\n            } else if (!isDefined(validPosition)) {\r\n                currentPosition = this.getPredefinedPosition(this.getOptions().position)\r\n            } else {\r\n                currentPosition = orthogonalTranslator.to(validPosition, -1)\r\n            }\r\n            if (isFinite(currentPosition) && isFinite(offset)) {\r\n                currentPosition += offset\r\n            }\r\n            return currentPosition\r\n        },\r\n        getCustomBoundaryPosition(position) {\r\n            var {\r\n                customPosition: customPosition,\r\n                offset: offset\r\n            } = this.getOptions();\r\n            var resolvedPosition = null !== position && void 0 !== position ? position : this.getResolvedPositionOption();\r\n            var orthogonalAxis = this.getOrthogonalAxis();\r\n            var orthogonalTranslator = orthogonalAxis.getTranslator();\r\n            var visibleArea = orthogonalTranslator.getCanvasVisibleArea();\r\n            if (!isDefined(orthogonalAxis._orthogonalPositions) || 0 === orthogonalTranslator.canvasLength) {\r\n                return\r\n            }\r\n            var currentPosition = this.getCustomPosition(resolvedPosition);\r\n            if (!isDefined(currentPosition)) {\r\n                return this.getResolvedBoundaryPosition()\r\n            } else if (isDefined(customPosition)) {\r\n                if (currentPosition <= visibleArea.min) {\r\n                    return this._isHorizontal ? TOP : LEFT\r\n                } else if (currentPosition >= visibleArea.max) {\r\n                    return this._isHorizontal ? BOTTOM : RIGHT\r\n                }\r\n            } else if (isDefined(offset)) {\r\n                if (currentPosition <= this._orthogonalPositions.start) {\r\n                    return this._isHorizontal ? TOP : LEFT\r\n                } else if (currentPosition >= this._orthogonalPositions.end) {\r\n                    return this._isHorizontal ? BOTTOM : RIGHT\r\n                }\r\n            }\r\n            return currentPosition\r\n        },\r\n        getResolvedPositionOption() {\r\n            var _options$customPositi;\r\n            var options = this.getOptions();\r\n            return null !== (_options$customPositi = options.customPosition) && void 0 !== _options$customPositi ? _options$customPositi : options.position\r\n        },\r\n        customPositionIsAvailable() {\r\n            var options = this.getOptions();\r\n            return isDefined(this.getOrthogonalAxis()) && (isDefined(options.customPosition) || isFinite(options.offset))\r\n        },\r\n        hasNonBoundaryPosition() {\r\n            return this.customPositionIsAvailable() && !this.customPositionIsBoundary()\r\n        },\r\n        getResolvedBoundaryPosition() {\r\n            return this.customPositionIsBoundary() ? this._customBoundaryPosition : this.getOptions().position\r\n        },\r\n        customPositionEqualsToPredefined() {\r\n            return this.customPositionIsBoundary() && this._customBoundaryPosition === this.getOptions().position\r\n        },\r\n        customPositionIsBoundary() {\r\n            return this.positionIsBoundary(this._customBoundaryPosition)\r\n        },\r\n        positionIsBoundary: position => [TOP, LEFT, BOTTOM, RIGHT].indexOf(position) >= 0,\r\n        getPredefinedPosition(position) {\r\n            var _this$_orthogonalPosi;\r\n            return null === (_this$_orthogonalPosi = this._orthogonalPositions) || void 0 === _this$_orthogonalPosi ? void 0 : _this$_orthogonalPosi[position === TOP || position === LEFT ? \"start\" : \"end\"]\r\n        },\r\n        resolveOverlappingForCustomPositioning(oppositeAxes) {\r\n            var that = this;\r\n            if (!that.hasNonBoundaryPosition() && !that.customPositionIsBoundary() && !oppositeAxes.some(a => a.hasNonBoundaryPosition())) {\r\n                return\r\n            }\r\n            var overlappingObj = {\r\n                axes: [],\r\n                ticks: []\r\n            };\r\n            oppositeAxes.filter(orthogonalAxis => orthogonalAxis.pane === that.pane).forEach(orthogonalAxis => {\r\n                for (var i = 0; i < that._majorTicks.length; i++) {\r\n                    var tick = that._majorTicks[i];\r\n                    var label = tick.label;\r\n                    if (label) {\r\n                        if (overlappingObj.axes.indexOf(orthogonalAxis) < 0 && that._detectElementsOverlapping(label, orthogonalAxis._axisElement)) {\r\n                            overlappingObj.axes.push(orthogonalAxis);\r\n                            that._shiftThroughOrthogonalAxisOverlappedTick(label, orthogonalAxis)\r\n                        }\r\n                        for (var j = 0; j < orthogonalAxis._majorTicks.length; j++) {\r\n                            var oppositeTick = orthogonalAxis._majorTicks[j];\r\n                            var oppositeLabel = oppositeTick.label;\r\n                            if (oppositeLabel && that._detectElementsOverlapping(label, oppositeLabel)) {\r\n                                overlappingObj.ticks.push(tick);\r\n                                that._shiftThroughAxisOverlappedTick(tick);\r\n                                i = that._majorTicks.length;\r\n                                break\r\n                            }\r\n                        }\r\n                    }\r\n                    if (tick.mark && overlappingObj.ticks.indexOf(tick) < 0) {\r\n                        if (that._isHorizontal && tick.mark.attr(\"translateY\")) {\r\n                            tick.mark.attr({\r\n                                translateY: 0\r\n                            })\r\n                        } else if (!that._isHorizontal && tick.mark.attr(\"translateX\")) {\r\n                            tick.mark.attr({\r\n                                translateX: 0\r\n                            })\r\n                        }\r\n                    }\r\n                }\r\n            })\r\n        },\r\n        _shiftThroughOrthogonalAxisOverlappedTick(label, orthogonalAxis) {\r\n            var labelBBox = label.getBBox();\r\n            var orthogonalAxisPosition = orthogonalAxis.getAxisPosition();\r\n            var orthogonalAxisLabelOptions = orthogonalAxis.getOptions().label;\r\n            var orthogonalAxisLabelPosition = orthogonalAxisLabelOptions.position;\r\n            var orthogonalAxisLabelIndent = orthogonalAxisLabelOptions.indentFromAxis / 2;\r\n            var translateCoordName = this._isHorizontal ? \"translateX\" : \"translateY\";\r\n            var defaultOrthogonalAxisLabelPosition = this._isHorizontal ? LEFT : TOP;\r\n            var translate = label.attr(translateCoordName);\r\n            var labelCoord = (this._isHorizontal ? labelBBox.x : labelBBox.y) + translate;\r\n            var labelSize = this._isHorizontal ? labelBBox.width : labelBBox.height;\r\n            var outsidePart = orthogonalAxisPosition - labelCoord;\r\n            var insidePart = labelCoord + labelSize - orthogonalAxisPosition;\r\n            var attr = {};\r\n            attr[translateCoordName] = translate;\r\n            if (outsidePart > 0 && insidePart > 0) {\r\n                if (insidePart - outsidePart > 1) {\r\n                    attr[translateCoordName] += outsidePart + orthogonalAxisLabelIndent\r\n                } else if (outsidePart - insidePart > 1) {\r\n                    attr[translateCoordName] -= insidePart + orthogonalAxisLabelIndent\r\n                } else {\r\n                    attr[translateCoordName] += orthogonalAxisLabelPosition === defaultOrthogonalAxisLabelPosition ? outsidePart + orthogonalAxisLabelIndent : -(insidePart + orthogonalAxisLabelIndent)\r\n                }\r\n                label.attr(attr)\r\n            }\r\n        },\r\n        _shiftThroughAxisOverlappedTick(tick) {\r\n            var _tick$mark;\r\n            var label = tick.label;\r\n            if (!label) {\r\n                return\r\n            }\r\n            var labelBBox = label.getBBox();\r\n            var tickMarkBBox = null === (_tick$mark = tick.mark) || void 0 === _tick$mark ? void 0 : _tick$mark.getBBox();\r\n            var axisPosition = this.getAxisPosition();\r\n            var labelOptions = this.getOptions().label;\r\n            var labelIndent = labelOptions.indentFromAxis;\r\n            var labelPosition = labelOptions.position;\r\n            var defaultLabelPosition = this._isHorizontal ? TOP : LEFT;\r\n            var translateCoordName = this._isHorizontal ? \"translateY\" : \"translateX\";\r\n            var translate = label.attr(translateCoordName);\r\n            var labelCoord = (this._isHorizontal ? labelBBox.y : labelBBox.x) + translate;\r\n            var labelSize = this._isHorizontal ? labelBBox.height : labelBBox.width;\r\n            var attr = {};\r\n            attr[translateCoordName] = translate + (labelPosition === defaultLabelPosition ? axisPosition - labelCoord + labelIndent : -(labelCoord - axisPosition + labelSize + labelIndent));\r\n            label.attr(attr);\r\n            if (tick.mark) {\r\n                var markerSize = this._isHorizontal ? tickMarkBBox.height : tickMarkBBox.width;\r\n                var dir = labelPosition === defaultLabelPosition ? 1 : -1;\r\n                attr[translateCoordName] = dir * (markerSize - 1);\r\n                tick.mark.attr(attr)\r\n            }\r\n        },\r\n        _detectElementsOverlapping(element1, element2) {\r\n            if (!element1 || !element2) {\r\n                return false\r\n            }\r\n            var bBox1 = element1.getBBox();\r\n            var x1 = bBox1.x + element1.attr(\"translateX\");\r\n            var y1 = bBox1.y + element1.attr(\"translateY\");\r\n            var bBox2 = element2.getBBox();\r\n            var x2 = bBox2.x + element2.attr(\"translateX\");\r\n            var y2 = bBox2.y + element2.attr(\"translateY\");\r\n            return (x2 >= x1 && x2 <= x1 + bBox1.width || x1 >= x2 && x1 <= x2 + bBox2.width) && (y2 >= y1 && y2 <= y1 + bBox1.height || y1 >= y2 && y1 <= y2 + bBox2.height)\r\n        }\r\n    }\r\n};\r\n\r\nfunction getLineDrawer(renderer, root, rotatePoints, positionFrom, breakStart, positionTo, isWaved) {\r\n    var elementType = isWaved ? \"bezier\" : \"line\";\r\n    var group = renderer.g().append(root);\r\n    return function(offset, attr) {\r\n        renderer.path(rotatePoints(getPoints(positionFrom, breakStart, positionTo, offset, isWaved)), elementType).attr(attr).append(group)\r\n    }\r\n}\r\n\r\nfunction getPoints(positionFrom, breakStart, positionTo, offset, isWaved) {\r\n    if (!isWaved) {\r\n        return [positionFrom, breakStart + offset, positionTo, breakStart + offset]\r\n    }\r\n    breakStart += offset;\r\n    var currentPosition;\r\n    var topPoint = breakStart + WAVED_LINE_TOP;\r\n    var centerPoint = breakStart + WAVED_LINE_CENTER;\r\n    var bottomPoint = breakStart + WAVED_LINE_BOTTOM;\r\n    var points = [\r\n        [positionFrom, centerPoint]\r\n    ];\r\n    for (currentPosition = positionFrom; currentPosition < positionTo + WAVED_LINE_LENGTH; currentPosition += WAVED_LINE_LENGTH) {\r\n        points.push([currentPosition + 6, topPoint, currentPosition + 6, topPoint, currentPosition + 12, centerPoint, currentPosition + 18, bottomPoint, currentPosition + 18, bottomPoint, currentPosition + 24, centerPoint])\r\n    }\r\n    return [].concat.apply([], points)\r\n}\r\n\r\nfunction rotateLine(lineCoords) {\r\n    var points = [];\r\n    var i;\r\n    for (i = 0; i < lineCoords.length; i += 2) {\r\n        points.push(lineCoords[i + 1]);\r\n        points.push(lineCoords[i])\r\n    }\r\n    return points\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}