{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/view_model/view_data_generator.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport dateUtils from \"../../../../core/utils/date\";\nimport { HORIZONTAL_GROUP_ORIENTATION } from \"../../constants\";\nimport { getAllGroups, getGroupCount } from \"../../resources/utils\";\nimport { calculateCellIndex, calculateDayDuration, isHorizontalView, getStartViewDateWithoutDST, getDisplayedRowCount, getTotalCellCountByCompleteData, getTotalRowCountByCompleteData, getDisplayedCellCount } from \"../../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\nimport { getIsGroupedAllDayPanel, getKeyByGroup } from \"../../../../renovation/ui/scheduler/workspaces/utils\";\nvar HOUR_MS = dateUtils.dateToMilliseconds(\"hour\");\nvar DAY_MS = dateUtils.dateToMilliseconds(\"day\");\nexport class ViewDataGenerator {\n  get daysInInterval() {\n    return 1;\n  }\n\n  get isWorkView() {\n    return false;\n  }\n\n  get tableAllDay() {\n    return false;\n  }\n\n  isSkippedDate() {\n    return false;\n  }\n\n  getStartViewDate(options) {\n    return this._calculateStartViewDate(options);\n  }\n\n  getCompleteViewDataMap(options) {\n    var {\n      groups: groups,\n      isGroupedByDate: isGroupedByDate,\n      isHorizontalGrouping: isHorizontalGrouping,\n      isVerticalGrouping: isVerticalGrouping,\n      intervalCount: intervalCount,\n      currentDate: currentDate,\n      viewType: viewType,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour,\n      hoursInterval: hoursInterval\n    } = options;\n\n    this._setVisibilityDates(options);\n\n    this.setHiddenInterval(startDayHour, endDayHour, hoursInterval);\n    var groupsList = getAllGroups(groups);\n    var cellCountInGroupRow = this.getCellCount({\n      intervalCount: intervalCount,\n      currentDate: currentDate,\n      viewType: viewType,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour,\n      hoursInterval: hoursInterval\n    });\n    var rowCountInGroup = this.getRowCount({\n      intervalCount: intervalCount,\n      currentDate: currentDate,\n      viewType: viewType,\n      hoursInterval: hoursInterval,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour\n    });\n    var viewDataMap = [];\n\n    var allDayPanelData = this._generateAllDayPanelData(options, rowCountInGroup, cellCountInGroupRow);\n\n    var viewCellsData = this._generateViewCellsData(options, rowCountInGroup, cellCountInGroupRow);\n\n    allDayPanelData && viewDataMap.push(allDayPanelData);\n    viewDataMap.push(...viewCellsData);\n\n    if (isHorizontalGrouping && !isGroupedByDate) {\n      viewDataMap = this._transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList);\n    }\n\n    if (isVerticalGrouping) {\n      viewDataMap = this._transformViewDataMapForVerticalGrouping(viewDataMap, groupsList);\n    }\n\n    if (isGroupedByDate) {\n      viewDataMap = this._transformViewDataMapForGroupingByDate(viewDataMap, groupsList);\n    }\n\n    var completeViewDataMap = this._addKeysToCells(viewDataMap);\n\n    return completeViewDataMap;\n  }\n\n  _transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList) {\n    var result = viewDataMap.map(row => row.slice());\n    groupsList.slice(1).forEach((groups, index) => {\n      var groupIndex = index + 1;\n      viewDataMap.forEach((row, rowIndex) => {\n        var nextGroupRow = row.map(cellData => _extends({}, cellData, {\n          groups: groups,\n          groupIndex: groupIndex\n        }));\n        result[rowIndex].push(...nextGroupRow);\n      });\n    });\n    return result;\n  }\n\n  _transformViewDataMapForVerticalGrouping(viewDataMap, groupsList) {\n    var result = viewDataMap.map(row => row.slice());\n    groupsList.slice(1).forEach((groups, index) => {\n      var groupIndex = index + 1;\n      var nextGroupMap = viewDataMap.map(cellsRow => {\n        var nextRow = cellsRow.map(cellData => _extends({}, cellData, {\n          groupIndex: groupIndex,\n          groups: groups\n        }));\n        return nextRow;\n      });\n      result.push(...nextGroupMap);\n    });\n    return result;\n  }\n\n  _transformViewDataMapForGroupingByDate(viewDataMap, groupsList) {\n    var correctedGroupList = groupsList.slice(1);\n    var correctedGroupCount = correctedGroupList.length;\n    var result = viewDataMap.map(cellsRow => {\n      var groupedByDateCellsRow = cellsRow.reduce((currentRow, cell) => {\n        var rowWithCurrentCell = [...currentRow, _extends({}, cell, {\n          isFirstGroupCell: true,\n          isLastGroupCell: 0 === correctedGroupCount\n        }), ...correctedGroupList.map((groups, index) => _extends({}, cell, {\n          groups: groups,\n          groupIndex: index + 1,\n          isFirstGroupCell: false,\n          isLastGroupCell: index === correctedGroupCount - 1\n        }))];\n        return rowWithCurrentCell;\n      }, []);\n      return groupedByDateCellsRow;\n    });\n    return result;\n  }\n\n  _addKeysToCells(viewDataMap) {\n    var totalColumnCount = viewDataMap[0].length;\n    var {\n      currentViewDataMap: result\n    } = viewDataMap.reduce((_ref, row, rowIndex) => {\n      var {\n        allDayPanelsCount: allDayPanelsCount,\n        currentViewDataMap: currentViewDataMap\n      } = _ref;\n      var isAllDay = row[0].allDay;\n      var keyBase = (rowIndex - allDayPanelsCount) * totalColumnCount;\n      var currentAllDayPanelsCount = isAllDay ? allDayPanelsCount + 1 : allDayPanelsCount;\n      currentViewDataMap[rowIndex].forEach((cell, columnIndex) => {\n        cell.key = keyBase + columnIndex;\n      });\n      return {\n        allDayPanelsCount: currentAllDayPanelsCount,\n        currentViewDataMap: currentViewDataMap\n      };\n    }, {\n      allDayPanelsCount: 0,\n      currentViewDataMap: viewDataMap\n    });\n    return result;\n  }\n\n  generateViewDataMap(completeViewDataMap, options) {\n    var {\n      rowCount: rowCount,\n      startCellIndex: startCellIndex,\n      startRowIndex: startRowIndex,\n      cellCount: cellCount,\n      isVerticalGrouping: isVerticalGrouping,\n      isAllDayPanelVisible: isAllDayPanelVisible\n    } = options;\n\n    var sliceCells = (row, rowIndex, startIndex, count) => {\n      var sliceToIndex = void 0 !== count ? startIndex + count : void 0;\n      return row.slice(startIndex, sliceToIndex).map((cellData, columnIndex) => ({\n        cellData: cellData,\n        position: {\n          rowIndex: rowIndex,\n          columnIndex: columnIndex\n        }\n      }));\n    };\n\n    var correctedStartRowIndex = startRowIndex;\n    var allDayPanelMap = [];\n\n    if (this._isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible)) {\n      correctedStartRowIndex++;\n      allDayPanelMap = sliceCells(completeViewDataMap[0], 0, startCellIndex, cellCount);\n    }\n\n    var displayedRowCount = getDisplayedRowCount(rowCount, completeViewDataMap);\n    var dateTableMap = completeViewDataMap.slice(correctedStartRowIndex, correctedStartRowIndex + displayedRowCount).map((row, rowIndex) => sliceCells(row, rowIndex, startCellIndex, cellCount));\n    return {\n      allDayPanelMap: allDayPanelMap,\n      dateTableMap: dateTableMap\n    };\n  }\n\n  _isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible) {\n    return !isVerticalGrouping && isAllDayPanelVisible;\n  }\n\n  getViewDataFromMap(completeViewDataMap, viewDataMap, options) {\n    var {\n      topVirtualRowHeight: topVirtualRowHeight,\n      bottomVirtualRowHeight: bottomVirtualRowHeight,\n      leftVirtualCellWidth: leftVirtualCellWidth,\n      rightVirtualCellWidth: rightVirtualCellWidth,\n      cellCount: cellCount,\n      rowCount: rowCount,\n      startRowIndex: startRowIndex,\n      startCellIndex: startCellIndex,\n      isProvideVirtualCellsWidth: isProvideVirtualCellsWidth,\n      isGroupedAllDayPanel: isGroupedAllDayPanel,\n      isVerticalGrouping: isVerticalGrouping,\n      isAllDayPanelVisible: isAllDayPanelVisible\n    } = options;\n    var {\n      allDayPanelMap: allDayPanelMap,\n      dateTableMap: dateTableMap\n    } = viewDataMap;\n    var {\n      groupedData: groupedData\n    } = dateTableMap.reduce((_ref2, cellsRow) => {\n      var {\n        previousGroupIndex: previousGroupIndex,\n        groupedData: groupedData\n      } = _ref2;\n      var cellDataRow = cellsRow.map(_ref3 => {\n        var {\n          cellData: cellData\n        } = _ref3;\n        return cellData;\n      });\n      var firstCell = cellDataRow[0];\n      var isAllDayRow = firstCell.allDay;\n      var currentGroupIndex = firstCell.groupIndex;\n\n      if (currentGroupIndex !== previousGroupIndex) {\n        groupedData.push({\n          dateTable: [],\n          isGroupedAllDayPanel: getIsGroupedAllDayPanel(!!isAllDayRow, isVerticalGrouping),\n          groupIndex: currentGroupIndex,\n          key: getKeyByGroup(currentGroupIndex, isVerticalGrouping)\n        });\n      }\n\n      if (isAllDayRow) {\n        groupedData[groupedData.length - 1].allDayPanel = cellDataRow;\n      } else {\n        groupedData[groupedData.length - 1].dateTable.push({\n          cells: cellDataRow,\n          key: cellDataRow[0].key - startCellIndex\n        });\n      }\n\n      return {\n        groupedData: groupedData,\n        previousGroupIndex: currentGroupIndex\n      };\n    }, {\n      previousGroupIndex: -1,\n      groupedData: []\n    });\n\n    if (this._isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible)) {\n      groupedData[0].allDayPanel = allDayPanelMap.map(_ref4 => {\n        var {\n          cellData: cellData\n        } = _ref4;\n        return cellData;\n      });\n    }\n\n    var totalCellCount = getTotalCellCountByCompleteData(completeViewDataMap);\n    var totalRowCount = getTotalRowCountByCompleteData(completeViewDataMap);\n    var displayedCellCount = getDisplayedCellCount(cellCount, completeViewDataMap);\n    var displayedRowCount = getDisplayedRowCount(rowCount, completeViewDataMap);\n    return {\n      groupedData: groupedData,\n      topVirtualRowHeight: topVirtualRowHeight,\n      bottomVirtualRowHeight: bottomVirtualRowHeight,\n      leftVirtualCellWidth: isProvideVirtualCellsWidth ? leftVirtualCellWidth : void 0,\n      rightVirtualCellWidth: isProvideVirtualCellsWidth ? rightVirtualCellWidth : void 0,\n      isGroupedAllDayPanel: isGroupedAllDayPanel,\n      leftVirtualCellCount: startCellIndex,\n      rightVirtualCellCount: void 0 === cellCount ? 0 : totalCellCount - startCellIndex - displayedCellCount,\n      topVirtualRowCount: startRowIndex,\n      bottomVirtualRowCount: totalRowCount - startRowIndex - displayedRowCount\n    };\n  }\n\n  _generateViewCellsData(options, rowCount, cellCountInGroupRow) {\n    var viewCellsData = [];\n\n    for (var rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {\n      viewCellsData.push(this._generateCellsRow(options, false, rowIndex, rowCount, cellCountInGroupRow));\n    }\n\n    return viewCellsData;\n  }\n\n  _generateAllDayPanelData(options, rowCount, columnCount) {\n    if (!options.isAllDayPanelVisible) {\n      return null;\n    }\n\n    return this._generateCellsRow(options, true, 0, rowCount, columnCount);\n  }\n\n  _generateCellsRow(options, allDay, rowIndex, rowCount, columnCount) {\n    var cellsRow = [];\n\n    for (var columnIndex = 0; columnIndex < columnCount; ++columnIndex) {\n      var cellDataValue = this.getCellData(rowIndex, columnIndex, options, allDay);\n      cellDataValue.index = rowIndex * columnCount + columnIndex;\n      cellDataValue.isFirstGroupCell = this._isFirstGroupCell(rowIndex, columnIndex, options, rowCount, columnCount);\n      cellDataValue.isLastGroupCell = this._isLastGroupCell(rowIndex, columnIndex, options, rowCount, columnCount);\n      cellsRow.push(cellDataValue);\n    }\n\n    return cellsRow;\n  }\n\n  getCellData(rowIndex, columnIndex, options, allDay) {\n    return allDay ? this.prepareAllDayCellData(options, rowIndex, columnIndex) : this.prepareCellData(options, rowIndex, columnIndex);\n  }\n\n  prepareCellData(options, rowIndex, columnIndex) {\n    var {\n      groups: groups,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour,\n      interval: interval,\n      hoursInterval: hoursInterval\n    } = options;\n    var groupsList = getAllGroups(groups);\n    var startDate = this.getDateByCellIndices(options, rowIndex, columnIndex, this.getCellCountInDay(startDayHour, endDayHour, hoursInterval));\n    var endDate = this.calculateEndDate(startDate, interval, endDayHour);\n    var data = {\n      startDate: startDate,\n      endDate: endDate,\n      allDay: this.tableAllDay,\n      groupIndex: 0\n    };\n\n    if (groupsList.length > 0) {\n      data.groups = groupsList[0];\n    }\n\n    return data;\n  }\n\n  prepareAllDayCellData(options, rowIndex, columnIndex) {\n    var data = this.prepareCellData(options, rowIndex, columnIndex);\n    var startDate = dateUtils.trimTime(data.startDate);\n    return _extends({}, data, {\n      startDate: startDate,\n      endDate: startDate,\n      allDay: true\n    });\n  }\n\n  getDateByCellIndices(options, rowIndex, columnIndex, cellCountInDay) {\n    var startViewDate = options.startViewDate;\n    var {\n      startDayHour: startDayHour,\n      interval: interval,\n      firstDayOfWeek: firstDayOfWeek,\n      intervalCount: intervalCount\n    } = options;\n    var isStartViewDateDuringDST = startViewDate.getHours() !== Math.floor(startDayHour);\n\n    if (isStartViewDateDuringDST) {\n      var dateWithCorrectHours = getStartViewDateWithoutDST(startViewDate, startDayHour);\n      startViewDate = new Date(dateWithCorrectHours - dateUtils.dateToMilliseconds(\"day\"));\n    }\n\n    var columnCountBase = this.getCellCount(options);\n    var rowCountBase = this.getRowCount(options);\n\n    var cellIndex = this._calculateCellIndex(rowIndex, columnIndex, rowCountBase, columnCountBase);\n\n    var millisecondsOffset = this.getMillisecondsOffset(cellIndex, interval, cellCountInDay);\n    var offsetByCount = this.isWorkView ? this.getTimeOffsetByColumnIndex(columnIndex, this.getFirstDayOfWeek(firstDayOfWeek), columnCountBase, intervalCount) : 0;\n    var startViewDateTime = startViewDate.getTime();\n    var currentDate = new Date(startViewDateTime + millisecondsOffset + offsetByCount);\n    var timeZoneDifference = isStartViewDateDuringDST ? 0 : dateUtils.getTimezonesDifference(startViewDate, currentDate);\n    currentDate.setTime(currentDate.getTime() + timeZoneDifference);\n    return currentDate;\n  }\n\n  getMillisecondsOffset(cellIndex, interval, cellCountInDay) {\n    var dayIndex = Math.floor(cellIndex / cellCountInDay);\n    var realHiddenInterval = dayIndex * this.hiddenInterval;\n    return interval * cellIndex + realHiddenInterval;\n  }\n\n  getTimeOffsetByColumnIndex(columnIndex, firstDayOfWeek, columnCount, intervalCount) {\n    var firstDayOfWeekDiff = Math.max(0, firstDayOfWeek - 1);\n    var columnsInWeek = columnCount / intervalCount;\n    var weekendCount = Math.floor((columnIndex + firstDayOfWeekDiff) / columnsInWeek);\n    return DAY_MS * weekendCount * 2;\n  }\n\n  calculateEndDate(startDate, interval, endDayHour) {\n    var result = new Date(startDate);\n    result.setMilliseconds(result.getMilliseconds() + Math.round(interval));\n    return result;\n  }\n\n  _calculateCellIndex(rowIndex, columnIndex, rowCount, columnCount) {\n    return calculateCellIndex(rowIndex, columnIndex, rowCount);\n  }\n\n  generateGroupedDataMap(viewDataMap) {\n    var {\n      allDayPanelMap: allDayPanelMap,\n      dateTableMap: dateTableMap\n    } = viewDataMap;\n    var {\n      previousGroupedDataMap: dateTableGroupedMap\n    } = dateTableMap.reduce((previousOptions, cellsRow) => {\n      var {\n        previousGroupedDataMap: previousGroupedDataMap,\n        previousRowIndex: previousRowIndex,\n        previousGroupIndex: previousGroupIndex\n      } = previousOptions;\n      var {\n        groupIndex: currentGroupIndex\n      } = cellsRow[0].cellData;\n      var currentRowIndex = currentGroupIndex === previousGroupIndex ? previousRowIndex + 1 : 0;\n      cellsRow.forEach(cell => {\n        var {\n          groupIndex: groupIndex\n        } = cell.cellData;\n\n        if (!previousGroupedDataMap[groupIndex]) {\n          previousGroupedDataMap[groupIndex] = [];\n        }\n\n        if (!previousGroupedDataMap[groupIndex][currentRowIndex]) {\n          previousGroupedDataMap[groupIndex][currentRowIndex] = [];\n        }\n\n        previousGroupedDataMap[groupIndex][currentRowIndex].push(cell);\n      });\n      return {\n        previousGroupedDataMap: previousGroupedDataMap,\n        previousRowIndex: currentRowIndex,\n        previousGroupIndex: currentGroupIndex\n      };\n    }, {\n      previousGroupedDataMap: [],\n      previousRowIndex: -1,\n      previousGroupIndex: -1\n    });\n    var allDayPanelGroupedMap = [];\n    null === allDayPanelMap || void 0 === allDayPanelMap ? void 0 : allDayPanelMap.forEach(cell => {\n      var {\n        groupIndex: groupIndex\n      } = cell.cellData;\n\n      if (!allDayPanelGroupedMap[groupIndex]) {\n        allDayPanelGroupedMap[groupIndex] = [];\n      }\n\n      allDayPanelGroupedMap[groupIndex].push(cell);\n    });\n    return {\n      allDayPanelGroupedMap: allDayPanelGroupedMap,\n      dateTableGroupedMap: dateTableGroupedMap\n    };\n  }\n\n  _isFirstGroupCell(rowIndex, columnIndex, options, rowCount, columnCount) {\n    var {\n      groupOrientation: groupOrientation,\n      groups: groups,\n      isGroupedByDate: isGroupedByDate\n    } = options;\n    var groupCount = getGroupCount(groups);\n\n    if (isGroupedByDate) {\n      return columnIndex % groupCount === 0;\n    }\n\n    if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\n      return columnIndex % columnCount === 0;\n    }\n\n    return rowIndex % rowCount === 0;\n  }\n\n  _isLastGroupCell(rowIndex, columnIndex, options, rowCount, columnCount) {\n    var {\n      groupOrientation: groupOrientation,\n      groups: groups,\n      isGroupedByDate: isGroupedByDate\n    } = options;\n    var groupCount = getGroupCount(groups);\n\n    if (isGroupedByDate) {\n      return (columnIndex + 1) % groupCount === 0;\n    }\n\n    if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\n      return (columnIndex + 1) % columnCount === 0;\n    }\n\n    return (rowIndex + 1) % rowCount === 0;\n  }\n\n  markSelectedAndFocusedCells(viewDataMap, renderOptions) {\n    var {\n      selectedCells: selectedCells,\n      focusedCell: focusedCell\n    } = renderOptions;\n\n    if (!selectedCells && !focusedCell) {\n      return viewDataMap;\n    }\n\n    var {\n      allDayPanelMap: allDayPanelMap,\n      dateTableMap: dateTableMap\n    } = viewDataMap;\n    var nextDateTableMap = dateTableMap.map(row => this._markSelectedAndFocusedCellsInRow(row, selectedCells, focusedCell));\n\n    var nextAllDayMap = this._markSelectedAndFocusedCellsInRow(allDayPanelMap, selectedCells, focusedCell);\n\n    return {\n      allDayPanelMap: nextAllDayMap,\n      dateTableMap: nextDateTableMap\n    };\n  }\n\n  _markSelectedAndFocusedCellsInRow(dataRow, selectedCells, focusedCell) {\n    return dataRow.map(cell => {\n      var {\n        index: index,\n        groupIndex: groupIndex,\n        allDay: allDay,\n        startDate: startDate\n      } = cell.cellData;\n      var indexInSelectedCells = selectedCells.findIndex(_ref5 => {\n        var {\n          index: selectedCellIndex,\n          groupIndex: selectedCellGroupIndex,\n          allDay: selectedCellAllDay,\n          startDate: selectedCellStartDate\n        } = _ref5;\n        return groupIndex === selectedCellGroupIndex && (index === selectedCellIndex || void 0 === selectedCellIndex && startDate.getTime() === selectedCellStartDate.getTime()) && !!allDay === !!selectedCellAllDay;\n      });\n      var isFocused = !!focusedCell && index === focusedCell.cellData.index && groupIndex === focusedCell.cellData.groupIndex && allDay === focusedCell.cellData.allDay;\n\n      if (!isFocused && -1 === indexInSelectedCells) {\n        return cell;\n      }\n\n      return _extends({}, cell, {\n        cellData: _extends({}, cell.cellData, {\n          isSelected: indexInSelectedCells > -1,\n          isFocused: isFocused\n        })\n      });\n    });\n  }\n\n  getInterval(hoursInterval) {\n    return hoursInterval * HOUR_MS;\n  }\n\n  _getIntervalDuration(intervalCount) {\n    return dateUtils.dateToMilliseconds(\"day\") * intervalCount;\n  }\n\n  _setVisibilityDates() {}\n\n  getCellCountInDay(startDayHour, endDayHour, hoursInterval) {\n    var result = calculateDayDuration(startDayHour, endDayHour) / hoursInterval;\n    return Math.ceil(result);\n  }\n\n  getCellCount(options) {\n    var {\n      intervalCount: intervalCount,\n      viewType: viewType,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour,\n      hoursInterval: hoursInterval\n    } = options;\n    var cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\n    var columnCountInDay = isHorizontalView(viewType) ? cellCountInDay : 1;\n    return this.daysInInterval * intervalCount * columnCountInDay;\n  }\n\n  getRowCount(options) {\n    var {\n      viewType: viewType,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour,\n      hoursInterval: hoursInterval\n    } = options;\n    var cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\n    var rowCountInDay = !isHorizontalView(viewType) ? cellCountInDay : 1;\n    return rowCountInDay;\n  }\n\n  setHiddenInterval(startDayHour, endDayHour, hoursInterval) {\n    this.hiddenInterval = DAY_MS - this.getVisibleDayDuration(startDayHour, endDayHour, hoursInterval);\n  }\n\n  getVisibleDayDuration(startDayHour, endDayHour, hoursInterval) {\n    var cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\n    return hoursInterval * cellCountInDay * HOUR_MS;\n  }\n\n  getFirstDayOfWeek(firstDayOfWeekOption) {\n    return firstDayOfWeekOption;\n  }\n\n}","map":{"version":3,"names":["_extends","dateUtils","HORIZONTAL_GROUP_ORIENTATION","getAllGroups","getGroupCount","calculateCellIndex","calculateDayDuration","isHorizontalView","getStartViewDateWithoutDST","getDisplayedRowCount","getTotalCellCountByCompleteData","getTotalRowCountByCompleteData","getDisplayedCellCount","getIsGroupedAllDayPanel","getKeyByGroup","HOUR_MS","dateToMilliseconds","DAY_MS","ViewDataGenerator","daysInInterval","isWorkView","tableAllDay","isSkippedDate","getStartViewDate","options","_calculateStartViewDate","getCompleteViewDataMap","groups","isGroupedByDate","isHorizontalGrouping","isVerticalGrouping","intervalCount","currentDate","viewType","startDayHour","endDayHour","hoursInterval","_setVisibilityDates","setHiddenInterval","groupsList","cellCountInGroupRow","getCellCount","rowCountInGroup","getRowCount","viewDataMap","allDayPanelData","_generateAllDayPanelData","viewCellsData","_generateViewCellsData","push","_transformViewDataMapForHorizontalGrouping","_transformViewDataMapForVerticalGrouping","_transformViewDataMapForGroupingByDate","completeViewDataMap","_addKeysToCells","result","map","row","slice","forEach","index","groupIndex","rowIndex","nextGroupRow","cellData","nextGroupMap","cellsRow","nextRow","correctedGroupList","correctedGroupCount","length","groupedByDateCellsRow","reduce","currentRow","cell","rowWithCurrentCell","isFirstGroupCell","isLastGroupCell","totalColumnCount","currentViewDataMap","_ref","allDayPanelsCount","isAllDay","allDay","keyBase","currentAllDayPanelsCount","columnIndex","key","generateViewDataMap","rowCount","startCellIndex","startRowIndex","cellCount","isAllDayPanelVisible","sliceCells","startIndex","count","sliceToIndex","position","correctedStartRowIndex","allDayPanelMap","_isStandaloneAllDayPanel","displayedRowCount","dateTableMap","getViewDataFromMap","topVirtualRowHeight","bottomVirtualRowHeight","leftVirtualCellWidth","rightVirtualCellWidth","isProvideVirtualCellsWidth","isGroupedAllDayPanel","groupedData","_ref2","previousGroupIndex","cellDataRow","_ref3","firstCell","isAllDayRow","currentGroupIndex","dateTable","allDayPanel","cells","_ref4","totalCellCount","totalRowCount","displayedCellCount","leftVirtualCellCount","rightVirtualCellCount","topVirtualRowCount","bottomVirtualRowCount","_generateCellsRow","columnCount","cellDataValue","getCellData","_isFirstGroupCell","_isLastGroupCell","prepareAllDayCellData","prepareCellData","interval","startDate","getDateByCellIndices","getCellCountInDay","endDate","calculateEndDate","data","trimTime","cellCountInDay","startViewDate","firstDayOfWeek","isStartViewDateDuringDST","getHours","Math","floor","dateWithCorrectHours","Date","columnCountBase","rowCountBase","cellIndex","_calculateCellIndex","millisecondsOffset","getMillisecondsOffset","offsetByCount","getTimeOffsetByColumnIndex","getFirstDayOfWeek","startViewDateTime","getTime","timeZoneDifference","getTimezonesDifference","setTime","dayIndex","realHiddenInterval","hiddenInterval","firstDayOfWeekDiff","max","columnsInWeek","weekendCount","setMilliseconds","getMilliseconds","round","generateGroupedDataMap","previousGroupedDataMap","dateTableGroupedMap","previousOptions","previousRowIndex","currentRowIndex","allDayPanelGroupedMap","groupOrientation","groupCount","markSelectedAndFocusedCells","renderOptions","selectedCells","focusedCell","nextDateTableMap","_markSelectedAndFocusedCellsInRow","nextAllDayMap","dataRow","indexInSelectedCells","findIndex","_ref5","selectedCellIndex","selectedCellGroupIndex","selectedCellAllDay","selectedCellStartDate","isFocused","isSelected","getInterval","_getIntervalDuration","ceil","columnCountInDay","rowCountInDay","getVisibleDayDuration","firstDayOfWeekOption"],"sources":["E:/MisaProject/W2022_06/misa_emis/node_modules/devextreme/esm/ui/scheduler/workspaces/view_model/view_data_generator.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/view_model/view_data_generator.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\r\nimport dateUtils from \"../../../../core/utils/date\";\r\nimport {\r\n    HORIZONTAL_GROUP_ORIENTATION\r\n} from \"../../constants\";\r\nimport {\r\n    getAllGroups,\r\n    getGroupCount\r\n} from \"../../resources/utils\";\r\nimport {\r\n    calculateCellIndex,\r\n    calculateDayDuration,\r\n    isHorizontalView,\r\n    getStartViewDateWithoutDST,\r\n    getDisplayedRowCount,\r\n    getTotalCellCountByCompleteData,\r\n    getTotalRowCountByCompleteData,\r\n    getDisplayedCellCount\r\n} from \"../../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\r\nimport {\r\n    getIsGroupedAllDayPanel,\r\n    getKeyByGroup\r\n} from \"../../../../renovation/ui/scheduler/workspaces/utils\";\r\nvar HOUR_MS = dateUtils.dateToMilliseconds(\"hour\");\r\nvar DAY_MS = dateUtils.dateToMilliseconds(\"day\");\r\nexport class ViewDataGenerator {\r\n    get daysInInterval() {\r\n        return 1\r\n    }\r\n    get isWorkView() {\r\n        return false\r\n    }\r\n    get tableAllDay() {\r\n        return false\r\n    }\r\n    isSkippedDate() {\r\n        return false\r\n    }\r\n    getStartViewDate(options) {\r\n        return this._calculateStartViewDate(options)\r\n    }\r\n    getCompleteViewDataMap(options) {\r\n        var {\r\n            groups: groups,\r\n            isGroupedByDate: isGroupedByDate,\r\n            isHorizontalGrouping: isHorizontalGrouping,\r\n            isVerticalGrouping: isVerticalGrouping,\r\n            intervalCount: intervalCount,\r\n            currentDate: currentDate,\r\n            viewType: viewType,\r\n            startDayHour: startDayHour,\r\n            endDayHour: endDayHour,\r\n            hoursInterval: hoursInterval\r\n        } = options;\r\n        this._setVisibilityDates(options);\r\n        this.setHiddenInterval(startDayHour, endDayHour, hoursInterval);\r\n        var groupsList = getAllGroups(groups);\r\n        var cellCountInGroupRow = this.getCellCount({\r\n            intervalCount: intervalCount,\r\n            currentDate: currentDate,\r\n            viewType: viewType,\r\n            startDayHour: startDayHour,\r\n            endDayHour: endDayHour,\r\n            hoursInterval: hoursInterval\r\n        });\r\n        var rowCountInGroup = this.getRowCount({\r\n            intervalCount: intervalCount,\r\n            currentDate: currentDate,\r\n            viewType: viewType,\r\n            hoursInterval: hoursInterval,\r\n            startDayHour: startDayHour,\r\n            endDayHour: endDayHour\r\n        });\r\n        var viewDataMap = [];\r\n        var allDayPanelData = this._generateAllDayPanelData(options, rowCountInGroup, cellCountInGroupRow);\r\n        var viewCellsData = this._generateViewCellsData(options, rowCountInGroup, cellCountInGroupRow);\r\n        allDayPanelData && viewDataMap.push(allDayPanelData);\r\n        viewDataMap.push(...viewCellsData);\r\n        if (isHorizontalGrouping && !isGroupedByDate) {\r\n            viewDataMap = this._transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList)\r\n        }\r\n        if (isVerticalGrouping) {\r\n            viewDataMap = this._transformViewDataMapForVerticalGrouping(viewDataMap, groupsList)\r\n        }\r\n        if (isGroupedByDate) {\r\n            viewDataMap = this._transformViewDataMapForGroupingByDate(viewDataMap, groupsList)\r\n        }\r\n        var completeViewDataMap = this._addKeysToCells(viewDataMap);\r\n        return completeViewDataMap\r\n    }\r\n    _transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList) {\r\n        var result = viewDataMap.map(row => row.slice());\r\n        groupsList.slice(1).forEach((groups, index) => {\r\n            var groupIndex = index + 1;\r\n            viewDataMap.forEach((row, rowIndex) => {\r\n                var nextGroupRow = row.map(cellData => _extends({}, cellData, {\r\n                    groups: groups,\r\n                    groupIndex: groupIndex\r\n                }));\r\n                result[rowIndex].push(...nextGroupRow)\r\n            })\r\n        });\r\n        return result\r\n    }\r\n    _transformViewDataMapForVerticalGrouping(viewDataMap, groupsList) {\r\n        var result = viewDataMap.map(row => row.slice());\r\n        groupsList.slice(1).forEach((groups, index) => {\r\n            var groupIndex = index + 1;\r\n            var nextGroupMap = viewDataMap.map(cellsRow => {\r\n                var nextRow = cellsRow.map(cellData => _extends({}, cellData, {\r\n                    groupIndex: groupIndex,\r\n                    groups: groups\r\n                }));\r\n                return nextRow\r\n            });\r\n            result.push(...nextGroupMap)\r\n        });\r\n        return result\r\n    }\r\n    _transformViewDataMapForGroupingByDate(viewDataMap, groupsList) {\r\n        var correctedGroupList = groupsList.slice(1);\r\n        var correctedGroupCount = correctedGroupList.length;\r\n        var result = viewDataMap.map(cellsRow => {\r\n            var groupedByDateCellsRow = cellsRow.reduce((currentRow, cell) => {\r\n                var rowWithCurrentCell = [...currentRow, _extends({}, cell, {\r\n                    isFirstGroupCell: true,\r\n                    isLastGroupCell: 0 === correctedGroupCount\r\n                }), ...correctedGroupList.map((groups, index) => _extends({}, cell, {\r\n                    groups: groups,\r\n                    groupIndex: index + 1,\r\n                    isFirstGroupCell: false,\r\n                    isLastGroupCell: index === correctedGroupCount - 1\r\n                }))];\r\n                return rowWithCurrentCell\r\n            }, []);\r\n            return groupedByDateCellsRow\r\n        });\r\n        return result\r\n    }\r\n    _addKeysToCells(viewDataMap) {\r\n        var totalColumnCount = viewDataMap[0].length;\r\n        var {\r\n            currentViewDataMap: result\r\n        } = viewDataMap.reduce((_ref, row, rowIndex) => {\r\n            var {\r\n                allDayPanelsCount: allDayPanelsCount,\r\n                currentViewDataMap: currentViewDataMap\r\n            } = _ref;\r\n            var isAllDay = row[0].allDay;\r\n            var keyBase = (rowIndex - allDayPanelsCount) * totalColumnCount;\r\n            var currentAllDayPanelsCount = isAllDay ? allDayPanelsCount + 1 : allDayPanelsCount;\r\n            currentViewDataMap[rowIndex].forEach((cell, columnIndex) => {\r\n                cell.key = keyBase + columnIndex\r\n            });\r\n            return {\r\n                allDayPanelsCount: currentAllDayPanelsCount,\r\n                currentViewDataMap: currentViewDataMap\r\n            }\r\n        }, {\r\n            allDayPanelsCount: 0,\r\n            currentViewDataMap: viewDataMap\r\n        });\r\n        return result\r\n    }\r\n    generateViewDataMap(completeViewDataMap, options) {\r\n        var {\r\n            rowCount: rowCount,\r\n            startCellIndex: startCellIndex,\r\n            startRowIndex: startRowIndex,\r\n            cellCount: cellCount,\r\n            isVerticalGrouping: isVerticalGrouping,\r\n            isAllDayPanelVisible: isAllDayPanelVisible\r\n        } = options;\r\n        var sliceCells = (row, rowIndex, startIndex, count) => {\r\n            var sliceToIndex = void 0 !== count ? startIndex + count : void 0;\r\n            return row.slice(startIndex, sliceToIndex).map((cellData, columnIndex) => ({\r\n                cellData: cellData,\r\n                position: {\r\n                    rowIndex: rowIndex,\r\n                    columnIndex: columnIndex\r\n                }\r\n            }))\r\n        };\r\n        var correctedStartRowIndex = startRowIndex;\r\n        var allDayPanelMap = [];\r\n        if (this._isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible)) {\r\n            correctedStartRowIndex++;\r\n            allDayPanelMap = sliceCells(completeViewDataMap[0], 0, startCellIndex, cellCount)\r\n        }\r\n        var displayedRowCount = getDisplayedRowCount(rowCount, completeViewDataMap);\r\n        var dateTableMap = completeViewDataMap.slice(correctedStartRowIndex, correctedStartRowIndex + displayedRowCount).map((row, rowIndex) => sliceCells(row, rowIndex, startCellIndex, cellCount));\r\n        return {\r\n            allDayPanelMap: allDayPanelMap,\r\n            dateTableMap: dateTableMap\r\n        }\r\n    }\r\n    _isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible) {\r\n        return !isVerticalGrouping && isAllDayPanelVisible\r\n    }\r\n    getViewDataFromMap(completeViewDataMap, viewDataMap, options) {\r\n        var {\r\n            topVirtualRowHeight: topVirtualRowHeight,\r\n            bottomVirtualRowHeight: bottomVirtualRowHeight,\r\n            leftVirtualCellWidth: leftVirtualCellWidth,\r\n            rightVirtualCellWidth: rightVirtualCellWidth,\r\n            cellCount: cellCount,\r\n            rowCount: rowCount,\r\n            startRowIndex: startRowIndex,\r\n            startCellIndex: startCellIndex,\r\n            isProvideVirtualCellsWidth: isProvideVirtualCellsWidth,\r\n            isGroupedAllDayPanel: isGroupedAllDayPanel,\r\n            isVerticalGrouping: isVerticalGrouping,\r\n            isAllDayPanelVisible: isAllDayPanelVisible\r\n        } = options;\r\n        var {\r\n            allDayPanelMap: allDayPanelMap,\r\n            dateTableMap: dateTableMap\r\n        } = viewDataMap;\r\n        var {\r\n            groupedData: groupedData\r\n        } = dateTableMap.reduce((_ref2, cellsRow) => {\r\n            var {\r\n                previousGroupIndex: previousGroupIndex,\r\n                groupedData: groupedData\r\n            } = _ref2;\r\n            var cellDataRow = cellsRow.map(_ref3 => {\r\n                var {\r\n                    cellData: cellData\r\n                } = _ref3;\r\n                return cellData\r\n            });\r\n            var firstCell = cellDataRow[0];\r\n            var isAllDayRow = firstCell.allDay;\r\n            var currentGroupIndex = firstCell.groupIndex;\r\n            if (currentGroupIndex !== previousGroupIndex) {\r\n                groupedData.push({\r\n                    dateTable: [],\r\n                    isGroupedAllDayPanel: getIsGroupedAllDayPanel(!!isAllDayRow, isVerticalGrouping),\r\n                    groupIndex: currentGroupIndex,\r\n                    key: getKeyByGroup(currentGroupIndex, isVerticalGrouping)\r\n                })\r\n            }\r\n            if (isAllDayRow) {\r\n                groupedData[groupedData.length - 1].allDayPanel = cellDataRow\r\n            } else {\r\n                groupedData[groupedData.length - 1].dateTable.push({\r\n                    cells: cellDataRow,\r\n                    key: cellDataRow[0].key - startCellIndex\r\n                })\r\n            }\r\n            return {\r\n                groupedData: groupedData,\r\n                previousGroupIndex: currentGroupIndex\r\n            }\r\n        }, {\r\n            previousGroupIndex: -1,\r\n            groupedData: []\r\n        });\r\n        if (this._isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible)) {\r\n            groupedData[0].allDayPanel = allDayPanelMap.map(_ref4 => {\r\n                var {\r\n                    cellData: cellData\r\n                } = _ref4;\r\n                return cellData\r\n            })\r\n        }\r\n        var totalCellCount = getTotalCellCountByCompleteData(completeViewDataMap);\r\n        var totalRowCount = getTotalRowCountByCompleteData(completeViewDataMap);\r\n        var displayedCellCount = getDisplayedCellCount(cellCount, completeViewDataMap);\r\n        var displayedRowCount = getDisplayedRowCount(rowCount, completeViewDataMap);\r\n        return {\r\n            groupedData: groupedData,\r\n            topVirtualRowHeight: topVirtualRowHeight,\r\n            bottomVirtualRowHeight: bottomVirtualRowHeight,\r\n            leftVirtualCellWidth: isProvideVirtualCellsWidth ? leftVirtualCellWidth : void 0,\r\n            rightVirtualCellWidth: isProvideVirtualCellsWidth ? rightVirtualCellWidth : void 0,\r\n            isGroupedAllDayPanel: isGroupedAllDayPanel,\r\n            leftVirtualCellCount: startCellIndex,\r\n            rightVirtualCellCount: void 0 === cellCount ? 0 : totalCellCount - startCellIndex - displayedCellCount,\r\n            topVirtualRowCount: startRowIndex,\r\n            bottomVirtualRowCount: totalRowCount - startRowIndex - displayedRowCount\r\n        }\r\n    }\r\n    _generateViewCellsData(options, rowCount, cellCountInGroupRow) {\r\n        var viewCellsData = [];\r\n        for (var rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {\r\n            viewCellsData.push(this._generateCellsRow(options, false, rowIndex, rowCount, cellCountInGroupRow))\r\n        }\r\n        return viewCellsData\r\n    }\r\n    _generateAllDayPanelData(options, rowCount, columnCount) {\r\n        if (!options.isAllDayPanelVisible) {\r\n            return null\r\n        }\r\n        return this._generateCellsRow(options, true, 0, rowCount, columnCount)\r\n    }\r\n    _generateCellsRow(options, allDay, rowIndex, rowCount, columnCount) {\r\n        var cellsRow = [];\r\n        for (var columnIndex = 0; columnIndex < columnCount; ++columnIndex) {\r\n            var cellDataValue = this.getCellData(rowIndex, columnIndex, options, allDay);\r\n            cellDataValue.index = rowIndex * columnCount + columnIndex;\r\n            cellDataValue.isFirstGroupCell = this._isFirstGroupCell(rowIndex, columnIndex, options, rowCount, columnCount);\r\n            cellDataValue.isLastGroupCell = this._isLastGroupCell(rowIndex, columnIndex, options, rowCount, columnCount);\r\n            cellsRow.push(cellDataValue)\r\n        }\r\n        return cellsRow\r\n    }\r\n    getCellData(rowIndex, columnIndex, options, allDay) {\r\n        return allDay ? this.prepareAllDayCellData(options, rowIndex, columnIndex) : this.prepareCellData(options, rowIndex, columnIndex)\r\n    }\r\n    prepareCellData(options, rowIndex, columnIndex) {\r\n        var {\r\n            groups: groups,\r\n            startDayHour: startDayHour,\r\n            endDayHour: endDayHour,\r\n            interval: interval,\r\n            hoursInterval: hoursInterval\r\n        } = options;\r\n        var groupsList = getAllGroups(groups);\r\n        var startDate = this.getDateByCellIndices(options, rowIndex, columnIndex, this.getCellCountInDay(startDayHour, endDayHour, hoursInterval));\r\n        var endDate = this.calculateEndDate(startDate, interval, endDayHour);\r\n        var data = {\r\n            startDate: startDate,\r\n            endDate: endDate,\r\n            allDay: this.tableAllDay,\r\n            groupIndex: 0\r\n        };\r\n        if (groupsList.length > 0) {\r\n            data.groups = groupsList[0]\r\n        }\r\n        return data\r\n    }\r\n    prepareAllDayCellData(options, rowIndex, columnIndex) {\r\n        var data = this.prepareCellData(options, rowIndex, columnIndex);\r\n        var startDate = dateUtils.trimTime(data.startDate);\r\n        return _extends({}, data, {\r\n            startDate: startDate,\r\n            endDate: startDate,\r\n            allDay: true\r\n        })\r\n    }\r\n    getDateByCellIndices(options, rowIndex, columnIndex, cellCountInDay) {\r\n        var startViewDate = options.startViewDate;\r\n        var {\r\n            startDayHour: startDayHour,\r\n            interval: interval,\r\n            firstDayOfWeek: firstDayOfWeek,\r\n            intervalCount: intervalCount\r\n        } = options;\r\n        var isStartViewDateDuringDST = startViewDate.getHours() !== Math.floor(startDayHour);\r\n        if (isStartViewDateDuringDST) {\r\n            var dateWithCorrectHours = getStartViewDateWithoutDST(startViewDate, startDayHour);\r\n            startViewDate = new Date(dateWithCorrectHours - dateUtils.dateToMilliseconds(\"day\"))\r\n        }\r\n        var columnCountBase = this.getCellCount(options);\r\n        var rowCountBase = this.getRowCount(options);\r\n        var cellIndex = this._calculateCellIndex(rowIndex, columnIndex, rowCountBase, columnCountBase);\r\n        var millisecondsOffset = this.getMillisecondsOffset(cellIndex, interval, cellCountInDay);\r\n        var offsetByCount = this.isWorkView ? this.getTimeOffsetByColumnIndex(columnIndex, this.getFirstDayOfWeek(firstDayOfWeek), columnCountBase, intervalCount) : 0;\r\n        var startViewDateTime = startViewDate.getTime();\r\n        var currentDate = new Date(startViewDateTime + millisecondsOffset + offsetByCount);\r\n        var timeZoneDifference = isStartViewDateDuringDST ? 0 : dateUtils.getTimezonesDifference(startViewDate, currentDate);\r\n        currentDate.setTime(currentDate.getTime() + timeZoneDifference);\r\n        return currentDate\r\n    }\r\n    getMillisecondsOffset(cellIndex, interval, cellCountInDay) {\r\n        var dayIndex = Math.floor(cellIndex / cellCountInDay);\r\n        var realHiddenInterval = dayIndex * this.hiddenInterval;\r\n        return interval * cellIndex + realHiddenInterval\r\n    }\r\n    getTimeOffsetByColumnIndex(columnIndex, firstDayOfWeek, columnCount, intervalCount) {\r\n        var firstDayOfWeekDiff = Math.max(0, firstDayOfWeek - 1);\r\n        var columnsInWeek = columnCount / intervalCount;\r\n        var weekendCount = Math.floor((columnIndex + firstDayOfWeekDiff) / columnsInWeek);\r\n        return DAY_MS * weekendCount * 2\r\n    }\r\n    calculateEndDate(startDate, interval, endDayHour) {\r\n        var result = new Date(startDate);\r\n        result.setMilliseconds(result.getMilliseconds() + Math.round(interval));\r\n        return result\r\n    }\r\n    _calculateCellIndex(rowIndex, columnIndex, rowCount, columnCount) {\r\n        return calculateCellIndex(rowIndex, columnIndex, rowCount)\r\n    }\r\n    generateGroupedDataMap(viewDataMap) {\r\n        var {\r\n            allDayPanelMap: allDayPanelMap,\r\n            dateTableMap: dateTableMap\r\n        } = viewDataMap;\r\n        var {\r\n            previousGroupedDataMap: dateTableGroupedMap\r\n        } = dateTableMap.reduce((previousOptions, cellsRow) => {\r\n            var {\r\n                previousGroupedDataMap: previousGroupedDataMap,\r\n                previousRowIndex: previousRowIndex,\r\n                previousGroupIndex: previousGroupIndex\r\n            } = previousOptions;\r\n            var {\r\n                groupIndex: currentGroupIndex\r\n            } = cellsRow[0].cellData;\r\n            var currentRowIndex = currentGroupIndex === previousGroupIndex ? previousRowIndex + 1 : 0;\r\n            cellsRow.forEach(cell => {\r\n                var {\r\n                    groupIndex: groupIndex\r\n                } = cell.cellData;\r\n                if (!previousGroupedDataMap[groupIndex]) {\r\n                    previousGroupedDataMap[groupIndex] = []\r\n                }\r\n                if (!previousGroupedDataMap[groupIndex][currentRowIndex]) {\r\n                    previousGroupedDataMap[groupIndex][currentRowIndex] = []\r\n                }\r\n                previousGroupedDataMap[groupIndex][currentRowIndex].push(cell)\r\n            });\r\n            return {\r\n                previousGroupedDataMap: previousGroupedDataMap,\r\n                previousRowIndex: currentRowIndex,\r\n                previousGroupIndex: currentGroupIndex\r\n            }\r\n        }, {\r\n            previousGroupedDataMap: [],\r\n            previousRowIndex: -1,\r\n            previousGroupIndex: -1\r\n        });\r\n        var allDayPanelGroupedMap = [];\r\n        null === allDayPanelMap || void 0 === allDayPanelMap ? void 0 : allDayPanelMap.forEach(cell => {\r\n            var {\r\n                groupIndex: groupIndex\r\n            } = cell.cellData;\r\n            if (!allDayPanelGroupedMap[groupIndex]) {\r\n                allDayPanelGroupedMap[groupIndex] = []\r\n            }\r\n            allDayPanelGroupedMap[groupIndex].push(cell)\r\n        });\r\n        return {\r\n            allDayPanelGroupedMap: allDayPanelGroupedMap,\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        }\r\n    }\r\n    _isFirstGroupCell(rowIndex, columnIndex, options, rowCount, columnCount) {\r\n        var {\r\n            groupOrientation: groupOrientation,\r\n            groups: groups,\r\n            isGroupedByDate: isGroupedByDate\r\n        } = options;\r\n        var groupCount = getGroupCount(groups);\r\n        if (isGroupedByDate) {\r\n            return columnIndex % groupCount === 0\r\n        }\r\n        if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\r\n            return columnIndex % columnCount === 0\r\n        }\r\n        return rowIndex % rowCount === 0\r\n    }\r\n    _isLastGroupCell(rowIndex, columnIndex, options, rowCount, columnCount) {\r\n        var {\r\n            groupOrientation: groupOrientation,\r\n            groups: groups,\r\n            isGroupedByDate: isGroupedByDate\r\n        } = options;\r\n        var groupCount = getGroupCount(groups);\r\n        if (isGroupedByDate) {\r\n            return (columnIndex + 1) % groupCount === 0\r\n        }\r\n        if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\r\n            return (columnIndex + 1) % columnCount === 0\r\n        }\r\n        return (rowIndex + 1) % rowCount === 0\r\n    }\r\n    markSelectedAndFocusedCells(viewDataMap, renderOptions) {\r\n        var {\r\n            selectedCells: selectedCells,\r\n            focusedCell: focusedCell\r\n        } = renderOptions;\r\n        if (!selectedCells && !focusedCell) {\r\n            return viewDataMap\r\n        }\r\n        var {\r\n            allDayPanelMap: allDayPanelMap,\r\n            dateTableMap: dateTableMap\r\n        } = viewDataMap;\r\n        var nextDateTableMap = dateTableMap.map(row => this._markSelectedAndFocusedCellsInRow(row, selectedCells, focusedCell));\r\n        var nextAllDayMap = this._markSelectedAndFocusedCellsInRow(allDayPanelMap, selectedCells, focusedCell);\r\n        return {\r\n            allDayPanelMap: nextAllDayMap,\r\n            dateTableMap: nextDateTableMap\r\n        }\r\n    }\r\n    _markSelectedAndFocusedCellsInRow(dataRow, selectedCells, focusedCell) {\r\n        return dataRow.map(cell => {\r\n            var {\r\n                index: index,\r\n                groupIndex: groupIndex,\r\n                allDay: allDay,\r\n                startDate: startDate\r\n            } = cell.cellData;\r\n            var indexInSelectedCells = selectedCells.findIndex(_ref5 => {\r\n                var {\r\n                    index: selectedCellIndex,\r\n                    groupIndex: selectedCellGroupIndex,\r\n                    allDay: selectedCellAllDay,\r\n                    startDate: selectedCellStartDate\r\n                } = _ref5;\r\n                return groupIndex === selectedCellGroupIndex && (index === selectedCellIndex || void 0 === selectedCellIndex && startDate.getTime() === selectedCellStartDate.getTime()) && !!allDay === !!selectedCellAllDay\r\n            });\r\n            var isFocused = !!focusedCell && index === focusedCell.cellData.index && groupIndex === focusedCell.cellData.groupIndex && allDay === focusedCell.cellData.allDay;\r\n            if (!isFocused && -1 === indexInSelectedCells) {\r\n                return cell\r\n            }\r\n            return _extends({}, cell, {\r\n                cellData: _extends({}, cell.cellData, {\r\n                    isSelected: indexInSelectedCells > -1,\r\n                    isFocused: isFocused\r\n                })\r\n            })\r\n        })\r\n    }\r\n    getInterval(hoursInterval) {\r\n        return hoursInterval * HOUR_MS\r\n    }\r\n    _getIntervalDuration(intervalCount) {\r\n        return dateUtils.dateToMilliseconds(\"day\") * intervalCount\r\n    }\r\n    _setVisibilityDates() {}\r\n    getCellCountInDay(startDayHour, endDayHour, hoursInterval) {\r\n        var result = calculateDayDuration(startDayHour, endDayHour) / hoursInterval;\r\n        return Math.ceil(result)\r\n    }\r\n    getCellCount(options) {\r\n        var {\r\n            intervalCount: intervalCount,\r\n            viewType: viewType,\r\n            startDayHour: startDayHour,\r\n            endDayHour: endDayHour,\r\n            hoursInterval: hoursInterval\r\n        } = options;\r\n        var cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\r\n        var columnCountInDay = isHorizontalView(viewType) ? cellCountInDay : 1;\r\n        return this.daysInInterval * intervalCount * columnCountInDay\r\n    }\r\n    getRowCount(options) {\r\n        var {\r\n            viewType: viewType,\r\n            startDayHour: startDayHour,\r\n            endDayHour: endDayHour,\r\n            hoursInterval: hoursInterval\r\n        } = options;\r\n        var cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\r\n        var rowCountInDay = !isHorizontalView(viewType) ? cellCountInDay : 1;\r\n        return rowCountInDay\r\n    }\r\n    setHiddenInterval(startDayHour, endDayHour, hoursInterval) {\r\n        this.hiddenInterval = DAY_MS - this.getVisibleDayDuration(startDayHour, endDayHour, hoursInterval)\r\n    }\r\n    getVisibleDayDuration(startDayHour, endDayHour, hoursInterval) {\r\n        var cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\r\n        return hoursInterval * cellCountInDay * HOUR_MS\r\n    }\r\n    getFirstDayOfWeek(firstDayOfWeekOption) {\r\n        return firstDayOfWeekOption\r\n    }\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,QAAP,MAAqB,oCAArB;AACA,OAAOC,SAAP,MAAsB,6BAAtB;AACA,SACIC,4BADJ,QAEO,iBAFP;AAGA,SACIC,YADJ,EAEIC,aAFJ,QAGO,uBAHP;AAIA,SACIC,kBADJ,EAEIC,oBAFJ,EAGIC,gBAHJ,EAIIC,0BAJJ,EAKIC,oBALJ,EAMIC,+BANJ,EAOIC,8BAPJ,EAQIC,qBARJ,QASO,yEATP;AAUA,SACIC,uBADJ,EAEIC,aAFJ,QAGO,sDAHP;AAIA,IAAIC,OAAO,GAAGd,SAAS,CAACe,kBAAV,CAA6B,MAA7B,CAAd;AACA,IAAIC,MAAM,GAAGhB,SAAS,CAACe,kBAAV,CAA6B,KAA7B,CAAb;AACA,OAAO,MAAME,iBAAN,CAAwB;EACT,IAAdC,cAAc,GAAG;IACjB,OAAO,CAAP;EACH;;EACa,IAAVC,UAAU,GAAG;IACb,OAAO,KAAP;EACH;;EACc,IAAXC,WAAW,GAAG;IACd,OAAO,KAAP;EACH;;EACDC,aAAa,GAAG;IACZ,OAAO,KAAP;EACH;;EACDC,gBAAgB,CAACC,OAAD,EAAU;IACtB,OAAO,KAAKC,uBAAL,CAA6BD,OAA7B,CAAP;EACH;;EACDE,sBAAsB,CAACF,OAAD,EAAU;IAC5B,IAAI;MACAG,MAAM,EAAEA,MADR;MAEAC,eAAe,EAAEA,eAFjB;MAGAC,oBAAoB,EAAEA,oBAHtB;MAIAC,kBAAkB,EAAEA,kBAJpB;MAKAC,aAAa,EAAEA,aALf;MAMAC,WAAW,EAAEA,WANb;MAOAC,QAAQ,EAAEA,QAPV;MAQAC,YAAY,EAAEA,YARd;MASAC,UAAU,EAAEA,UATZ;MAUAC,aAAa,EAAEA;IAVf,IAWAZ,OAXJ;;IAYA,KAAKa,mBAAL,CAAyBb,OAAzB;;IACA,KAAKc,iBAAL,CAAuBJ,YAAvB,EAAqCC,UAArC,EAAiDC,aAAjD;IACA,IAAIG,UAAU,GAAGpC,YAAY,CAACwB,MAAD,CAA7B;IACA,IAAIa,mBAAmB,GAAG,KAAKC,YAAL,CAAkB;MACxCV,aAAa,EAAEA,aADyB;MAExCC,WAAW,EAAEA,WAF2B;MAGxCC,QAAQ,EAAEA,QAH8B;MAIxCC,YAAY,EAAEA,YAJ0B;MAKxCC,UAAU,EAAEA,UAL4B;MAMxCC,aAAa,EAAEA;IANyB,CAAlB,CAA1B;IAQA,IAAIM,eAAe,GAAG,KAAKC,WAAL,CAAiB;MACnCZ,aAAa,EAAEA,aADoB;MAEnCC,WAAW,EAAEA,WAFsB;MAGnCC,QAAQ,EAAEA,QAHyB;MAInCG,aAAa,EAAEA,aAJoB;MAKnCF,YAAY,EAAEA,YALqB;MAMnCC,UAAU,EAAEA;IANuB,CAAjB,CAAtB;IAQA,IAAIS,WAAW,GAAG,EAAlB;;IACA,IAAIC,eAAe,GAAG,KAAKC,wBAAL,CAA8BtB,OAA9B,EAAuCkB,eAAvC,EAAwDF,mBAAxD,CAAtB;;IACA,IAAIO,aAAa,GAAG,KAAKC,sBAAL,CAA4BxB,OAA5B,EAAqCkB,eAArC,EAAsDF,mBAAtD,CAApB;;IACAK,eAAe,IAAID,WAAW,CAACK,IAAZ,CAAiBJ,eAAjB,CAAnB;IACAD,WAAW,CAACK,IAAZ,CAAiB,GAAGF,aAApB;;IACA,IAAIlB,oBAAoB,IAAI,CAACD,eAA7B,EAA8C;MAC1CgB,WAAW,GAAG,KAAKM,0CAAL,CAAgDN,WAAhD,EAA6DL,UAA7D,CAAd;IACH;;IACD,IAAIT,kBAAJ,EAAwB;MACpBc,WAAW,GAAG,KAAKO,wCAAL,CAA8CP,WAA9C,EAA2DL,UAA3D,CAAd;IACH;;IACD,IAAIX,eAAJ,EAAqB;MACjBgB,WAAW,GAAG,KAAKQ,sCAAL,CAA4CR,WAA5C,EAAyDL,UAAzD,CAAd;IACH;;IACD,IAAIc,mBAAmB,GAAG,KAAKC,eAAL,CAAqBV,WAArB,CAA1B;;IACA,OAAOS,mBAAP;EACH;;EACDH,0CAA0C,CAACN,WAAD,EAAcL,UAAd,EAA0B;IAChE,IAAIgB,MAAM,GAAGX,WAAW,CAACY,GAAZ,CAAgBC,GAAG,IAAIA,GAAG,CAACC,KAAJ,EAAvB,CAAb;IACAnB,UAAU,CAACmB,KAAX,CAAiB,CAAjB,EAAoBC,OAApB,CAA4B,CAAChC,MAAD,EAASiC,KAAT,KAAmB;MAC3C,IAAIC,UAAU,GAAGD,KAAK,GAAG,CAAzB;MACAhB,WAAW,CAACe,OAAZ,CAAoB,CAACF,GAAD,EAAMK,QAAN,KAAmB;QACnC,IAAIC,YAAY,GAAGN,GAAG,CAACD,GAAJ,CAAQQ,QAAQ,IAAIhE,QAAQ,CAAC,EAAD,EAAKgE,QAAL,EAAe;UAC1DrC,MAAM,EAAEA,MADkD;UAE1DkC,UAAU,EAAEA;QAF8C,CAAf,CAA5B,CAAnB;QAIAN,MAAM,CAACO,QAAD,CAAN,CAAiBb,IAAjB,CAAsB,GAAGc,YAAzB;MACH,CAND;IAOH,CATD;IAUA,OAAOR,MAAP;EACH;;EACDJ,wCAAwC,CAACP,WAAD,EAAcL,UAAd,EAA0B;IAC9D,IAAIgB,MAAM,GAAGX,WAAW,CAACY,GAAZ,CAAgBC,GAAG,IAAIA,GAAG,CAACC,KAAJ,EAAvB,CAAb;IACAnB,UAAU,CAACmB,KAAX,CAAiB,CAAjB,EAAoBC,OAApB,CAA4B,CAAChC,MAAD,EAASiC,KAAT,KAAmB;MAC3C,IAAIC,UAAU,GAAGD,KAAK,GAAG,CAAzB;MACA,IAAIK,YAAY,GAAGrB,WAAW,CAACY,GAAZ,CAAgBU,QAAQ,IAAI;QAC3C,IAAIC,OAAO,GAAGD,QAAQ,CAACV,GAAT,CAAaQ,QAAQ,IAAIhE,QAAQ,CAAC,EAAD,EAAKgE,QAAL,EAAe;UAC1DH,UAAU,EAAEA,UAD8C;UAE1DlC,MAAM,EAAEA;QAFkD,CAAf,CAAjC,CAAd;QAIA,OAAOwC,OAAP;MACH,CANkB,CAAnB;MAOAZ,MAAM,CAACN,IAAP,CAAY,GAAGgB,YAAf;IACH,CAVD;IAWA,OAAOV,MAAP;EACH;;EACDH,sCAAsC,CAACR,WAAD,EAAcL,UAAd,EAA0B;IAC5D,IAAI6B,kBAAkB,GAAG7B,UAAU,CAACmB,KAAX,CAAiB,CAAjB,CAAzB;IACA,IAAIW,mBAAmB,GAAGD,kBAAkB,CAACE,MAA7C;IACA,IAAIf,MAAM,GAAGX,WAAW,CAACY,GAAZ,CAAgBU,QAAQ,IAAI;MACrC,IAAIK,qBAAqB,GAAGL,QAAQ,CAACM,MAAT,CAAgB,CAACC,UAAD,EAAaC,IAAb,KAAsB;QAC9D,IAAIC,kBAAkB,GAAG,CAAC,GAAGF,UAAJ,EAAgBzE,QAAQ,CAAC,EAAD,EAAK0E,IAAL,EAAW;UACxDE,gBAAgB,EAAE,IADsC;UAExDC,eAAe,EAAE,MAAMR;QAFiC,CAAX,CAAxB,EAGrB,GAAGD,kBAAkB,CAACZ,GAAnB,CAAuB,CAAC7B,MAAD,EAASiC,KAAT,KAAmB5D,QAAQ,CAAC,EAAD,EAAK0E,IAAL,EAAW;UAChE/C,MAAM,EAAEA,MADwD;UAEhEkC,UAAU,EAAED,KAAK,GAAG,CAF4C;UAGhEgB,gBAAgB,EAAE,KAH8C;UAIhEC,eAAe,EAAEjB,KAAK,KAAKS,mBAAmB,GAAG;QAJe,CAAX,CAAlD,CAHkB,CAAzB;QASA,OAAOM,kBAAP;MACH,CAX2B,EAWzB,EAXyB,CAA5B;MAYA,OAAOJ,qBAAP;IACH,CAdY,CAAb;IAeA,OAAOhB,MAAP;EACH;;EACDD,eAAe,CAACV,WAAD,EAAc;IACzB,IAAIkC,gBAAgB,GAAGlC,WAAW,CAAC,CAAD,CAAX,CAAe0B,MAAtC;IACA,IAAI;MACAS,kBAAkB,EAAExB;IADpB,IAEAX,WAAW,CAAC4B,MAAZ,CAAmB,CAACQ,IAAD,EAAOvB,GAAP,EAAYK,QAAZ,KAAyB;MAC5C,IAAI;QACAmB,iBAAiB,EAAEA,iBADnB;QAEAF,kBAAkB,EAAEA;MAFpB,IAGAC,IAHJ;MAIA,IAAIE,QAAQ,GAAGzB,GAAG,CAAC,CAAD,CAAH,CAAO0B,MAAtB;MACA,IAAIC,OAAO,GAAG,CAACtB,QAAQ,GAAGmB,iBAAZ,IAAiCH,gBAA/C;MACA,IAAIO,wBAAwB,GAAGH,QAAQ,GAAGD,iBAAiB,GAAG,CAAvB,GAA2BA,iBAAlE;MACAF,kBAAkB,CAACjB,QAAD,CAAlB,CAA6BH,OAA7B,CAAqC,CAACe,IAAD,EAAOY,WAAP,KAAuB;QACxDZ,IAAI,CAACa,GAAL,GAAWH,OAAO,GAAGE,WAArB;MACH,CAFD;MAGA,OAAO;QACHL,iBAAiB,EAAEI,wBADhB;QAEHN,kBAAkB,EAAEA;MAFjB,CAAP;IAIH,CAfG,EAeD;MACCE,iBAAiB,EAAE,CADpB;MAECF,kBAAkB,EAAEnC;IAFrB,CAfC,CAFJ;IAqBA,OAAOW,MAAP;EACH;;EACDiC,mBAAmB,CAACnC,mBAAD,EAAsB7B,OAAtB,EAA+B;IAC9C,IAAI;MACAiE,QAAQ,EAAEA,QADV;MAEAC,cAAc,EAAEA,cAFhB;MAGAC,aAAa,EAAEA,aAHf;MAIAC,SAAS,EAAEA,SAJX;MAKA9D,kBAAkB,EAAEA,kBALpB;MAMA+D,oBAAoB,EAAEA;IANtB,IAOArE,OAPJ;;IAQA,IAAIsE,UAAU,GAAG,CAACrC,GAAD,EAAMK,QAAN,EAAgBiC,UAAhB,EAA4BC,KAA5B,KAAsC;MACnD,IAAIC,YAAY,GAAG,KAAK,CAAL,KAAWD,KAAX,GAAmBD,UAAU,GAAGC,KAAhC,GAAwC,KAAK,CAAhE;MACA,OAAOvC,GAAG,CAACC,KAAJ,CAAUqC,UAAV,EAAsBE,YAAtB,EAAoCzC,GAApC,CAAwC,CAACQ,QAAD,EAAWsB,WAAX,MAA4B;QACvEtB,QAAQ,EAAEA,QAD6D;QAEvEkC,QAAQ,EAAE;UACNpC,QAAQ,EAAEA,QADJ;UAENwB,WAAW,EAAEA;QAFP;MAF6D,CAA5B,CAAxC,CAAP;IAOH,CATD;;IAUA,IAAIa,sBAAsB,GAAGR,aAA7B;IACA,IAAIS,cAAc,GAAG,EAArB;;IACA,IAAI,KAAKC,wBAAL,CAA8BvE,kBAA9B,EAAkD+D,oBAAlD,CAAJ,EAA6E;MACzEM,sBAAsB;MACtBC,cAAc,GAAGN,UAAU,CAACzC,mBAAmB,CAAC,CAAD,CAApB,EAAyB,CAAzB,EAA4BqC,cAA5B,EAA4CE,SAA5C,CAA3B;IACH;;IACD,IAAIU,iBAAiB,GAAG7F,oBAAoB,CAACgF,QAAD,EAAWpC,mBAAX,CAA5C;IACA,IAAIkD,YAAY,GAAGlD,mBAAmB,CAACK,KAApB,CAA0ByC,sBAA1B,EAAkDA,sBAAsB,GAAGG,iBAA3E,EAA8F9C,GAA9F,CAAkG,CAACC,GAAD,EAAMK,QAAN,KAAmBgC,UAAU,CAACrC,GAAD,EAAMK,QAAN,EAAgB4B,cAAhB,EAAgCE,SAAhC,CAA/H,CAAnB;IACA,OAAO;MACHQ,cAAc,EAAEA,cADb;MAEHG,YAAY,EAAEA;IAFX,CAAP;EAIH;;EACDF,wBAAwB,CAACvE,kBAAD,EAAqB+D,oBAArB,EAA2C;IAC/D,OAAO,CAAC/D,kBAAD,IAAuB+D,oBAA9B;EACH;;EACDW,kBAAkB,CAACnD,mBAAD,EAAsBT,WAAtB,EAAmCpB,OAAnC,EAA4C;IAC1D,IAAI;MACAiF,mBAAmB,EAAEA,mBADrB;MAEAC,sBAAsB,EAAEA,sBAFxB;MAGAC,oBAAoB,EAAEA,oBAHtB;MAIAC,qBAAqB,EAAEA,qBAJvB;MAKAhB,SAAS,EAAEA,SALX;MAMAH,QAAQ,EAAEA,QANV;MAOAE,aAAa,EAAEA,aAPf;MAQAD,cAAc,EAAEA,cARhB;MASAmB,0BAA0B,EAAEA,0BAT5B;MAUAC,oBAAoB,EAAEA,oBAVtB;MAWAhF,kBAAkB,EAAEA,kBAXpB;MAYA+D,oBAAoB,EAAEA;IAZtB,IAaArE,OAbJ;IAcA,IAAI;MACA4E,cAAc,EAAEA,cADhB;MAEAG,YAAY,EAAEA;IAFd,IAGA3D,WAHJ;IAIA,IAAI;MACAmE,WAAW,EAAEA;IADb,IAEAR,YAAY,CAAC/B,MAAb,CAAoB,CAACwC,KAAD,EAAQ9C,QAAR,KAAqB;MACzC,IAAI;QACA+C,kBAAkB,EAAEA,kBADpB;QAEAF,WAAW,EAAEA;MAFb,IAGAC,KAHJ;MAIA,IAAIE,WAAW,GAAGhD,QAAQ,CAACV,GAAT,CAAa2D,KAAK,IAAI;QACpC,IAAI;UACAnD,QAAQ,EAAEA;QADV,IAEAmD,KAFJ;QAGA,OAAOnD,QAAP;MACH,CALiB,CAAlB;MAMA,IAAIoD,SAAS,GAAGF,WAAW,CAAC,CAAD,CAA3B;MACA,IAAIG,WAAW,GAAGD,SAAS,CAACjC,MAA5B;MACA,IAAImC,iBAAiB,GAAGF,SAAS,CAACvD,UAAlC;;MACA,IAAIyD,iBAAiB,KAAKL,kBAA1B,EAA8C;QAC1CF,WAAW,CAAC9D,IAAZ,CAAiB;UACbsE,SAAS,EAAE,EADE;UAEbT,oBAAoB,EAAEjG,uBAAuB,CAAC,CAAC,CAACwG,WAAH,EAAgBvF,kBAAhB,CAFhC;UAGb+B,UAAU,EAAEyD,iBAHC;UAIb/B,GAAG,EAAEzE,aAAa,CAACwG,iBAAD,EAAoBxF,kBAApB;QAJL,CAAjB;MAMH;;MACD,IAAIuF,WAAJ,EAAiB;QACbN,WAAW,CAACA,WAAW,CAACzC,MAAZ,GAAqB,CAAtB,CAAX,CAAoCkD,WAApC,GAAkDN,WAAlD;MACH,CAFD,MAEO;QACHH,WAAW,CAACA,WAAW,CAACzC,MAAZ,GAAqB,CAAtB,CAAX,CAAoCiD,SAApC,CAA8CtE,IAA9C,CAAmD;UAC/CwE,KAAK,EAAEP,WADwC;UAE/C3B,GAAG,EAAE2B,WAAW,CAAC,CAAD,CAAX,CAAe3B,GAAf,GAAqBG;QAFqB,CAAnD;MAIH;;MACD,OAAO;QACHqB,WAAW,EAAEA,WADV;QAEHE,kBAAkB,EAAEK;MAFjB,CAAP;IAIH,CAlCG,EAkCD;MACCL,kBAAkB,EAAE,CAAC,CADtB;MAECF,WAAW,EAAE;IAFd,CAlCC,CAFJ;;IAwCA,IAAI,KAAKV,wBAAL,CAA8BvE,kBAA9B,EAAkD+D,oBAAlD,CAAJ,EAA6E;MACzEkB,WAAW,CAAC,CAAD,CAAX,CAAeS,WAAf,GAA6BpB,cAAc,CAAC5C,GAAf,CAAmBkE,KAAK,IAAI;QACrD,IAAI;UACA1D,QAAQ,EAAEA;QADV,IAEA0D,KAFJ;QAGA,OAAO1D,QAAP;MACH,CAL4B,CAA7B;IAMH;;IACD,IAAI2D,cAAc,GAAGjH,+BAA+B,CAAC2C,mBAAD,CAApD;IACA,IAAIuE,aAAa,GAAGjH,8BAA8B,CAAC0C,mBAAD,CAAlD;IACA,IAAIwE,kBAAkB,GAAGjH,qBAAqB,CAACgF,SAAD,EAAYvC,mBAAZ,CAA9C;IACA,IAAIiD,iBAAiB,GAAG7F,oBAAoB,CAACgF,QAAD,EAAWpC,mBAAX,CAA5C;IACA,OAAO;MACH0D,WAAW,EAAEA,WADV;MAEHN,mBAAmB,EAAEA,mBAFlB;MAGHC,sBAAsB,EAAEA,sBAHrB;MAIHC,oBAAoB,EAAEE,0BAA0B,GAAGF,oBAAH,GAA0B,KAAK,CAJ5E;MAKHC,qBAAqB,EAAEC,0BAA0B,GAAGD,qBAAH,GAA2B,KAAK,CAL9E;MAMHE,oBAAoB,EAAEA,oBANnB;MAOHgB,oBAAoB,EAAEpC,cAPnB;MAQHqC,qBAAqB,EAAE,KAAK,CAAL,KAAWnC,SAAX,GAAuB,CAAvB,GAA2B+B,cAAc,GAAGjC,cAAjB,GAAkCmC,kBARjF;MASHG,kBAAkB,EAAErC,aATjB;MAUHsC,qBAAqB,EAAEL,aAAa,GAAGjC,aAAhB,GAAgCW;IAVpD,CAAP;EAYH;;EACDtD,sBAAsB,CAACxB,OAAD,EAAUiE,QAAV,EAAoBjD,mBAApB,EAAyC;IAC3D,IAAIO,aAAa,GAAG,EAApB;;IACA,KAAK,IAAIe,QAAQ,GAAG,CAApB,EAAuBA,QAAQ,GAAG2B,QAAlC,EAA4C3B,QAAQ,IAAI,CAAxD,EAA2D;MACvDf,aAAa,CAACE,IAAd,CAAmB,KAAKiF,iBAAL,CAAuB1G,OAAvB,EAAgC,KAAhC,EAAuCsC,QAAvC,EAAiD2B,QAAjD,EAA2DjD,mBAA3D,CAAnB;IACH;;IACD,OAAOO,aAAP;EACH;;EACDD,wBAAwB,CAACtB,OAAD,EAAUiE,QAAV,EAAoB0C,WAApB,EAAiC;IACrD,IAAI,CAAC3G,OAAO,CAACqE,oBAAb,EAAmC;MAC/B,OAAO,IAAP;IACH;;IACD,OAAO,KAAKqC,iBAAL,CAAuB1G,OAAvB,EAAgC,IAAhC,EAAsC,CAAtC,EAAyCiE,QAAzC,EAAmD0C,WAAnD,CAAP;EACH;;EACDD,iBAAiB,CAAC1G,OAAD,EAAU2D,MAAV,EAAkBrB,QAAlB,EAA4B2B,QAA5B,EAAsC0C,WAAtC,EAAmD;IAChE,IAAIjE,QAAQ,GAAG,EAAf;;IACA,KAAK,IAAIoB,WAAW,GAAG,CAAvB,EAA0BA,WAAW,GAAG6C,WAAxC,EAAqD,EAAE7C,WAAvD,EAAoE;MAChE,IAAI8C,aAAa,GAAG,KAAKC,WAAL,CAAiBvE,QAAjB,EAA2BwB,WAA3B,EAAwC9D,OAAxC,EAAiD2D,MAAjD,CAApB;MACAiD,aAAa,CAACxE,KAAd,GAAsBE,QAAQ,GAAGqE,WAAX,GAAyB7C,WAA/C;MACA8C,aAAa,CAACxD,gBAAd,GAAiC,KAAK0D,iBAAL,CAAuBxE,QAAvB,EAAiCwB,WAAjC,EAA8C9D,OAA9C,EAAuDiE,QAAvD,EAAiE0C,WAAjE,CAAjC;MACAC,aAAa,CAACvD,eAAd,GAAgC,KAAK0D,gBAAL,CAAsBzE,QAAtB,EAAgCwB,WAAhC,EAA6C9D,OAA7C,EAAsDiE,QAAtD,EAAgE0C,WAAhE,CAAhC;MACAjE,QAAQ,CAACjB,IAAT,CAAcmF,aAAd;IACH;;IACD,OAAOlE,QAAP;EACH;;EACDmE,WAAW,CAACvE,QAAD,EAAWwB,WAAX,EAAwB9D,OAAxB,EAAiC2D,MAAjC,EAAyC;IAChD,OAAOA,MAAM,GAAG,KAAKqD,qBAAL,CAA2BhH,OAA3B,EAAoCsC,QAApC,EAA8CwB,WAA9C,CAAH,GAAgE,KAAKmD,eAAL,CAAqBjH,OAArB,EAA8BsC,QAA9B,EAAwCwB,WAAxC,CAA7E;EACH;;EACDmD,eAAe,CAACjH,OAAD,EAAUsC,QAAV,EAAoBwB,WAApB,EAAiC;IAC5C,IAAI;MACA3D,MAAM,EAAEA,MADR;MAEAO,YAAY,EAAEA,YAFd;MAGAC,UAAU,EAAEA,UAHZ;MAIAuG,QAAQ,EAAEA,QAJV;MAKAtG,aAAa,EAAEA;IALf,IAMAZ,OANJ;IAOA,IAAIe,UAAU,GAAGpC,YAAY,CAACwB,MAAD,CAA7B;IACA,IAAIgH,SAAS,GAAG,KAAKC,oBAAL,CAA0BpH,OAA1B,EAAmCsC,QAAnC,EAA6CwB,WAA7C,EAA0D,KAAKuD,iBAAL,CAAuB3G,YAAvB,EAAqCC,UAArC,EAAiDC,aAAjD,CAA1D,CAAhB;IACA,IAAI0G,OAAO,GAAG,KAAKC,gBAAL,CAAsBJ,SAAtB,EAAiCD,QAAjC,EAA2CvG,UAA3C,CAAd;IACA,IAAI6G,IAAI,GAAG;MACPL,SAAS,EAAEA,SADJ;MAEPG,OAAO,EAAEA,OAFF;MAGP3D,MAAM,EAAE,KAAK9D,WAHN;MAIPwC,UAAU,EAAE;IAJL,CAAX;;IAMA,IAAItB,UAAU,CAAC+B,MAAX,GAAoB,CAAxB,EAA2B;MACvB0E,IAAI,CAACrH,MAAL,GAAcY,UAAU,CAAC,CAAD,CAAxB;IACH;;IACD,OAAOyG,IAAP;EACH;;EACDR,qBAAqB,CAAChH,OAAD,EAAUsC,QAAV,EAAoBwB,WAApB,EAAiC;IAClD,IAAI0D,IAAI,GAAG,KAAKP,eAAL,CAAqBjH,OAArB,EAA8BsC,QAA9B,EAAwCwB,WAAxC,CAAX;IACA,IAAIqD,SAAS,GAAG1I,SAAS,CAACgJ,QAAV,CAAmBD,IAAI,CAACL,SAAxB,CAAhB;IACA,OAAO3I,QAAQ,CAAC,EAAD,EAAKgJ,IAAL,EAAW;MACtBL,SAAS,EAAEA,SADW;MAEtBG,OAAO,EAAEH,SAFa;MAGtBxD,MAAM,EAAE;IAHc,CAAX,CAAf;EAKH;;EACDyD,oBAAoB,CAACpH,OAAD,EAAUsC,QAAV,EAAoBwB,WAApB,EAAiC4D,cAAjC,EAAiD;IACjE,IAAIC,aAAa,GAAG3H,OAAO,CAAC2H,aAA5B;IACA,IAAI;MACAjH,YAAY,EAAEA,YADd;MAEAwG,QAAQ,EAAEA,QAFV;MAGAU,cAAc,EAAEA,cAHhB;MAIArH,aAAa,EAAEA;IAJf,IAKAP,OALJ;IAMA,IAAI6H,wBAAwB,GAAGF,aAAa,CAACG,QAAd,OAA6BC,IAAI,CAACC,KAAL,CAAWtH,YAAX,CAA5D;;IACA,IAAImH,wBAAJ,EAA8B;MAC1B,IAAII,oBAAoB,GAAGjJ,0BAA0B,CAAC2I,aAAD,EAAgBjH,YAAhB,CAArD;MACAiH,aAAa,GAAG,IAAIO,IAAJ,CAASD,oBAAoB,GAAGxJ,SAAS,CAACe,kBAAV,CAA6B,KAA7B,CAAhC,CAAhB;IACH;;IACD,IAAI2I,eAAe,GAAG,KAAKlH,YAAL,CAAkBjB,OAAlB,CAAtB;IACA,IAAIoI,YAAY,GAAG,KAAKjH,WAAL,CAAiBnB,OAAjB,CAAnB;;IACA,IAAIqI,SAAS,GAAG,KAAKC,mBAAL,CAAyBhG,QAAzB,EAAmCwB,WAAnC,EAAgDsE,YAAhD,EAA8DD,eAA9D,CAAhB;;IACA,IAAII,kBAAkB,GAAG,KAAKC,qBAAL,CAA2BH,SAA3B,EAAsCnB,QAAtC,EAAgDQ,cAAhD,CAAzB;IACA,IAAIe,aAAa,GAAG,KAAK7I,UAAL,GAAkB,KAAK8I,0BAAL,CAAgC5E,WAAhC,EAA6C,KAAK6E,iBAAL,CAAuBf,cAAvB,CAA7C,EAAqFO,eAArF,EAAsG5H,aAAtG,CAAlB,GAAyI,CAA7J;IACA,IAAIqI,iBAAiB,GAAGjB,aAAa,CAACkB,OAAd,EAAxB;IACA,IAAIrI,WAAW,GAAG,IAAI0H,IAAJ,CAASU,iBAAiB,GAAGL,kBAApB,GAAyCE,aAAlD,CAAlB;IACA,IAAIK,kBAAkB,GAAGjB,wBAAwB,GAAG,CAAH,GAAOpJ,SAAS,CAACsK,sBAAV,CAAiCpB,aAAjC,EAAgDnH,WAAhD,CAAxD;IACAA,WAAW,CAACwI,OAAZ,CAAoBxI,WAAW,CAACqI,OAAZ,KAAwBC,kBAA5C;IACA,OAAOtI,WAAP;EACH;;EACDgI,qBAAqB,CAACH,SAAD,EAAYnB,QAAZ,EAAsBQ,cAAtB,EAAsC;IACvD,IAAIuB,QAAQ,GAAGlB,IAAI,CAACC,KAAL,CAAWK,SAAS,GAAGX,cAAvB,CAAf;IACA,IAAIwB,kBAAkB,GAAGD,QAAQ,GAAG,KAAKE,cAAzC;IACA,OAAOjC,QAAQ,GAAGmB,SAAX,GAAuBa,kBAA9B;EACH;;EACDR,0BAA0B,CAAC5E,WAAD,EAAc8D,cAAd,EAA8BjB,WAA9B,EAA2CpG,aAA3C,EAA0D;IAChF,IAAI6I,kBAAkB,GAAGrB,IAAI,CAACsB,GAAL,CAAS,CAAT,EAAYzB,cAAc,GAAG,CAA7B,CAAzB;IACA,IAAI0B,aAAa,GAAG3C,WAAW,GAAGpG,aAAlC;IACA,IAAIgJ,YAAY,GAAGxB,IAAI,CAACC,KAAL,CAAW,CAAClE,WAAW,GAAGsF,kBAAf,IAAqCE,aAAhD,CAAnB;IACA,OAAO7J,MAAM,GAAG8J,YAAT,GAAwB,CAA/B;EACH;;EACDhC,gBAAgB,CAACJ,SAAD,EAAYD,QAAZ,EAAsBvG,UAAtB,EAAkC;IAC9C,IAAIoB,MAAM,GAAG,IAAImG,IAAJ,CAASf,SAAT,CAAb;IACApF,MAAM,CAACyH,eAAP,CAAuBzH,MAAM,CAAC0H,eAAP,KAA2B1B,IAAI,CAAC2B,KAAL,CAAWxC,QAAX,CAAlD;IACA,OAAOnF,MAAP;EACH;;EACDuG,mBAAmB,CAAChG,QAAD,EAAWwB,WAAX,EAAwBG,QAAxB,EAAkC0C,WAAlC,EAA+C;IAC9D,OAAO9H,kBAAkB,CAACyD,QAAD,EAAWwB,WAAX,EAAwBG,QAAxB,CAAzB;EACH;;EACD0F,sBAAsB,CAACvI,WAAD,EAAc;IAChC,IAAI;MACAwD,cAAc,EAAEA,cADhB;MAEAG,YAAY,EAAEA;IAFd,IAGA3D,WAHJ;IAIA,IAAI;MACAwI,sBAAsB,EAAEC;IADxB,IAEA9E,YAAY,CAAC/B,MAAb,CAAoB,CAAC8G,eAAD,EAAkBpH,QAAlB,KAA+B;MACnD,IAAI;QACAkH,sBAAsB,EAAEA,sBADxB;QAEAG,gBAAgB,EAAEA,gBAFlB;QAGAtE,kBAAkB,EAAEA;MAHpB,IAIAqE,eAJJ;MAKA,IAAI;QACAzH,UAAU,EAAEyD;MADZ,IAEApD,QAAQ,CAAC,CAAD,CAAR,CAAYF,QAFhB;MAGA,IAAIwH,eAAe,GAAGlE,iBAAiB,KAAKL,kBAAtB,GAA2CsE,gBAAgB,GAAG,CAA9D,GAAkE,CAAxF;MACArH,QAAQ,CAACP,OAAT,CAAiBe,IAAI,IAAI;QACrB,IAAI;UACAb,UAAU,EAAEA;QADZ,IAEAa,IAAI,CAACV,QAFT;;QAGA,IAAI,CAACoH,sBAAsB,CAACvH,UAAD,CAA3B,EAAyC;UACrCuH,sBAAsB,CAACvH,UAAD,CAAtB,GAAqC,EAArC;QACH;;QACD,IAAI,CAACuH,sBAAsB,CAACvH,UAAD,CAAtB,CAAmC2H,eAAnC,CAAL,EAA0D;UACtDJ,sBAAsB,CAACvH,UAAD,CAAtB,CAAmC2H,eAAnC,IAAsD,EAAtD;QACH;;QACDJ,sBAAsB,CAACvH,UAAD,CAAtB,CAAmC2H,eAAnC,EAAoDvI,IAApD,CAAyDyB,IAAzD;MACH,CAXD;MAYA,OAAO;QACH0G,sBAAsB,EAAEA,sBADrB;QAEHG,gBAAgB,EAAEC,eAFf;QAGHvE,kBAAkB,EAAEK;MAHjB,CAAP;IAKH,CA3BG,EA2BD;MACC8D,sBAAsB,EAAE,EADzB;MAECG,gBAAgB,EAAE,CAAC,CAFpB;MAGCtE,kBAAkB,EAAE,CAAC;IAHtB,CA3BC,CAFJ;IAkCA,IAAIwE,qBAAqB,GAAG,EAA5B;IACA,SAASrF,cAAT,IAA2B,KAAK,CAAL,KAAWA,cAAtC,GAAuD,KAAK,CAA5D,GAAgEA,cAAc,CAACzC,OAAf,CAAuBe,IAAI,IAAI;MAC3F,IAAI;QACAb,UAAU,EAAEA;MADZ,IAEAa,IAAI,CAACV,QAFT;;MAGA,IAAI,CAACyH,qBAAqB,CAAC5H,UAAD,CAA1B,EAAwC;QACpC4H,qBAAqB,CAAC5H,UAAD,CAArB,GAAoC,EAApC;MACH;;MACD4H,qBAAqB,CAAC5H,UAAD,CAArB,CAAkCZ,IAAlC,CAAuCyB,IAAvC;IACH,CAR+D,CAAhE;IASA,OAAO;MACH+G,qBAAqB,EAAEA,qBADpB;MAEHJ,mBAAmB,EAAEA;IAFlB,CAAP;EAIH;;EACD/C,iBAAiB,CAACxE,QAAD,EAAWwB,WAAX,EAAwB9D,OAAxB,EAAiCiE,QAAjC,EAA2C0C,WAA3C,EAAwD;IACrE,IAAI;MACAuD,gBAAgB,EAAEA,gBADlB;MAEA/J,MAAM,EAAEA,MAFR;MAGAC,eAAe,EAAEA;IAHjB,IAIAJ,OAJJ;IAKA,IAAImK,UAAU,GAAGvL,aAAa,CAACuB,MAAD,CAA9B;;IACA,IAAIC,eAAJ,EAAqB;MACjB,OAAO0D,WAAW,GAAGqG,UAAd,KAA6B,CAApC;IACH;;IACD,IAAID,gBAAgB,KAAKxL,4BAAzB,EAAuD;MACnD,OAAOoF,WAAW,GAAG6C,WAAd,KAA8B,CAArC;IACH;;IACD,OAAOrE,QAAQ,GAAG2B,QAAX,KAAwB,CAA/B;EACH;;EACD8C,gBAAgB,CAACzE,QAAD,EAAWwB,WAAX,EAAwB9D,OAAxB,EAAiCiE,QAAjC,EAA2C0C,WAA3C,EAAwD;IACpE,IAAI;MACAuD,gBAAgB,EAAEA,gBADlB;MAEA/J,MAAM,EAAEA,MAFR;MAGAC,eAAe,EAAEA;IAHjB,IAIAJ,OAJJ;IAKA,IAAImK,UAAU,GAAGvL,aAAa,CAACuB,MAAD,CAA9B;;IACA,IAAIC,eAAJ,EAAqB;MACjB,OAAO,CAAC0D,WAAW,GAAG,CAAf,IAAoBqG,UAApB,KAAmC,CAA1C;IACH;;IACD,IAAID,gBAAgB,KAAKxL,4BAAzB,EAAuD;MACnD,OAAO,CAACoF,WAAW,GAAG,CAAf,IAAoB6C,WAApB,KAAoC,CAA3C;IACH;;IACD,OAAO,CAACrE,QAAQ,GAAG,CAAZ,IAAiB2B,QAAjB,KAA8B,CAArC;EACH;;EACDmG,2BAA2B,CAAChJ,WAAD,EAAciJ,aAAd,EAA6B;IACpD,IAAI;MACAC,aAAa,EAAEA,aADf;MAEAC,WAAW,EAAEA;IAFb,IAGAF,aAHJ;;IAIA,IAAI,CAACC,aAAD,IAAkB,CAACC,WAAvB,EAAoC;MAChC,OAAOnJ,WAAP;IACH;;IACD,IAAI;MACAwD,cAAc,EAAEA,cADhB;MAEAG,YAAY,EAAEA;IAFd,IAGA3D,WAHJ;IAIA,IAAIoJ,gBAAgB,GAAGzF,YAAY,CAAC/C,GAAb,CAAiBC,GAAG,IAAI,KAAKwI,iCAAL,CAAuCxI,GAAvC,EAA4CqI,aAA5C,EAA2DC,WAA3D,CAAxB,CAAvB;;IACA,IAAIG,aAAa,GAAG,KAAKD,iCAAL,CAAuC7F,cAAvC,EAAuD0F,aAAvD,EAAsEC,WAAtE,CAApB;;IACA,OAAO;MACH3F,cAAc,EAAE8F,aADb;MAEH3F,YAAY,EAAEyF;IAFX,CAAP;EAIH;;EACDC,iCAAiC,CAACE,OAAD,EAAUL,aAAV,EAAyBC,WAAzB,EAAsC;IACnE,OAAOI,OAAO,CAAC3I,GAAR,CAAYkB,IAAI,IAAI;MACvB,IAAI;QACAd,KAAK,EAAEA,KADP;QAEAC,UAAU,EAAEA,UAFZ;QAGAsB,MAAM,EAAEA,MAHR;QAIAwD,SAAS,EAAEA;MAJX,IAKAjE,IAAI,CAACV,QALT;MAMA,IAAIoI,oBAAoB,GAAGN,aAAa,CAACO,SAAd,CAAwBC,KAAK,IAAI;QACxD,IAAI;UACA1I,KAAK,EAAE2I,iBADP;UAEA1I,UAAU,EAAE2I,sBAFZ;UAGArH,MAAM,EAAEsH,kBAHR;UAIA9D,SAAS,EAAE+D;QAJX,IAKAJ,KALJ;QAMA,OAAOzI,UAAU,KAAK2I,sBAAf,KAA0C5I,KAAK,KAAK2I,iBAAV,IAA+B,KAAK,CAAL,KAAWA,iBAAX,IAAgC5D,SAAS,CAAC0B,OAAV,OAAwBqC,qBAAqB,CAACrC,OAAtB,EAAjI,KAAqK,CAAC,CAAClF,MAAF,KAAa,CAAC,CAACsH,kBAA3L;MACH,CAR0B,CAA3B;MASA,IAAIE,SAAS,GAAG,CAAC,CAACZ,WAAF,IAAiBnI,KAAK,KAAKmI,WAAW,CAAC/H,QAAZ,CAAqBJ,KAAhD,IAAyDC,UAAU,KAAKkI,WAAW,CAAC/H,QAAZ,CAAqBH,UAA7F,IAA2GsB,MAAM,KAAK4G,WAAW,CAAC/H,QAAZ,CAAqBmB,MAA3J;;MACA,IAAI,CAACwH,SAAD,IAAc,CAAC,CAAD,KAAOP,oBAAzB,EAA+C;QAC3C,OAAO1H,IAAP;MACH;;MACD,OAAO1E,QAAQ,CAAC,EAAD,EAAK0E,IAAL,EAAW;QACtBV,QAAQ,EAAEhE,QAAQ,CAAC,EAAD,EAAK0E,IAAI,CAACV,QAAV,EAAoB;UAClC4I,UAAU,EAAER,oBAAoB,GAAG,CAAC,CADF;UAElCO,SAAS,EAAEA;QAFuB,CAApB;MADI,CAAX,CAAf;IAMH,CA1BM,CAAP;EA2BH;;EACDE,WAAW,CAACzK,aAAD,EAAgB;IACvB,OAAOA,aAAa,GAAGrB,OAAvB;EACH;;EACD+L,oBAAoB,CAAC/K,aAAD,EAAgB;IAChC,OAAO9B,SAAS,CAACe,kBAAV,CAA6B,KAA7B,IAAsCe,aAA7C;EACH;;EACDM,mBAAmB,GAAG,CAAE;;EACxBwG,iBAAiB,CAAC3G,YAAD,EAAeC,UAAf,EAA2BC,aAA3B,EAA0C;IACvD,IAAImB,MAAM,GAAGjD,oBAAoB,CAAC4B,YAAD,EAAeC,UAAf,CAApB,GAAiDC,aAA9D;IACA,OAAOmH,IAAI,CAACwD,IAAL,CAAUxJ,MAAV,CAAP;EACH;;EACDd,YAAY,CAACjB,OAAD,EAAU;IAClB,IAAI;MACAO,aAAa,EAAEA,aADf;MAEAE,QAAQ,EAAEA,QAFV;MAGAC,YAAY,EAAEA,YAHd;MAIAC,UAAU,EAAEA,UAJZ;MAKAC,aAAa,EAAEA;IALf,IAMAZ,OANJ;IAOA,IAAI0H,cAAc,GAAG,KAAKL,iBAAL,CAAuB3G,YAAvB,EAAqCC,UAArC,EAAiDC,aAAjD,CAArB;IACA,IAAI4K,gBAAgB,GAAGzM,gBAAgB,CAAC0B,QAAD,CAAhB,GAA6BiH,cAA7B,GAA8C,CAArE;IACA,OAAO,KAAK/H,cAAL,GAAsBY,aAAtB,GAAsCiL,gBAA7C;EACH;;EACDrK,WAAW,CAACnB,OAAD,EAAU;IACjB,IAAI;MACAS,QAAQ,EAAEA,QADV;MAEAC,YAAY,EAAEA,YAFd;MAGAC,UAAU,EAAEA,UAHZ;MAIAC,aAAa,EAAEA;IAJf,IAKAZ,OALJ;IAMA,IAAI0H,cAAc,GAAG,KAAKL,iBAAL,CAAuB3G,YAAvB,EAAqCC,UAArC,EAAiDC,aAAjD,CAArB;IACA,IAAI6K,aAAa,GAAG,CAAC1M,gBAAgB,CAAC0B,QAAD,CAAjB,GAA8BiH,cAA9B,GAA+C,CAAnE;IACA,OAAO+D,aAAP;EACH;;EACD3K,iBAAiB,CAACJ,YAAD,EAAeC,UAAf,EAA2BC,aAA3B,EAA0C;IACvD,KAAKuI,cAAL,GAAsB1J,MAAM,GAAG,KAAKiM,qBAAL,CAA2BhL,YAA3B,EAAyCC,UAAzC,EAAqDC,aAArD,CAA/B;EACH;;EACD8K,qBAAqB,CAAChL,YAAD,EAAeC,UAAf,EAA2BC,aAA3B,EAA0C;IAC3D,IAAI8G,cAAc,GAAG,KAAKL,iBAAL,CAAuB3G,YAAvB,EAAqCC,UAArC,EAAiDC,aAAjD,CAArB;IACA,OAAOA,aAAa,GAAG8G,cAAhB,GAAiCnI,OAAxC;EACH;;EACDoJ,iBAAiB,CAACgD,oBAAD,EAAuB;IACpC,OAAOA,oBAAP;EACH;;AAthB0B"},"metadata":{},"sourceType":"module"}